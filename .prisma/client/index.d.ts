
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model WorkingCapital
 * 
 */
export type WorkingCapital = $Result.DefaultSelection<Prisma.$WorkingCapitalPayload>
/**
 * Model CashRunway
 * 
 */
export type CashRunway = $Result.DefaultSelection<Prisma.$CashRunwayPayload>
/**
 * Model Production
 * 
 */
export type Production = $Result.DefaultSelection<Prisma.$ProductionPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model InventoryMovement
 * 
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model AIInsight
 * 
 */
export type AIInsight = $Result.DefaultSelection<Prisma.$AIInsightPayload>
/**
 * Model Dashboard
 * 
 */
export type Dashboard = $Result.DefaultSelection<Prisma.$DashboardPayload>
/**
 * Model Analytics
 * 
 */
export type Analytics = $Result.DefaultSelection<Prisma.$AnalyticsPayload>
/**
 * Model MCPRequest
 * 
 */
export type MCPRequest = $Result.DefaultSelection<Prisma.$MCPRequestPayload>
/**
 * Model CashLedger
 * 
 */
export type CashLedger = $Result.DefaultSelection<Prisma.$CashLedgerPayload>
/**
 * Model CashProjection
 * 
 */
export type CashProjection = $Result.DefaultSelection<Prisma.$CashProjectionPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model ExecutiveMetric
 * 
 */
export type ExecutiveMetric = $Result.DefaultSelection<Prisma.$ExecutiveMetricPayload>
/**
 * Model ExecutiveAlert
 * 
 */
export type ExecutiveAlert = $Result.DefaultSelection<Prisma.$ExecutiveAlertPayload>
/**
 * Model EnterpriseCashCoverage
 * 
 */
export type EnterpriseCashCoverage = $Result.DefaultSelection<Prisma.$EnterpriseCashCoveragePayload>
/**
 * Model XeroAccount
 * 
 */
export type XeroAccount = $Result.DefaultSelection<Prisma.$XeroAccountPayload>
/**
 * Model XeroContact
 * 
 */
export type XeroContact = $Result.DefaultSelection<Prisma.$XeroContactPayload>
/**
 * Model XeroInvoice
 * 
 */
export type XeroInvoice = $Result.DefaultSelection<Prisma.$XeroInvoicePayload>
/**
 * Model XeroBill
 * 
 */
export type XeroBill = $Result.DefaultSelection<Prisma.$XeroBillPayload>
/**
 * Model XeroPayment
 * 
 */
export type XeroPayment = $Result.DefaultSelection<Prisma.$XeroPaymentPayload>
/**
 * Model XeroBankTransaction
 * 
 */
export type XeroBankTransaction = $Result.DefaultSelection<Prisma.$XeroBankTransactionPayload>
/**
 * Model XeroItem
 * 
 */
export type XeroItem = $Result.DefaultSelection<Prisma.$XeroItemPayload>
/**
 * Model AmazonOrder
 * 
 */
export type AmazonOrder = $Result.DefaultSelection<Prisma.$AmazonOrderPayload>
/**
 * Model AmazonOrderItem
 * 
 */
export type AmazonOrderItem = $Result.DefaultSelection<Prisma.$AmazonOrderItemPayload>
/**
 * Model AmazonInventory
 * 
 */
export type AmazonInventory = $Result.DefaultSelection<Prisma.$AmazonInventoryPayload>
/**
 * Model ShopifyOrder
 * 
 */
export type ShopifyOrder = $Result.DefaultSelection<Prisma.$ShopifyOrderPayload>
/**
 * Model ShopifyLineItem
 * 
 */
export type ShopifyLineItem = $Result.DefaultSelection<Prisma.$ShopifyLineItemPayload>
/**
 * Model ShopifyProduct
 * 
 */
export type ShopifyProduct = $Result.DefaultSelection<Prisma.$ShopifyProductPayload>
/**
 * Model ShopifyVariant
 * 
 */
export type ShopifyVariant = $Result.DefaultSelection<Prisma.$ShopifyVariantPayload>
/**
 * Model Machine
 * 
 */
export type Machine = $Result.DefaultSelection<Prisma.$MachinePayload>
/**
 * Model MachineSensor
 * 
 */
export type MachineSensor = $Result.DefaultSelection<Prisma.$MachineSensorPayload>
/**
 * Model MachineAlert
 * 
 */
export type MachineAlert = $Result.DefaultSelection<Prisma.$MachineAlertPayload>
/**
 * Model MachineMaintenanceRecord
 * 
 */
export type MachineMaintenanceRecord = $Result.DefaultSelection<Prisma.$MachineMaintenanceRecordPayload>
/**
 * Model QualityCheck
 * 
 */
export type QualityCheck = $Result.DefaultSelection<Prisma.$QualityCheckPayload>
/**
 * Model ProductionOrder
 * 
 */
export type ProductionOrder = $Result.DefaultSelection<Prisma.$ProductionOrderPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  OPERATOR: 'OPERATOR',
  VIEWER: 'VIEWER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ProductionStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  DELAYED: 'DELAYED',
  CANCELLED: 'CANCELLED'
};

export type ProductionStatus = (typeof ProductionStatus)[keyof typeof ProductionStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const MovementType: {
  IN: 'IN',
  OUT: 'OUT',
  ADJUSTMENT: 'ADJUSTMENT',
  TRANSFER: 'TRANSFER'
};

export type MovementType = (typeof MovementType)[keyof typeof MovementType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type ProductionStatus = $Enums.ProductionStatus

export const ProductionStatus: typeof $Enums.ProductionStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type MovementType = $Enums.MovementType

export const MovementType: typeof $Enums.MovementType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workingCapital`: Exposes CRUD operations for the **WorkingCapital** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkingCapitals
    * const workingCapitals = await prisma.workingCapital.findMany()
    * ```
    */
  get workingCapital(): Prisma.WorkingCapitalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashRunway`: Exposes CRUD operations for the **CashRunway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashRunways
    * const cashRunways = await prisma.cashRunway.findMany()
    * ```
    */
  get cashRunway(): Prisma.CashRunwayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.production`: Exposes CRUD operations for the **Production** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productions
    * const productions = await prisma.production.findMany()
    * ```
    */
  get production(): Prisma.ProductionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIInsight`: Exposes CRUD operations for the **AIInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIInsights
    * const aIInsights = await prisma.aIInsight.findMany()
    * ```
    */
  get aIInsight(): Prisma.AIInsightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboard`: Exposes CRUD operations for the **Dashboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dashboards
    * const dashboards = await prisma.dashboard.findMany()
    * ```
    */
  get dashboard(): Prisma.DashboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analytics`: Exposes CRUD operations for the **Analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analytics
    * const analytics = await prisma.analytics.findMany()
    * ```
    */
  get analytics(): Prisma.AnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mCPRequest`: Exposes CRUD operations for the **MCPRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCPRequests
    * const mCPRequests = await prisma.mCPRequest.findMany()
    * ```
    */
  get mCPRequest(): Prisma.MCPRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashLedger`: Exposes CRUD operations for the **CashLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashLedgers
    * const cashLedgers = await prisma.cashLedger.findMany()
    * ```
    */
  get cashLedger(): Prisma.CashLedgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashProjection`: Exposes CRUD operations for the **CashProjection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashProjections
    * const cashProjections = await prisma.cashProjection.findMany()
    * ```
    */
  get cashProjection(): Prisma.CashProjectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.executiveMetric`: Exposes CRUD operations for the **ExecutiveMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExecutiveMetrics
    * const executiveMetrics = await prisma.executiveMetric.findMany()
    * ```
    */
  get executiveMetric(): Prisma.ExecutiveMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.executiveAlert`: Exposes CRUD operations for the **ExecutiveAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExecutiveAlerts
    * const executiveAlerts = await prisma.executiveAlert.findMany()
    * ```
    */
  get executiveAlert(): Prisma.ExecutiveAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enterpriseCashCoverage`: Exposes CRUD operations for the **EnterpriseCashCoverage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnterpriseCashCoverages
    * const enterpriseCashCoverages = await prisma.enterpriseCashCoverage.findMany()
    * ```
    */
  get enterpriseCashCoverage(): Prisma.EnterpriseCashCoverageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xeroAccount`: Exposes CRUD operations for the **XeroAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XeroAccounts
    * const xeroAccounts = await prisma.xeroAccount.findMany()
    * ```
    */
  get xeroAccount(): Prisma.XeroAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xeroContact`: Exposes CRUD operations for the **XeroContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XeroContacts
    * const xeroContacts = await prisma.xeroContact.findMany()
    * ```
    */
  get xeroContact(): Prisma.XeroContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xeroInvoice`: Exposes CRUD operations for the **XeroInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XeroInvoices
    * const xeroInvoices = await prisma.xeroInvoice.findMany()
    * ```
    */
  get xeroInvoice(): Prisma.XeroInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xeroBill`: Exposes CRUD operations for the **XeroBill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XeroBills
    * const xeroBills = await prisma.xeroBill.findMany()
    * ```
    */
  get xeroBill(): Prisma.XeroBillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xeroPayment`: Exposes CRUD operations for the **XeroPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XeroPayments
    * const xeroPayments = await prisma.xeroPayment.findMany()
    * ```
    */
  get xeroPayment(): Prisma.XeroPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xeroBankTransaction`: Exposes CRUD operations for the **XeroBankTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XeroBankTransactions
    * const xeroBankTransactions = await prisma.xeroBankTransaction.findMany()
    * ```
    */
  get xeroBankTransaction(): Prisma.XeroBankTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.xeroItem`: Exposes CRUD operations for the **XeroItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more XeroItems
    * const xeroItems = await prisma.xeroItem.findMany()
    * ```
    */
  get xeroItem(): Prisma.XeroItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amazonOrder`: Exposes CRUD operations for the **AmazonOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmazonOrders
    * const amazonOrders = await prisma.amazonOrder.findMany()
    * ```
    */
  get amazonOrder(): Prisma.AmazonOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amazonOrderItem`: Exposes CRUD operations for the **AmazonOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmazonOrderItems
    * const amazonOrderItems = await prisma.amazonOrderItem.findMany()
    * ```
    */
  get amazonOrderItem(): Prisma.AmazonOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amazonInventory`: Exposes CRUD operations for the **AmazonInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmazonInventories
    * const amazonInventories = await prisma.amazonInventory.findMany()
    * ```
    */
  get amazonInventory(): Prisma.AmazonInventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopifyOrder`: Exposes CRUD operations for the **ShopifyOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopifyOrders
    * const shopifyOrders = await prisma.shopifyOrder.findMany()
    * ```
    */
  get shopifyOrder(): Prisma.ShopifyOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopifyLineItem`: Exposes CRUD operations for the **ShopifyLineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopifyLineItems
    * const shopifyLineItems = await prisma.shopifyLineItem.findMany()
    * ```
    */
  get shopifyLineItem(): Prisma.ShopifyLineItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopifyProduct`: Exposes CRUD operations for the **ShopifyProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopifyProducts
    * const shopifyProducts = await prisma.shopifyProduct.findMany()
    * ```
    */
  get shopifyProduct(): Prisma.ShopifyProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopifyVariant`: Exposes CRUD operations for the **ShopifyVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopifyVariants
    * const shopifyVariants = await prisma.shopifyVariant.findMany()
    * ```
    */
  get shopifyVariant(): Prisma.ShopifyVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.machine`: Exposes CRUD operations for the **Machine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machines
    * const machines = await prisma.machine.findMany()
    * ```
    */
  get machine(): Prisma.MachineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.machineSensor`: Exposes CRUD operations for the **MachineSensor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MachineSensors
    * const machineSensors = await prisma.machineSensor.findMany()
    * ```
    */
  get machineSensor(): Prisma.MachineSensorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.machineAlert`: Exposes CRUD operations for the **MachineAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MachineAlerts
    * const machineAlerts = await prisma.machineAlert.findMany()
    * ```
    */
  get machineAlert(): Prisma.MachineAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.machineMaintenanceRecord`: Exposes CRUD operations for the **MachineMaintenanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MachineMaintenanceRecords
    * const machineMaintenanceRecords = await prisma.machineMaintenanceRecord.findMany()
    * ```
    */
  get machineMaintenanceRecord(): Prisma.MachineMaintenanceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qualityCheck`: Exposes CRUD operations for the **QualityCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QualityChecks
    * const qualityChecks = await prisma.qualityCheck.findMany()
    * ```
    */
  get qualityCheck(): Prisma.QualityCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productionOrder`: Exposes CRUD operations for the **ProductionOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionOrders
    * const productionOrders = await prisma.productionOrder.findMany()
    * ```
    */
  get productionOrder(): Prisma.ProductionOrderDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    WorkingCapital: 'WorkingCapital',
    CashRunway: 'CashRunway',
    Production: 'Production',
    Inventory: 'Inventory',
    InventoryMovement: 'InventoryMovement',
    AIInsight: 'AIInsight',
    Dashboard: 'Dashboard',
    Analytics: 'Analytics',
    MCPRequest: 'MCPRequest',
    CashLedger: 'CashLedger',
    CashProjection: 'CashProjection',
    Expense: 'Expense',
    ExecutiveMetric: 'ExecutiveMetric',
    ExecutiveAlert: 'ExecutiveAlert',
    EnterpriseCashCoverage: 'EnterpriseCashCoverage',
    XeroAccount: 'XeroAccount',
    XeroContact: 'XeroContact',
    XeroInvoice: 'XeroInvoice',
    XeroBill: 'XeroBill',
    XeroPayment: 'XeroPayment',
    XeroBankTransaction: 'XeroBankTransaction',
    XeroItem: 'XeroItem',
    AmazonOrder: 'AmazonOrder',
    AmazonOrderItem: 'AmazonOrderItem',
    AmazonInventory: 'AmazonInventory',
    ShopifyOrder: 'ShopifyOrder',
    ShopifyLineItem: 'ShopifyLineItem',
    ShopifyProduct: 'ShopifyProduct',
    ShopifyVariant: 'ShopifyVariant',
    Machine: 'Machine',
    MachineSensor: 'MachineSensor',
    MachineAlert: 'MachineAlert',
    MachineMaintenanceRecord: 'MachineMaintenanceRecord',
    QualityCheck: 'QualityCheck',
    ProductionOrder: 'ProductionOrder'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "workingCapital" | "cashRunway" | "production" | "inventory" | "inventoryMovement" | "aIInsight" | "dashboard" | "analytics" | "mCPRequest" | "cashLedger" | "cashProjection" | "expense" | "executiveMetric" | "executiveAlert" | "enterpriseCashCoverage" | "xeroAccount" | "xeroContact" | "xeroInvoice" | "xeroBill" | "xeroPayment" | "xeroBankTransaction" | "xeroItem" | "amazonOrder" | "amazonOrderItem" | "amazonInventory" | "shopifyOrder" | "shopifyLineItem" | "shopifyProduct" | "shopifyVariant" | "machine" | "machineSensor" | "machineAlert" | "machineMaintenanceRecord" | "qualityCheck" | "productionOrder"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      WorkingCapital: {
        payload: Prisma.$WorkingCapitalPayload<ExtArgs>
        fields: Prisma.WorkingCapitalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkingCapitalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkingCapitalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>
          }
          findFirst: {
            args: Prisma.WorkingCapitalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkingCapitalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>
          }
          findMany: {
            args: Prisma.WorkingCapitalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>[]
          }
          create: {
            args: Prisma.WorkingCapitalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>
          }
          createMany: {
            args: Prisma.WorkingCapitalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkingCapitalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>[]
          }
          delete: {
            args: Prisma.WorkingCapitalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>
          }
          update: {
            args: Prisma.WorkingCapitalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>
          }
          deleteMany: {
            args: Prisma.WorkingCapitalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkingCapitalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkingCapitalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>[]
          }
          upsert: {
            args: Prisma.WorkingCapitalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkingCapitalPayload>
          }
          aggregate: {
            args: Prisma.WorkingCapitalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkingCapital>
          }
          groupBy: {
            args: Prisma.WorkingCapitalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkingCapitalGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkingCapitalCountArgs<ExtArgs>
            result: $Utils.Optional<WorkingCapitalCountAggregateOutputType> | number
          }
        }
      }
      CashRunway: {
        payload: Prisma.$CashRunwayPayload<ExtArgs>
        fields: Prisma.CashRunwayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashRunwayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashRunwayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>
          }
          findFirst: {
            args: Prisma.CashRunwayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashRunwayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>
          }
          findMany: {
            args: Prisma.CashRunwayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>[]
          }
          create: {
            args: Prisma.CashRunwayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>
          }
          createMany: {
            args: Prisma.CashRunwayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashRunwayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>[]
          }
          delete: {
            args: Prisma.CashRunwayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>
          }
          update: {
            args: Prisma.CashRunwayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>
          }
          deleteMany: {
            args: Prisma.CashRunwayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashRunwayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashRunwayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>[]
          }
          upsert: {
            args: Prisma.CashRunwayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRunwayPayload>
          }
          aggregate: {
            args: Prisma.CashRunwayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashRunway>
          }
          groupBy: {
            args: Prisma.CashRunwayGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashRunwayGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashRunwayCountArgs<ExtArgs>
            result: $Utils.Optional<CashRunwayCountAggregateOutputType> | number
          }
        }
      }
      Production: {
        payload: Prisma.$ProductionPayload<ExtArgs>
        fields: Prisma.ProductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          findFirst: {
            args: Prisma.ProductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          findMany: {
            args: Prisma.ProductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>[]
          }
          create: {
            args: Prisma.ProductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          createMany: {
            args: Prisma.ProductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>[]
          }
          delete: {
            args: Prisma.ProductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          update: {
            args: Prisma.ProductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          deleteMany: {
            args: Prisma.ProductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>[]
          }
          upsert: {
            args: Prisma.ProductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionPayload>
          }
          aggregate: {
            args: Prisma.ProductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduction>
          }
          groupBy: {
            args: Prisma.ProductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      AIInsight: {
        payload: Prisma.$AIInsightPayload<ExtArgs>
        fields: Prisma.AIInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          findFirst: {
            args: Prisma.AIInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          findMany: {
            args: Prisma.AIInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>[]
          }
          create: {
            args: Prisma.AIInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          createMany: {
            args: Prisma.AIInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>[]
          }
          delete: {
            args: Prisma.AIInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          update: {
            args: Prisma.AIInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          deleteMany: {
            args: Prisma.AIInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIInsightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>[]
          }
          upsert: {
            args: Prisma.AIInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInsightPayload>
          }
          aggregate: {
            args: Prisma.AIInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIInsight>
          }
          groupBy: {
            args: Prisma.AIInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIInsightCountArgs<ExtArgs>
            result: $Utils.Optional<AIInsightCountAggregateOutputType> | number
          }
        }
      }
      Dashboard: {
        payload: Prisma.$DashboardPayload<ExtArgs>
        fields: Prisma.DashboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          findFirst: {
            args: Prisma.DashboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          findMany: {
            args: Prisma.DashboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          create: {
            args: Prisma.DashboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          createMany: {
            args: Prisma.DashboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          delete: {
            args: Prisma.DashboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          update: {
            args: Prisma.DashboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          deleteMany: {
            args: Prisma.DashboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          upsert: {
            args: Prisma.DashboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          aggregate: {
            args: Prisma.DashboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboard>
          }
          groupBy: {
            args: Prisma.DashboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardCountAggregateOutputType> | number
          }
        }
      }
      Analytics: {
        payload: Prisma.$AnalyticsPayload<ExtArgs>
        fields: Prisma.AnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findMany: {
            args: Prisma.AnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          create: {
            args: Prisma.AnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          createMany: {
            args: Prisma.AnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          update: {
            args: Prisma.AnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalytics>
          }
          groupBy: {
            args: Prisma.AnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCountAggregateOutputType> | number
          }
        }
      }
      MCPRequest: {
        payload: Prisma.$MCPRequestPayload<ExtArgs>
        fields: Prisma.MCPRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCPRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCPRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>
          }
          findFirst: {
            args: Prisma.MCPRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCPRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>
          }
          findMany: {
            args: Prisma.MCPRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>[]
          }
          create: {
            args: Prisma.MCPRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>
          }
          createMany: {
            args: Prisma.MCPRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MCPRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>[]
          }
          delete: {
            args: Prisma.MCPRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>
          }
          update: {
            args: Prisma.MCPRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>
          }
          deleteMany: {
            args: Prisma.MCPRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MCPRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MCPRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>[]
          }
          upsert: {
            args: Prisma.MCPRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MCPRequestPayload>
          }
          aggregate: {
            args: Prisma.MCPRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMCPRequest>
          }
          groupBy: {
            args: Prisma.MCPRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MCPRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCPRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MCPRequestCountAggregateOutputType> | number
          }
        }
      }
      CashLedger: {
        payload: Prisma.$CashLedgerPayload<ExtArgs>
        fields: Prisma.CashLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>
          }
          findFirst: {
            args: Prisma.CashLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>
          }
          findMany: {
            args: Prisma.CashLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>[]
          }
          create: {
            args: Prisma.CashLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>
          }
          createMany: {
            args: Prisma.CashLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>[]
          }
          delete: {
            args: Prisma.CashLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>
          }
          update: {
            args: Prisma.CashLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>
          }
          deleteMany: {
            args: Prisma.CashLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashLedgerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>[]
          }
          upsert: {
            args: Prisma.CashLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashLedgerPayload>
          }
          aggregate: {
            args: Prisma.CashLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashLedger>
          }
          groupBy: {
            args: Prisma.CashLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<CashLedgerCountAggregateOutputType> | number
          }
        }
      }
      CashProjection: {
        payload: Prisma.$CashProjectionPayload<ExtArgs>
        fields: Prisma.CashProjectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashProjectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashProjectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>
          }
          findFirst: {
            args: Prisma.CashProjectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashProjectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>
          }
          findMany: {
            args: Prisma.CashProjectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>[]
          }
          create: {
            args: Prisma.CashProjectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>
          }
          createMany: {
            args: Prisma.CashProjectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashProjectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>[]
          }
          delete: {
            args: Prisma.CashProjectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>
          }
          update: {
            args: Prisma.CashProjectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>
          }
          deleteMany: {
            args: Prisma.CashProjectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashProjectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashProjectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>[]
          }
          upsert: {
            args: Prisma.CashProjectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashProjectionPayload>
          }
          aggregate: {
            args: Prisma.CashProjectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashProjection>
          }
          groupBy: {
            args: Prisma.CashProjectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashProjectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashProjectionCountArgs<ExtArgs>
            result: $Utils.Optional<CashProjectionCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      ExecutiveMetric: {
        payload: Prisma.$ExecutiveMetricPayload<ExtArgs>
        fields: Prisma.ExecutiveMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutiveMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutiveMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>
          }
          findFirst: {
            args: Prisma.ExecutiveMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutiveMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>
          }
          findMany: {
            args: Prisma.ExecutiveMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>[]
          }
          create: {
            args: Prisma.ExecutiveMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>
          }
          createMany: {
            args: Prisma.ExecutiveMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutiveMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>[]
          }
          delete: {
            args: Prisma.ExecutiveMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>
          }
          update: {
            args: Prisma.ExecutiveMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>
          }
          deleteMany: {
            args: Prisma.ExecutiveMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutiveMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExecutiveMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>[]
          }
          upsert: {
            args: Prisma.ExecutiveMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveMetricPayload>
          }
          aggregate: {
            args: Prisma.ExecutiveMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecutiveMetric>
          }
          groupBy: {
            args: Prisma.ExecutiveMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutiveMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutiveMetricCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutiveMetricCountAggregateOutputType> | number
          }
        }
      }
      ExecutiveAlert: {
        payload: Prisma.$ExecutiveAlertPayload<ExtArgs>
        fields: Prisma.ExecutiveAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutiveAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutiveAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>
          }
          findFirst: {
            args: Prisma.ExecutiveAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutiveAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>
          }
          findMany: {
            args: Prisma.ExecutiveAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>[]
          }
          create: {
            args: Prisma.ExecutiveAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>
          }
          createMany: {
            args: Prisma.ExecutiveAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutiveAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>[]
          }
          delete: {
            args: Prisma.ExecutiveAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>
          }
          update: {
            args: Prisma.ExecutiveAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>
          }
          deleteMany: {
            args: Prisma.ExecutiveAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutiveAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExecutiveAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>[]
          }
          upsert: {
            args: Prisma.ExecutiveAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutiveAlertPayload>
          }
          aggregate: {
            args: Prisma.ExecutiveAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecutiveAlert>
          }
          groupBy: {
            args: Prisma.ExecutiveAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutiveAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutiveAlertCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutiveAlertCountAggregateOutputType> | number
          }
        }
      }
      EnterpriseCashCoverage: {
        payload: Prisma.$EnterpriseCashCoveragePayload<ExtArgs>
        fields: Prisma.EnterpriseCashCoverageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnterpriseCashCoverageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnterpriseCashCoverageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>
          }
          findFirst: {
            args: Prisma.EnterpriseCashCoverageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnterpriseCashCoverageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>
          }
          findMany: {
            args: Prisma.EnterpriseCashCoverageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>[]
          }
          create: {
            args: Prisma.EnterpriseCashCoverageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>
          }
          createMany: {
            args: Prisma.EnterpriseCashCoverageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnterpriseCashCoverageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>[]
          }
          delete: {
            args: Prisma.EnterpriseCashCoverageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>
          }
          update: {
            args: Prisma.EnterpriseCashCoverageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>
          }
          deleteMany: {
            args: Prisma.EnterpriseCashCoverageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnterpriseCashCoverageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnterpriseCashCoverageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>[]
          }
          upsert: {
            args: Prisma.EnterpriseCashCoverageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnterpriseCashCoveragePayload>
          }
          aggregate: {
            args: Prisma.EnterpriseCashCoverageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnterpriseCashCoverage>
          }
          groupBy: {
            args: Prisma.EnterpriseCashCoverageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnterpriseCashCoverageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnterpriseCashCoverageCountArgs<ExtArgs>
            result: $Utils.Optional<EnterpriseCashCoverageCountAggregateOutputType> | number
          }
        }
      }
      XeroAccount: {
        payload: Prisma.$XeroAccountPayload<ExtArgs>
        fields: Prisma.XeroAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XeroAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XeroAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>
          }
          findFirst: {
            args: Prisma.XeroAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XeroAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>
          }
          findMany: {
            args: Prisma.XeroAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>[]
          }
          create: {
            args: Prisma.XeroAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>
          }
          createMany: {
            args: Prisma.XeroAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XeroAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>[]
          }
          delete: {
            args: Prisma.XeroAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>
          }
          update: {
            args: Prisma.XeroAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>
          }
          deleteMany: {
            args: Prisma.XeroAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XeroAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XeroAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>[]
          }
          upsert: {
            args: Prisma.XeroAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroAccountPayload>
          }
          aggregate: {
            args: Prisma.XeroAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXeroAccount>
          }
          groupBy: {
            args: Prisma.XeroAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<XeroAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.XeroAccountCountArgs<ExtArgs>
            result: $Utils.Optional<XeroAccountCountAggregateOutputType> | number
          }
        }
      }
      XeroContact: {
        payload: Prisma.$XeroContactPayload<ExtArgs>
        fields: Prisma.XeroContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XeroContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XeroContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>
          }
          findFirst: {
            args: Prisma.XeroContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XeroContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>
          }
          findMany: {
            args: Prisma.XeroContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>[]
          }
          create: {
            args: Prisma.XeroContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>
          }
          createMany: {
            args: Prisma.XeroContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XeroContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>[]
          }
          delete: {
            args: Prisma.XeroContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>
          }
          update: {
            args: Prisma.XeroContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>
          }
          deleteMany: {
            args: Prisma.XeroContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XeroContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XeroContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>[]
          }
          upsert: {
            args: Prisma.XeroContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroContactPayload>
          }
          aggregate: {
            args: Prisma.XeroContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXeroContact>
          }
          groupBy: {
            args: Prisma.XeroContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<XeroContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.XeroContactCountArgs<ExtArgs>
            result: $Utils.Optional<XeroContactCountAggregateOutputType> | number
          }
        }
      }
      XeroInvoice: {
        payload: Prisma.$XeroInvoicePayload<ExtArgs>
        fields: Prisma.XeroInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XeroInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XeroInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>
          }
          findFirst: {
            args: Prisma.XeroInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XeroInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>
          }
          findMany: {
            args: Prisma.XeroInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>[]
          }
          create: {
            args: Prisma.XeroInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>
          }
          createMany: {
            args: Prisma.XeroInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XeroInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>[]
          }
          delete: {
            args: Prisma.XeroInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>
          }
          update: {
            args: Prisma.XeroInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>
          }
          deleteMany: {
            args: Prisma.XeroInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XeroInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XeroInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>[]
          }
          upsert: {
            args: Prisma.XeroInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroInvoicePayload>
          }
          aggregate: {
            args: Prisma.XeroInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXeroInvoice>
          }
          groupBy: {
            args: Prisma.XeroInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<XeroInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.XeroInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<XeroInvoiceCountAggregateOutputType> | number
          }
        }
      }
      XeroBill: {
        payload: Prisma.$XeroBillPayload<ExtArgs>
        fields: Prisma.XeroBillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XeroBillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XeroBillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>
          }
          findFirst: {
            args: Prisma.XeroBillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XeroBillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>
          }
          findMany: {
            args: Prisma.XeroBillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>[]
          }
          create: {
            args: Prisma.XeroBillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>
          }
          createMany: {
            args: Prisma.XeroBillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XeroBillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>[]
          }
          delete: {
            args: Prisma.XeroBillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>
          }
          update: {
            args: Prisma.XeroBillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>
          }
          deleteMany: {
            args: Prisma.XeroBillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XeroBillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XeroBillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>[]
          }
          upsert: {
            args: Prisma.XeroBillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBillPayload>
          }
          aggregate: {
            args: Prisma.XeroBillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXeroBill>
          }
          groupBy: {
            args: Prisma.XeroBillGroupByArgs<ExtArgs>
            result: $Utils.Optional<XeroBillGroupByOutputType>[]
          }
          count: {
            args: Prisma.XeroBillCountArgs<ExtArgs>
            result: $Utils.Optional<XeroBillCountAggregateOutputType> | number
          }
        }
      }
      XeroPayment: {
        payload: Prisma.$XeroPaymentPayload<ExtArgs>
        fields: Prisma.XeroPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XeroPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XeroPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>
          }
          findFirst: {
            args: Prisma.XeroPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XeroPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>
          }
          findMany: {
            args: Prisma.XeroPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>[]
          }
          create: {
            args: Prisma.XeroPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>
          }
          createMany: {
            args: Prisma.XeroPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XeroPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>[]
          }
          delete: {
            args: Prisma.XeroPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>
          }
          update: {
            args: Prisma.XeroPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>
          }
          deleteMany: {
            args: Prisma.XeroPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XeroPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XeroPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>[]
          }
          upsert: {
            args: Prisma.XeroPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroPaymentPayload>
          }
          aggregate: {
            args: Prisma.XeroPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXeroPayment>
          }
          groupBy: {
            args: Prisma.XeroPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<XeroPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.XeroPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<XeroPaymentCountAggregateOutputType> | number
          }
        }
      }
      XeroBankTransaction: {
        payload: Prisma.$XeroBankTransactionPayload<ExtArgs>
        fields: Prisma.XeroBankTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XeroBankTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XeroBankTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>
          }
          findFirst: {
            args: Prisma.XeroBankTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XeroBankTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>
          }
          findMany: {
            args: Prisma.XeroBankTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>[]
          }
          create: {
            args: Prisma.XeroBankTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>
          }
          createMany: {
            args: Prisma.XeroBankTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XeroBankTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>[]
          }
          delete: {
            args: Prisma.XeroBankTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>
          }
          update: {
            args: Prisma.XeroBankTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>
          }
          deleteMany: {
            args: Prisma.XeroBankTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XeroBankTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XeroBankTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>[]
          }
          upsert: {
            args: Prisma.XeroBankTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroBankTransactionPayload>
          }
          aggregate: {
            args: Prisma.XeroBankTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXeroBankTransaction>
          }
          groupBy: {
            args: Prisma.XeroBankTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<XeroBankTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.XeroBankTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<XeroBankTransactionCountAggregateOutputType> | number
          }
        }
      }
      XeroItem: {
        payload: Prisma.$XeroItemPayload<ExtArgs>
        fields: Prisma.XeroItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.XeroItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.XeroItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>
          }
          findFirst: {
            args: Prisma.XeroItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.XeroItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>
          }
          findMany: {
            args: Prisma.XeroItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>[]
          }
          create: {
            args: Prisma.XeroItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>
          }
          createMany: {
            args: Prisma.XeroItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.XeroItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>[]
          }
          delete: {
            args: Prisma.XeroItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>
          }
          update: {
            args: Prisma.XeroItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>
          }
          deleteMany: {
            args: Prisma.XeroItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.XeroItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.XeroItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>[]
          }
          upsert: {
            args: Prisma.XeroItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$XeroItemPayload>
          }
          aggregate: {
            args: Prisma.XeroItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateXeroItem>
          }
          groupBy: {
            args: Prisma.XeroItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<XeroItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.XeroItemCountArgs<ExtArgs>
            result: $Utils.Optional<XeroItemCountAggregateOutputType> | number
          }
        }
      }
      AmazonOrder: {
        payload: Prisma.$AmazonOrderPayload<ExtArgs>
        fields: Prisma.AmazonOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmazonOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmazonOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>
          }
          findFirst: {
            args: Prisma.AmazonOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmazonOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>
          }
          findMany: {
            args: Prisma.AmazonOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>[]
          }
          create: {
            args: Prisma.AmazonOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>
          }
          createMany: {
            args: Prisma.AmazonOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmazonOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>[]
          }
          delete: {
            args: Prisma.AmazonOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>
          }
          update: {
            args: Prisma.AmazonOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>
          }
          deleteMany: {
            args: Prisma.AmazonOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmazonOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmazonOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>[]
          }
          upsert: {
            args: Prisma.AmazonOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderPayload>
          }
          aggregate: {
            args: Prisma.AmazonOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmazonOrder>
          }
          groupBy: {
            args: Prisma.AmazonOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmazonOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmazonOrderCountArgs<ExtArgs>
            result: $Utils.Optional<AmazonOrderCountAggregateOutputType> | number
          }
        }
      }
      AmazonOrderItem: {
        payload: Prisma.$AmazonOrderItemPayload<ExtArgs>
        fields: Prisma.AmazonOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmazonOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmazonOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>
          }
          findFirst: {
            args: Prisma.AmazonOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmazonOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>
          }
          findMany: {
            args: Prisma.AmazonOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>[]
          }
          create: {
            args: Prisma.AmazonOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>
          }
          createMany: {
            args: Prisma.AmazonOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmazonOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>[]
          }
          delete: {
            args: Prisma.AmazonOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>
          }
          update: {
            args: Prisma.AmazonOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.AmazonOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmazonOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmazonOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.AmazonOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonOrderItemPayload>
          }
          aggregate: {
            args: Prisma.AmazonOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmazonOrderItem>
          }
          groupBy: {
            args: Prisma.AmazonOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmazonOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmazonOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<AmazonOrderItemCountAggregateOutputType> | number
          }
        }
      }
      AmazonInventory: {
        payload: Prisma.$AmazonInventoryPayload<ExtArgs>
        fields: Prisma.AmazonInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmazonInventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmazonInventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>
          }
          findFirst: {
            args: Prisma.AmazonInventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmazonInventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>
          }
          findMany: {
            args: Prisma.AmazonInventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>[]
          }
          create: {
            args: Prisma.AmazonInventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>
          }
          createMany: {
            args: Prisma.AmazonInventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmazonInventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>[]
          }
          delete: {
            args: Prisma.AmazonInventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>
          }
          update: {
            args: Prisma.AmazonInventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>
          }
          deleteMany: {
            args: Prisma.AmazonInventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmazonInventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmazonInventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>[]
          }
          upsert: {
            args: Prisma.AmazonInventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmazonInventoryPayload>
          }
          aggregate: {
            args: Prisma.AmazonInventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmazonInventory>
          }
          groupBy: {
            args: Prisma.AmazonInventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmazonInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmazonInventoryCountArgs<ExtArgs>
            result: $Utils.Optional<AmazonInventoryCountAggregateOutputType> | number
          }
        }
      }
      ShopifyOrder: {
        payload: Prisma.$ShopifyOrderPayload<ExtArgs>
        fields: Prisma.ShopifyOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopifyOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopifyOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>
          }
          findFirst: {
            args: Prisma.ShopifyOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopifyOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>
          }
          findMany: {
            args: Prisma.ShopifyOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>[]
          }
          create: {
            args: Prisma.ShopifyOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>
          }
          createMany: {
            args: Prisma.ShopifyOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopifyOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>[]
          }
          delete: {
            args: Prisma.ShopifyOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>
          }
          update: {
            args: Prisma.ShopifyOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>
          }
          deleteMany: {
            args: Prisma.ShopifyOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopifyOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopifyOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>[]
          }
          upsert: {
            args: Prisma.ShopifyOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyOrderPayload>
          }
          aggregate: {
            args: Prisma.ShopifyOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopifyOrder>
          }
          groupBy: {
            args: Prisma.ShopifyOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopifyOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopifyOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ShopifyOrderCountAggregateOutputType> | number
          }
        }
      }
      ShopifyLineItem: {
        payload: Prisma.$ShopifyLineItemPayload<ExtArgs>
        fields: Prisma.ShopifyLineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopifyLineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopifyLineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>
          }
          findFirst: {
            args: Prisma.ShopifyLineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopifyLineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>
          }
          findMany: {
            args: Prisma.ShopifyLineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>[]
          }
          create: {
            args: Prisma.ShopifyLineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>
          }
          createMany: {
            args: Prisma.ShopifyLineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopifyLineItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>[]
          }
          delete: {
            args: Prisma.ShopifyLineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>
          }
          update: {
            args: Prisma.ShopifyLineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>
          }
          deleteMany: {
            args: Prisma.ShopifyLineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopifyLineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopifyLineItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>[]
          }
          upsert: {
            args: Prisma.ShopifyLineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyLineItemPayload>
          }
          aggregate: {
            args: Prisma.ShopifyLineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopifyLineItem>
          }
          groupBy: {
            args: Prisma.ShopifyLineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopifyLineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopifyLineItemCountArgs<ExtArgs>
            result: $Utils.Optional<ShopifyLineItemCountAggregateOutputType> | number
          }
        }
      }
      ShopifyProduct: {
        payload: Prisma.$ShopifyProductPayload<ExtArgs>
        fields: Prisma.ShopifyProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopifyProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopifyProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>
          }
          findFirst: {
            args: Prisma.ShopifyProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopifyProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>
          }
          findMany: {
            args: Prisma.ShopifyProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>[]
          }
          create: {
            args: Prisma.ShopifyProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>
          }
          createMany: {
            args: Prisma.ShopifyProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopifyProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>[]
          }
          delete: {
            args: Prisma.ShopifyProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>
          }
          update: {
            args: Prisma.ShopifyProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>
          }
          deleteMany: {
            args: Prisma.ShopifyProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopifyProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopifyProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>[]
          }
          upsert: {
            args: Prisma.ShopifyProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyProductPayload>
          }
          aggregate: {
            args: Prisma.ShopifyProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopifyProduct>
          }
          groupBy: {
            args: Prisma.ShopifyProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopifyProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopifyProductCountArgs<ExtArgs>
            result: $Utils.Optional<ShopifyProductCountAggregateOutputType> | number
          }
        }
      }
      ShopifyVariant: {
        payload: Prisma.$ShopifyVariantPayload<ExtArgs>
        fields: Prisma.ShopifyVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopifyVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopifyVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>
          }
          findFirst: {
            args: Prisma.ShopifyVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopifyVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>
          }
          findMany: {
            args: Prisma.ShopifyVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>[]
          }
          create: {
            args: Prisma.ShopifyVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>
          }
          createMany: {
            args: Prisma.ShopifyVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopifyVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>[]
          }
          delete: {
            args: Prisma.ShopifyVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>
          }
          update: {
            args: Prisma.ShopifyVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>
          }
          deleteMany: {
            args: Prisma.ShopifyVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopifyVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopifyVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>[]
          }
          upsert: {
            args: Prisma.ShopifyVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopifyVariantPayload>
          }
          aggregate: {
            args: Prisma.ShopifyVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopifyVariant>
          }
          groupBy: {
            args: Prisma.ShopifyVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopifyVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopifyVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ShopifyVariantCountAggregateOutputType> | number
          }
        }
      }
      Machine: {
        payload: Prisma.$MachinePayload<ExtArgs>
        fields: Prisma.MachineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findFirst: {
            args: Prisma.MachineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findMany: {
            args: Prisma.MachineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          create: {
            args: Prisma.MachineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          createMany: {
            args: Prisma.MachineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          delete: {
            args: Prisma.MachineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          update: {
            args: Prisma.MachineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          deleteMany: {
            args: Prisma.MachineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MachineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          upsert: {
            args: Prisma.MachineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          aggregate: {
            args: Prisma.MachineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachine>
          }
          groupBy: {
            args: Prisma.MachineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineCountArgs<ExtArgs>
            result: $Utils.Optional<MachineCountAggregateOutputType> | number
          }
        }
      }
      MachineSensor: {
        payload: Prisma.$MachineSensorPayload<ExtArgs>
        fields: Prisma.MachineSensorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineSensorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineSensorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>
          }
          findFirst: {
            args: Prisma.MachineSensorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineSensorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>
          }
          findMany: {
            args: Prisma.MachineSensorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>[]
          }
          create: {
            args: Prisma.MachineSensorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>
          }
          createMany: {
            args: Prisma.MachineSensorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineSensorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>[]
          }
          delete: {
            args: Prisma.MachineSensorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>
          }
          update: {
            args: Prisma.MachineSensorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>
          }
          deleteMany: {
            args: Prisma.MachineSensorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineSensorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MachineSensorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>[]
          }
          upsert: {
            args: Prisma.MachineSensorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineSensorPayload>
          }
          aggregate: {
            args: Prisma.MachineSensorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachineSensor>
          }
          groupBy: {
            args: Prisma.MachineSensorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineSensorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineSensorCountArgs<ExtArgs>
            result: $Utils.Optional<MachineSensorCountAggregateOutputType> | number
          }
        }
      }
      MachineAlert: {
        payload: Prisma.$MachineAlertPayload<ExtArgs>
        fields: Prisma.MachineAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>
          }
          findFirst: {
            args: Prisma.MachineAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>
          }
          findMany: {
            args: Prisma.MachineAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>[]
          }
          create: {
            args: Prisma.MachineAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>
          }
          createMany: {
            args: Prisma.MachineAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>[]
          }
          delete: {
            args: Prisma.MachineAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>
          }
          update: {
            args: Prisma.MachineAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>
          }
          deleteMany: {
            args: Prisma.MachineAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MachineAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>[]
          }
          upsert: {
            args: Prisma.MachineAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineAlertPayload>
          }
          aggregate: {
            args: Prisma.MachineAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachineAlert>
          }
          groupBy: {
            args: Prisma.MachineAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineAlertCountArgs<ExtArgs>
            result: $Utils.Optional<MachineAlertCountAggregateOutputType> | number
          }
        }
      }
      MachineMaintenanceRecord: {
        payload: Prisma.$MachineMaintenanceRecordPayload<ExtArgs>
        fields: Prisma.MachineMaintenanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineMaintenanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineMaintenanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>
          }
          findFirst: {
            args: Prisma.MachineMaintenanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineMaintenanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>
          }
          findMany: {
            args: Prisma.MachineMaintenanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>[]
          }
          create: {
            args: Prisma.MachineMaintenanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>
          }
          createMany: {
            args: Prisma.MachineMaintenanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineMaintenanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>[]
          }
          delete: {
            args: Prisma.MachineMaintenanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>
          }
          update: {
            args: Prisma.MachineMaintenanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.MachineMaintenanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineMaintenanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MachineMaintenanceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>[]
          }
          upsert: {
            args: Prisma.MachineMaintenanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachineMaintenanceRecordPayload>
          }
          aggregate: {
            args: Prisma.MachineMaintenanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachineMaintenanceRecord>
          }
          groupBy: {
            args: Prisma.MachineMaintenanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineMaintenanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineMaintenanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<MachineMaintenanceRecordCountAggregateOutputType> | number
          }
        }
      }
      QualityCheck: {
        payload: Prisma.$QualityCheckPayload<ExtArgs>
        fields: Prisma.QualityCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QualityCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QualityCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>
          }
          findFirst: {
            args: Prisma.QualityCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QualityCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>
          }
          findMany: {
            args: Prisma.QualityCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>[]
          }
          create: {
            args: Prisma.QualityCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>
          }
          createMany: {
            args: Prisma.QualityCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QualityCheckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>[]
          }
          delete: {
            args: Prisma.QualityCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>
          }
          update: {
            args: Prisma.QualityCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>
          }
          deleteMany: {
            args: Prisma.QualityCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QualityCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QualityCheckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>[]
          }
          upsert: {
            args: Prisma.QualityCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityCheckPayload>
          }
          aggregate: {
            args: Prisma.QualityCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualityCheck>
          }
          groupBy: {
            args: Prisma.QualityCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<QualityCheckGroupByOutputType>[]
          }
          count: {
            args: Prisma.QualityCheckCountArgs<ExtArgs>
            result: $Utils.Optional<QualityCheckCountAggregateOutputType> | number
          }
        }
      }
      ProductionOrder: {
        payload: Prisma.$ProductionOrderPayload<ExtArgs>
        fields: Prisma.ProductionOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          findFirst: {
            args: Prisma.ProductionOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          findMany: {
            args: Prisma.ProductionOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>[]
          }
          create: {
            args: Prisma.ProductionOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          createMany: {
            args: Prisma.ProductionOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>[]
          }
          delete: {
            args: Prisma.ProductionOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          update: {
            args: Prisma.ProductionOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          deleteMany: {
            args: Prisma.ProductionOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductionOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>[]
          }
          upsert: {
            args: Prisma.ProductionOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          aggregate: {
            args: Prisma.ProductionOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionOrder>
          }
          groupBy: {
            args: Prisma.ProductionOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionOrderCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    workingCapital?: WorkingCapitalOmit
    cashRunway?: CashRunwayOmit
    production?: ProductionOmit
    inventory?: InventoryOmit
    inventoryMovement?: InventoryMovementOmit
    aIInsight?: AIInsightOmit
    dashboard?: DashboardOmit
    analytics?: AnalyticsOmit
    mCPRequest?: MCPRequestOmit
    cashLedger?: CashLedgerOmit
    cashProjection?: CashProjectionOmit
    expense?: ExpenseOmit
    executiveMetric?: ExecutiveMetricOmit
    executiveAlert?: ExecutiveAlertOmit
    enterpriseCashCoverage?: EnterpriseCashCoverageOmit
    xeroAccount?: XeroAccountOmit
    xeroContact?: XeroContactOmit
    xeroInvoice?: XeroInvoiceOmit
    xeroBill?: XeroBillOmit
    xeroPayment?: XeroPaymentOmit
    xeroBankTransaction?: XeroBankTransactionOmit
    xeroItem?: XeroItemOmit
    amazonOrder?: AmazonOrderOmit
    amazonOrderItem?: AmazonOrderItemOmit
    amazonInventory?: AmazonInventoryOmit
    shopifyOrder?: ShopifyOrderOmit
    shopifyLineItem?: ShopifyLineItemOmit
    shopifyProduct?: ShopifyProductOmit
    shopifyVariant?: ShopifyVariantOmit
    machine?: MachineOmit
    machineSensor?: MachineSensorOmit
    machineAlert?: MachineAlertOmit
    machineMaintenanceRecord?: MachineMaintenanceRecordOmit
    qualityCheck?: QualityCheckOmit
    productionOrder?: ProductionOrderOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    dashboards: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboards?: boolean | UserCountOutputTypeCountDashboardsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDashboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardWhereInput
  }


  /**
   * Count Type ProductionCountOutputType
   */

  export type ProductionCountOutputType = {
    qualityChecks: number
  }

  export type ProductionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qualityChecks?: boolean | ProductionCountOutputTypeCountQualityChecksArgs
  }

  // Custom InputTypes
  /**
   * ProductionCountOutputType without action
   */
  export type ProductionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionCountOutputType
     */
    select?: ProductionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionCountOutputType without action
   */
  export type ProductionCountOutputTypeCountQualityChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityCheckWhereInput
  }


  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    movements: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | InventoryCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type XeroContactCountOutputType
   */

  export type XeroContactCountOutputType = {
    invoices: number
    bills: number
    payments: number
  }

  export type XeroContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | XeroContactCountOutputTypeCountInvoicesArgs
    bills?: boolean | XeroContactCountOutputTypeCountBillsArgs
    payments?: boolean | XeroContactCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * XeroContactCountOutputType without action
   */
  export type XeroContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContactCountOutputType
     */
    select?: XeroContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * XeroContactCountOutputType without action
   */
  export type XeroContactCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroInvoiceWhereInput
  }

  /**
   * XeroContactCountOutputType without action
   */
  export type XeroContactCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroBillWhereInput
  }

  /**
   * XeroContactCountOutputType without action
   */
  export type XeroContactCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroPaymentWhereInput
  }


  /**
   * Count Type XeroInvoiceCountOutputType
   */

  export type XeroInvoiceCountOutputType = {
    payments: number
  }

  export type XeroInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | XeroInvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * XeroInvoiceCountOutputType without action
   */
  export type XeroInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoiceCountOutputType
     */
    select?: XeroInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * XeroInvoiceCountOutputType without action
   */
  export type XeroInvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroPaymentWhereInput
  }


  /**
   * Count Type XeroBillCountOutputType
   */

  export type XeroBillCountOutputType = {
    payments: number
  }

  export type XeroBillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | XeroBillCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * XeroBillCountOutputType without action
   */
  export type XeroBillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBillCountOutputType
     */
    select?: XeroBillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * XeroBillCountOutputType without action
   */
  export type XeroBillCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroPaymentWhereInput
  }


  /**
   * Count Type AmazonOrderCountOutputType
   */

  export type AmazonOrderCountOutputType = {
    orderItems: number
  }

  export type AmazonOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | AmazonOrderCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * AmazonOrderCountOutputType without action
   */
  export type AmazonOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderCountOutputType
     */
    select?: AmazonOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmazonOrderCountOutputType without action
   */
  export type AmazonOrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmazonOrderItemWhereInput
  }


  /**
   * Count Type ShopifyOrderCountOutputType
   */

  export type ShopifyOrderCountOutputType = {
    lineItems: number
  }

  export type ShopifyOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | ShopifyOrderCountOutputTypeCountLineItemsArgs
  }

  // Custom InputTypes
  /**
   * ShopifyOrderCountOutputType without action
   */
  export type ShopifyOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrderCountOutputType
     */
    select?: ShopifyOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopifyOrderCountOutputType without action
   */
  export type ShopifyOrderCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopifyLineItemWhereInput
  }


  /**
   * Count Type ShopifyProductCountOutputType
   */

  export type ShopifyProductCountOutputType = {
    variants: number
  }

  export type ShopifyProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ShopifyProductCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ShopifyProductCountOutputType without action
   */
  export type ShopifyProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProductCountOutputType
     */
    select?: ShopifyProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopifyProductCountOutputType without action
   */
  export type ShopifyProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopifyVariantWhereInput
  }


  /**
   * Count Type MachineCountOutputType
   */

  export type MachineCountOutputType = {
    sensors: number
    alerts: number
    maintenanceRecords: number
  }

  export type MachineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensors?: boolean | MachineCountOutputTypeCountSensorsArgs
    alerts?: boolean | MachineCountOutputTypeCountAlertsArgs
    maintenanceRecords?: boolean | MachineCountOutputTypeCountMaintenanceRecordsArgs
  }

  // Custom InputTypes
  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineCountOutputType
     */
    select?: MachineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountSensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineSensorWhereInput
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineAlertWhereInput
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountMaintenanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineMaintenanceRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    role: $Enums.Role
    preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dashboards?: boolean | User$dashboardsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "role" | "preferences" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboards?: boolean | User$dashboardsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      dashboards: Prisma.$DashboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      role: $Enums.Role
      preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboards<T extends User$dashboardsArgs<ExtArgs> = {}>(args?: Subset<T, User$dashboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.dashboards
   */
  export type User$dashboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    where?: DashboardWhereInput
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    cursor?: DashboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model WorkingCapital
   */

  export type AggregateWorkingCapital = {
    _count: WorkingCapitalCountAggregateOutputType | null
    _avg: WorkingCapitalAvgAggregateOutputType | null
    _sum: WorkingCapitalSumAggregateOutputType | null
    _min: WorkingCapitalMinAggregateOutputType | null
    _max: WorkingCapitalMaxAggregateOutputType | null
  }

  export type WorkingCapitalAvgAggregateOutputType = {
    currentAssets: number | null
    currentLiabilities: number | null
    inventory: number | null
    accountsReceivable: number | null
    accountsPayable: number | null
    cash: number | null
    dso: number | null
    dpo: number | null
    dio: number | null
    cashConversionCycle: number | null
    workingCapitalRatio: number | null
    quickRatio: number | null
  }

  export type WorkingCapitalSumAggregateOutputType = {
    currentAssets: number | null
    currentLiabilities: number | null
    inventory: number | null
    accountsReceivable: number | null
    accountsPayable: number | null
    cash: number | null
    dso: number | null
    dpo: number | null
    dio: number | null
    cashConversionCycle: number | null
    workingCapitalRatio: number | null
    quickRatio: number | null
  }

  export type WorkingCapitalMinAggregateOutputType = {
    id: string | null
    date: Date | null
    currentAssets: number | null
    currentLiabilities: number | null
    inventory: number | null
    accountsReceivable: number | null
    accountsPayable: number | null
    cash: number | null
    dso: number | null
    dpo: number | null
    dio: number | null
    cashConversionCycle: number | null
    workingCapitalRatio: number | null
    quickRatio: number | null
    createdAt: Date | null
  }

  export type WorkingCapitalMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    currentAssets: number | null
    currentLiabilities: number | null
    inventory: number | null
    accountsReceivable: number | null
    accountsPayable: number | null
    cash: number | null
    dso: number | null
    dpo: number | null
    dio: number | null
    cashConversionCycle: number | null
    workingCapitalRatio: number | null
    quickRatio: number | null
    createdAt: Date | null
  }

  export type WorkingCapitalCountAggregateOutputType = {
    id: number
    date: number
    currentAssets: number
    currentLiabilities: number
    inventory: number
    accountsReceivable: number
    accountsPayable: number
    cash: number
    dso: number
    dpo: number
    dio: number
    cashConversionCycle: number
    workingCapitalRatio: number
    quickRatio: number
    createdAt: number
    _all: number
  }


  export type WorkingCapitalAvgAggregateInputType = {
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    accountsReceivable?: true
    accountsPayable?: true
    cash?: true
    dso?: true
    dpo?: true
    dio?: true
    cashConversionCycle?: true
    workingCapitalRatio?: true
    quickRatio?: true
  }

  export type WorkingCapitalSumAggregateInputType = {
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    accountsReceivable?: true
    accountsPayable?: true
    cash?: true
    dso?: true
    dpo?: true
    dio?: true
    cashConversionCycle?: true
    workingCapitalRatio?: true
    quickRatio?: true
  }

  export type WorkingCapitalMinAggregateInputType = {
    id?: true
    date?: true
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    accountsReceivable?: true
    accountsPayable?: true
    cash?: true
    dso?: true
    dpo?: true
    dio?: true
    cashConversionCycle?: true
    workingCapitalRatio?: true
    quickRatio?: true
    createdAt?: true
  }

  export type WorkingCapitalMaxAggregateInputType = {
    id?: true
    date?: true
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    accountsReceivable?: true
    accountsPayable?: true
    cash?: true
    dso?: true
    dpo?: true
    dio?: true
    cashConversionCycle?: true
    workingCapitalRatio?: true
    quickRatio?: true
    createdAt?: true
  }

  export type WorkingCapitalCountAggregateInputType = {
    id?: true
    date?: true
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    accountsReceivable?: true
    accountsPayable?: true
    cash?: true
    dso?: true
    dpo?: true
    dio?: true
    cashConversionCycle?: true
    workingCapitalRatio?: true
    quickRatio?: true
    createdAt?: true
    _all?: true
  }

  export type WorkingCapitalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingCapital to aggregate.
     */
    where?: WorkingCapitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingCapitals to fetch.
     */
    orderBy?: WorkingCapitalOrderByWithRelationInput | WorkingCapitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkingCapitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingCapitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingCapitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkingCapitals
    **/
    _count?: true | WorkingCapitalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkingCapitalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkingCapitalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkingCapitalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkingCapitalMaxAggregateInputType
  }

  export type GetWorkingCapitalAggregateType<T extends WorkingCapitalAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkingCapital]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkingCapital[P]>
      : GetScalarType<T[P], AggregateWorkingCapital[P]>
  }




  export type WorkingCapitalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkingCapitalWhereInput
    orderBy?: WorkingCapitalOrderByWithAggregationInput | WorkingCapitalOrderByWithAggregationInput[]
    by: WorkingCapitalScalarFieldEnum[] | WorkingCapitalScalarFieldEnum
    having?: WorkingCapitalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkingCapitalCountAggregateInputType | true
    _avg?: WorkingCapitalAvgAggregateInputType
    _sum?: WorkingCapitalSumAggregateInputType
    _min?: WorkingCapitalMinAggregateInputType
    _max?: WorkingCapitalMaxAggregateInputType
  }

  export type WorkingCapitalGroupByOutputType = {
    id: string
    date: Date
    currentAssets: number
    currentLiabilities: number
    inventory: number
    accountsReceivable: number
    accountsPayable: number
    cash: number
    dso: number
    dpo: number
    dio: number
    cashConversionCycle: number
    workingCapitalRatio: number
    quickRatio: number
    createdAt: Date
    _count: WorkingCapitalCountAggregateOutputType | null
    _avg: WorkingCapitalAvgAggregateOutputType | null
    _sum: WorkingCapitalSumAggregateOutputType | null
    _min: WorkingCapitalMinAggregateOutputType | null
    _max: WorkingCapitalMaxAggregateOutputType | null
  }

  type GetWorkingCapitalGroupByPayload<T extends WorkingCapitalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkingCapitalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkingCapitalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkingCapitalGroupByOutputType[P]>
            : GetScalarType<T[P], WorkingCapitalGroupByOutputType[P]>
        }
      >
    >


  export type WorkingCapitalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    currentAssets?: boolean
    currentLiabilities?: boolean
    inventory?: boolean
    accountsReceivable?: boolean
    accountsPayable?: boolean
    cash?: boolean
    dso?: boolean
    dpo?: boolean
    dio?: boolean
    cashConversionCycle?: boolean
    workingCapitalRatio?: boolean
    quickRatio?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["workingCapital"]>

  export type WorkingCapitalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    currentAssets?: boolean
    currentLiabilities?: boolean
    inventory?: boolean
    accountsReceivable?: boolean
    accountsPayable?: boolean
    cash?: boolean
    dso?: boolean
    dpo?: boolean
    dio?: boolean
    cashConversionCycle?: boolean
    workingCapitalRatio?: boolean
    quickRatio?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["workingCapital"]>

  export type WorkingCapitalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    currentAssets?: boolean
    currentLiabilities?: boolean
    inventory?: boolean
    accountsReceivable?: boolean
    accountsPayable?: boolean
    cash?: boolean
    dso?: boolean
    dpo?: boolean
    dio?: boolean
    cashConversionCycle?: boolean
    workingCapitalRatio?: boolean
    quickRatio?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["workingCapital"]>

  export type WorkingCapitalSelectScalar = {
    id?: boolean
    date?: boolean
    currentAssets?: boolean
    currentLiabilities?: boolean
    inventory?: boolean
    accountsReceivable?: boolean
    accountsPayable?: boolean
    cash?: boolean
    dso?: boolean
    dpo?: boolean
    dio?: boolean
    cashConversionCycle?: boolean
    workingCapitalRatio?: boolean
    quickRatio?: boolean
    createdAt?: boolean
  }

  export type WorkingCapitalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "currentAssets" | "currentLiabilities" | "inventory" | "accountsReceivable" | "accountsPayable" | "cash" | "dso" | "dpo" | "dio" | "cashConversionCycle" | "workingCapitalRatio" | "quickRatio" | "createdAt", ExtArgs["result"]["workingCapital"]>

  export type $WorkingCapitalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkingCapital"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      currentAssets: number
      currentLiabilities: number
      inventory: number
      accountsReceivable: number
      accountsPayable: number
      cash: number
      dso: number
      dpo: number
      dio: number
      cashConversionCycle: number
      workingCapitalRatio: number
      quickRatio: number
      createdAt: Date
    }, ExtArgs["result"]["workingCapital"]>
    composites: {}
  }

  type WorkingCapitalGetPayload<S extends boolean | null | undefined | WorkingCapitalDefaultArgs> = $Result.GetResult<Prisma.$WorkingCapitalPayload, S>

  type WorkingCapitalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkingCapitalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkingCapitalCountAggregateInputType | true
    }

  export interface WorkingCapitalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkingCapital'], meta: { name: 'WorkingCapital' } }
    /**
     * Find zero or one WorkingCapital that matches the filter.
     * @param {WorkingCapitalFindUniqueArgs} args - Arguments to find a WorkingCapital
     * @example
     * // Get one WorkingCapital
     * const workingCapital = await prisma.workingCapital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkingCapitalFindUniqueArgs>(args: SelectSubset<T, WorkingCapitalFindUniqueArgs<ExtArgs>>): Prisma__WorkingCapitalClient<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkingCapital that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkingCapitalFindUniqueOrThrowArgs} args - Arguments to find a WorkingCapital
     * @example
     * // Get one WorkingCapital
     * const workingCapital = await prisma.workingCapital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkingCapitalFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkingCapitalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkingCapitalClient<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingCapital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingCapitalFindFirstArgs} args - Arguments to find a WorkingCapital
     * @example
     * // Get one WorkingCapital
     * const workingCapital = await prisma.workingCapital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkingCapitalFindFirstArgs>(args?: SelectSubset<T, WorkingCapitalFindFirstArgs<ExtArgs>>): Prisma__WorkingCapitalClient<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkingCapital that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingCapitalFindFirstOrThrowArgs} args - Arguments to find a WorkingCapital
     * @example
     * // Get one WorkingCapital
     * const workingCapital = await prisma.workingCapital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkingCapitalFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkingCapitalFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkingCapitalClient<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkingCapitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingCapitalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkingCapitals
     * const workingCapitals = await prisma.workingCapital.findMany()
     * 
     * // Get first 10 WorkingCapitals
     * const workingCapitals = await prisma.workingCapital.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workingCapitalWithIdOnly = await prisma.workingCapital.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkingCapitalFindManyArgs>(args?: SelectSubset<T, WorkingCapitalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkingCapital.
     * @param {WorkingCapitalCreateArgs} args - Arguments to create a WorkingCapital.
     * @example
     * // Create one WorkingCapital
     * const WorkingCapital = await prisma.workingCapital.create({
     *   data: {
     *     // ... data to create a WorkingCapital
     *   }
     * })
     * 
     */
    create<T extends WorkingCapitalCreateArgs>(args: SelectSubset<T, WorkingCapitalCreateArgs<ExtArgs>>): Prisma__WorkingCapitalClient<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkingCapitals.
     * @param {WorkingCapitalCreateManyArgs} args - Arguments to create many WorkingCapitals.
     * @example
     * // Create many WorkingCapitals
     * const workingCapital = await prisma.workingCapital.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkingCapitalCreateManyArgs>(args?: SelectSubset<T, WorkingCapitalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkingCapitals and returns the data saved in the database.
     * @param {WorkingCapitalCreateManyAndReturnArgs} args - Arguments to create many WorkingCapitals.
     * @example
     * // Create many WorkingCapitals
     * const workingCapital = await prisma.workingCapital.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkingCapitals and only return the `id`
     * const workingCapitalWithIdOnly = await prisma.workingCapital.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkingCapitalCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkingCapitalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkingCapital.
     * @param {WorkingCapitalDeleteArgs} args - Arguments to delete one WorkingCapital.
     * @example
     * // Delete one WorkingCapital
     * const WorkingCapital = await prisma.workingCapital.delete({
     *   where: {
     *     // ... filter to delete one WorkingCapital
     *   }
     * })
     * 
     */
    delete<T extends WorkingCapitalDeleteArgs>(args: SelectSubset<T, WorkingCapitalDeleteArgs<ExtArgs>>): Prisma__WorkingCapitalClient<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkingCapital.
     * @param {WorkingCapitalUpdateArgs} args - Arguments to update one WorkingCapital.
     * @example
     * // Update one WorkingCapital
     * const workingCapital = await prisma.workingCapital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkingCapitalUpdateArgs>(args: SelectSubset<T, WorkingCapitalUpdateArgs<ExtArgs>>): Prisma__WorkingCapitalClient<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkingCapitals.
     * @param {WorkingCapitalDeleteManyArgs} args - Arguments to filter WorkingCapitals to delete.
     * @example
     * // Delete a few WorkingCapitals
     * const { count } = await prisma.workingCapital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkingCapitalDeleteManyArgs>(args?: SelectSubset<T, WorkingCapitalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingCapitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingCapitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkingCapitals
     * const workingCapital = await prisma.workingCapital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkingCapitalUpdateManyArgs>(args: SelectSubset<T, WorkingCapitalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkingCapitals and returns the data updated in the database.
     * @param {WorkingCapitalUpdateManyAndReturnArgs} args - Arguments to update many WorkingCapitals.
     * @example
     * // Update many WorkingCapitals
     * const workingCapital = await prisma.workingCapital.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkingCapitals and only return the `id`
     * const workingCapitalWithIdOnly = await prisma.workingCapital.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkingCapitalUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkingCapitalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkingCapital.
     * @param {WorkingCapitalUpsertArgs} args - Arguments to update or create a WorkingCapital.
     * @example
     * // Update or create a WorkingCapital
     * const workingCapital = await prisma.workingCapital.upsert({
     *   create: {
     *     // ... data to create a WorkingCapital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkingCapital we want to update
     *   }
     * })
     */
    upsert<T extends WorkingCapitalUpsertArgs>(args: SelectSubset<T, WorkingCapitalUpsertArgs<ExtArgs>>): Prisma__WorkingCapitalClient<$Result.GetResult<Prisma.$WorkingCapitalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkingCapitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingCapitalCountArgs} args - Arguments to filter WorkingCapitals to count.
     * @example
     * // Count the number of WorkingCapitals
     * const count = await prisma.workingCapital.count({
     *   where: {
     *     // ... the filter for the WorkingCapitals we want to count
     *   }
     * })
    **/
    count<T extends WorkingCapitalCountArgs>(
      args?: Subset<T, WorkingCapitalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkingCapitalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkingCapital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingCapitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkingCapitalAggregateArgs>(args: Subset<T, WorkingCapitalAggregateArgs>): Prisma.PrismaPromise<GetWorkingCapitalAggregateType<T>>

    /**
     * Group by WorkingCapital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkingCapitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkingCapitalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkingCapitalGroupByArgs['orderBy'] }
        : { orderBy?: WorkingCapitalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkingCapitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkingCapitalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkingCapital model
   */
  readonly fields: WorkingCapitalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkingCapital.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkingCapitalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkingCapital model
   */
  interface WorkingCapitalFieldRefs {
    readonly id: FieldRef<"WorkingCapital", 'String'>
    readonly date: FieldRef<"WorkingCapital", 'DateTime'>
    readonly currentAssets: FieldRef<"WorkingCapital", 'Float'>
    readonly currentLiabilities: FieldRef<"WorkingCapital", 'Float'>
    readonly inventory: FieldRef<"WorkingCapital", 'Float'>
    readonly accountsReceivable: FieldRef<"WorkingCapital", 'Float'>
    readonly accountsPayable: FieldRef<"WorkingCapital", 'Float'>
    readonly cash: FieldRef<"WorkingCapital", 'Float'>
    readonly dso: FieldRef<"WorkingCapital", 'Int'>
    readonly dpo: FieldRef<"WorkingCapital", 'Int'>
    readonly dio: FieldRef<"WorkingCapital", 'Int'>
    readonly cashConversionCycle: FieldRef<"WorkingCapital", 'Int'>
    readonly workingCapitalRatio: FieldRef<"WorkingCapital", 'Float'>
    readonly quickRatio: FieldRef<"WorkingCapital", 'Float'>
    readonly createdAt: FieldRef<"WorkingCapital", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkingCapital findUnique
   */
  export type WorkingCapitalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * Filter, which WorkingCapital to fetch.
     */
    where: WorkingCapitalWhereUniqueInput
  }

  /**
   * WorkingCapital findUniqueOrThrow
   */
  export type WorkingCapitalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * Filter, which WorkingCapital to fetch.
     */
    where: WorkingCapitalWhereUniqueInput
  }

  /**
   * WorkingCapital findFirst
   */
  export type WorkingCapitalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * Filter, which WorkingCapital to fetch.
     */
    where?: WorkingCapitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingCapitals to fetch.
     */
    orderBy?: WorkingCapitalOrderByWithRelationInput | WorkingCapitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingCapitals.
     */
    cursor?: WorkingCapitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingCapitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingCapitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingCapitals.
     */
    distinct?: WorkingCapitalScalarFieldEnum | WorkingCapitalScalarFieldEnum[]
  }

  /**
   * WorkingCapital findFirstOrThrow
   */
  export type WorkingCapitalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * Filter, which WorkingCapital to fetch.
     */
    where?: WorkingCapitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingCapitals to fetch.
     */
    orderBy?: WorkingCapitalOrderByWithRelationInput | WorkingCapitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkingCapitals.
     */
    cursor?: WorkingCapitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingCapitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingCapitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkingCapitals.
     */
    distinct?: WorkingCapitalScalarFieldEnum | WorkingCapitalScalarFieldEnum[]
  }

  /**
   * WorkingCapital findMany
   */
  export type WorkingCapitalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * Filter, which WorkingCapitals to fetch.
     */
    where?: WorkingCapitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkingCapitals to fetch.
     */
    orderBy?: WorkingCapitalOrderByWithRelationInput | WorkingCapitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkingCapitals.
     */
    cursor?: WorkingCapitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkingCapitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkingCapitals.
     */
    skip?: number
    distinct?: WorkingCapitalScalarFieldEnum | WorkingCapitalScalarFieldEnum[]
  }

  /**
   * WorkingCapital create
   */
  export type WorkingCapitalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * The data needed to create a WorkingCapital.
     */
    data: XOR<WorkingCapitalCreateInput, WorkingCapitalUncheckedCreateInput>
  }

  /**
   * WorkingCapital createMany
   */
  export type WorkingCapitalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkingCapitals.
     */
    data: WorkingCapitalCreateManyInput | WorkingCapitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkingCapital createManyAndReturn
   */
  export type WorkingCapitalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * The data used to create many WorkingCapitals.
     */
    data: WorkingCapitalCreateManyInput | WorkingCapitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkingCapital update
   */
  export type WorkingCapitalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * The data needed to update a WorkingCapital.
     */
    data: XOR<WorkingCapitalUpdateInput, WorkingCapitalUncheckedUpdateInput>
    /**
     * Choose, which WorkingCapital to update.
     */
    where: WorkingCapitalWhereUniqueInput
  }

  /**
   * WorkingCapital updateMany
   */
  export type WorkingCapitalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkingCapitals.
     */
    data: XOR<WorkingCapitalUpdateManyMutationInput, WorkingCapitalUncheckedUpdateManyInput>
    /**
     * Filter which WorkingCapitals to update
     */
    where?: WorkingCapitalWhereInput
    /**
     * Limit how many WorkingCapitals to update.
     */
    limit?: number
  }

  /**
   * WorkingCapital updateManyAndReturn
   */
  export type WorkingCapitalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * The data used to update WorkingCapitals.
     */
    data: XOR<WorkingCapitalUpdateManyMutationInput, WorkingCapitalUncheckedUpdateManyInput>
    /**
     * Filter which WorkingCapitals to update
     */
    where?: WorkingCapitalWhereInput
    /**
     * Limit how many WorkingCapitals to update.
     */
    limit?: number
  }

  /**
   * WorkingCapital upsert
   */
  export type WorkingCapitalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * The filter to search for the WorkingCapital to update in case it exists.
     */
    where: WorkingCapitalWhereUniqueInput
    /**
     * In case the WorkingCapital found by the `where` argument doesn't exist, create a new WorkingCapital with this data.
     */
    create: XOR<WorkingCapitalCreateInput, WorkingCapitalUncheckedCreateInput>
    /**
     * In case the WorkingCapital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkingCapitalUpdateInput, WorkingCapitalUncheckedUpdateInput>
  }

  /**
   * WorkingCapital delete
   */
  export type WorkingCapitalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
    /**
     * Filter which WorkingCapital to delete.
     */
    where: WorkingCapitalWhereUniqueInput
  }

  /**
   * WorkingCapital deleteMany
   */
  export type WorkingCapitalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkingCapitals to delete
     */
    where?: WorkingCapitalWhereInput
    /**
     * Limit how many WorkingCapitals to delete.
     */
    limit?: number
  }

  /**
   * WorkingCapital without action
   */
  export type WorkingCapitalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkingCapital
     */
    select?: WorkingCapitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkingCapital
     */
    omit?: WorkingCapitalOmit<ExtArgs> | null
  }


  /**
   * Model CashRunway
   */

  export type AggregateCashRunway = {
    _count: CashRunwayCountAggregateOutputType | null
    _avg: CashRunwayAvgAggregateOutputType | null
    _sum: CashRunwaySumAggregateOutputType | null
    _min: CashRunwayMinAggregateOutputType | null
    _max: CashRunwayMaxAggregateOutputType | null
  }

  export type CashRunwayAvgAggregateOutputType = {
    cashBalance: number | null
    monthlyBurnRate: number | null
    monthlyRevenue: number | null
    netBurnRate: number | null
    runwayMonths: number | null
    coverageDay30: number | null
    coverageDay60: number | null
    coverageDay90: number | null
    coverageDay120: number | null
    coverageDay180: number | null
  }

  export type CashRunwaySumAggregateOutputType = {
    cashBalance: number | null
    monthlyBurnRate: number | null
    monthlyRevenue: number | null
    netBurnRate: number | null
    runwayMonths: number | null
    coverageDay30: number | null
    coverageDay60: number | null
    coverageDay90: number | null
    coverageDay120: number | null
    coverageDay180: number | null
  }

  export type CashRunwayMinAggregateOutputType = {
    id: string | null
    date: Date | null
    cashBalance: number | null
    monthlyBurnRate: number | null
    monthlyRevenue: number | null
    netBurnRate: number | null
    runwayMonths: number | null
    coverageDay30: number | null
    coverageDay60: number | null
    coverageDay90: number | null
    coverageDay120: number | null
    coverageDay180: number | null
    createdAt: Date | null
  }

  export type CashRunwayMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    cashBalance: number | null
    monthlyBurnRate: number | null
    monthlyRevenue: number | null
    netBurnRate: number | null
    runwayMonths: number | null
    coverageDay30: number | null
    coverageDay60: number | null
    coverageDay90: number | null
    coverageDay120: number | null
    coverageDay180: number | null
    createdAt: Date | null
  }

  export type CashRunwayCountAggregateOutputType = {
    id: number
    date: number
    cashBalance: number
    monthlyBurnRate: number
    monthlyRevenue: number
    netBurnRate: number
    runwayMonths: number
    coverageDay30: number
    coverageDay60: number
    coverageDay90: number
    coverageDay120: number
    coverageDay180: number
    createdAt: number
    _all: number
  }


  export type CashRunwayAvgAggregateInputType = {
    cashBalance?: true
    monthlyBurnRate?: true
    monthlyRevenue?: true
    netBurnRate?: true
    runwayMonths?: true
    coverageDay30?: true
    coverageDay60?: true
    coverageDay90?: true
    coverageDay120?: true
    coverageDay180?: true
  }

  export type CashRunwaySumAggregateInputType = {
    cashBalance?: true
    monthlyBurnRate?: true
    monthlyRevenue?: true
    netBurnRate?: true
    runwayMonths?: true
    coverageDay30?: true
    coverageDay60?: true
    coverageDay90?: true
    coverageDay120?: true
    coverageDay180?: true
  }

  export type CashRunwayMinAggregateInputType = {
    id?: true
    date?: true
    cashBalance?: true
    monthlyBurnRate?: true
    monthlyRevenue?: true
    netBurnRate?: true
    runwayMonths?: true
    coverageDay30?: true
    coverageDay60?: true
    coverageDay90?: true
    coverageDay120?: true
    coverageDay180?: true
    createdAt?: true
  }

  export type CashRunwayMaxAggregateInputType = {
    id?: true
    date?: true
    cashBalance?: true
    monthlyBurnRate?: true
    monthlyRevenue?: true
    netBurnRate?: true
    runwayMonths?: true
    coverageDay30?: true
    coverageDay60?: true
    coverageDay90?: true
    coverageDay120?: true
    coverageDay180?: true
    createdAt?: true
  }

  export type CashRunwayCountAggregateInputType = {
    id?: true
    date?: true
    cashBalance?: true
    monthlyBurnRate?: true
    monthlyRevenue?: true
    netBurnRate?: true
    runwayMonths?: true
    coverageDay30?: true
    coverageDay60?: true
    coverageDay90?: true
    coverageDay120?: true
    coverageDay180?: true
    createdAt?: true
    _all?: true
  }

  export type CashRunwayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashRunway to aggregate.
     */
    where?: CashRunwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRunways to fetch.
     */
    orderBy?: CashRunwayOrderByWithRelationInput | CashRunwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashRunwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRunways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRunways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashRunways
    **/
    _count?: true | CashRunwayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashRunwayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashRunwaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashRunwayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashRunwayMaxAggregateInputType
  }

  export type GetCashRunwayAggregateType<T extends CashRunwayAggregateArgs> = {
        [P in keyof T & keyof AggregateCashRunway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashRunway[P]>
      : GetScalarType<T[P], AggregateCashRunway[P]>
  }




  export type CashRunwayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRunwayWhereInput
    orderBy?: CashRunwayOrderByWithAggregationInput | CashRunwayOrderByWithAggregationInput[]
    by: CashRunwayScalarFieldEnum[] | CashRunwayScalarFieldEnum
    having?: CashRunwayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashRunwayCountAggregateInputType | true
    _avg?: CashRunwayAvgAggregateInputType
    _sum?: CashRunwaySumAggregateInputType
    _min?: CashRunwayMinAggregateInputType
    _max?: CashRunwayMaxAggregateInputType
  }

  export type CashRunwayGroupByOutputType = {
    id: string
    date: Date
    cashBalance: number
    monthlyBurnRate: number
    monthlyRevenue: number
    netBurnRate: number
    runwayMonths: number
    coverageDay30: number
    coverageDay60: number
    coverageDay90: number
    coverageDay120: number
    coverageDay180: number
    createdAt: Date
    _count: CashRunwayCountAggregateOutputType | null
    _avg: CashRunwayAvgAggregateOutputType | null
    _sum: CashRunwaySumAggregateOutputType | null
    _min: CashRunwayMinAggregateOutputType | null
    _max: CashRunwayMaxAggregateOutputType | null
  }

  type GetCashRunwayGroupByPayload<T extends CashRunwayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashRunwayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashRunwayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashRunwayGroupByOutputType[P]>
            : GetScalarType<T[P], CashRunwayGroupByOutputType[P]>
        }
      >
    >


  export type CashRunwaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    cashBalance?: boolean
    monthlyBurnRate?: boolean
    monthlyRevenue?: boolean
    netBurnRate?: boolean
    runwayMonths?: boolean
    coverageDay30?: boolean
    coverageDay60?: boolean
    coverageDay90?: boolean
    coverageDay120?: boolean
    coverageDay180?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cashRunway"]>

  export type CashRunwaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    cashBalance?: boolean
    monthlyBurnRate?: boolean
    monthlyRevenue?: boolean
    netBurnRate?: boolean
    runwayMonths?: boolean
    coverageDay30?: boolean
    coverageDay60?: boolean
    coverageDay90?: boolean
    coverageDay120?: boolean
    coverageDay180?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cashRunway"]>

  export type CashRunwaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    cashBalance?: boolean
    monthlyBurnRate?: boolean
    monthlyRevenue?: boolean
    netBurnRate?: boolean
    runwayMonths?: boolean
    coverageDay30?: boolean
    coverageDay60?: boolean
    coverageDay90?: boolean
    coverageDay120?: boolean
    coverageDay180?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cashRunway"]>

  export type CashRunwaySelectScalar = {
    id?: boolean
    date?: boolean
    cashBalance?: boolean
    monthlyBurnRate?: boolean
    monthlyRevenue?: boolean
    netBurnRate?: boolean
    runwayMonths?: boolean
    coverageDay30?: boolean
    coverageDay60?: boolean
    coverageDay90?: boolean
    coverageDay120?: boolean
    coverageDay180?: boolean
    createdAt?: boolean
  }

  export type CashRunwayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "cashBalance" | "monthlyBurnRate" | "monthlyRevenue" | "netBurnRate" | "runwayMonths" | "coverageDay30" | "coverageDay60" | "coverageDay90" | "coverageDay120" | "coverageDay180" | "createdAt", ExtArgs["result"]["cashRunway"]>

  export type $CashRunwayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashRunway"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      cashBalance: number
      monthlyBurnRate: number
      monthlyRevenue: number
      netBurnRate: number
      runwayMonths: number
      coverageDay30: number
      coverageDay60: number
      coverageDay90: number
      coverageDay120: number
      coverageDay180: number
      createdAt: Date
    }, ExtArgs["result"]["cashRunway"]>
    composites: {}
  }

  type CashRunwayGetPayload<S extends boolean | null | undefined | CashRunwayDefaultArgs> = $Result.GetResult<Prisma.$CashRunwayPayload, S>

  type CashRunwayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashRunwayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashRunwayCountAggregateInputType | true
    }

  export interface CashRunwayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashRunway'], meta: { name: 'CashRunway' } }
    /**
     * Find zero or one CashRunway that matches the filter.
     * @param {CashRunwayFindUniqueArgs} args - Arguments to find a CashRunway
     * @example
     * // Get one CashRunway
     * const cashRunway = await prisma.cashRunway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashRunwayFindUniqueArgs>(args: SelectSubset<T, CashRunwayFindUniqueArgs<ExtArgs>>): Prisma__CashRunwayClient<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashRunway that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashRunwayFindUniqueOrThrowArgs} args - Arguments to find a CashRunway
     * @example
     * // Get one CashRunway
     * const cashRunway = await prisma.cashRunway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashRunwayFindUniqueOrThrowArgs>(args: SelectSubset<T, CashRunwayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashRunwayClient<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashRunway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRunwayFindFirstArgs} args - Arguments to find a CashRunway
     * @example
     * // Get one CashRunway
     * const cashRunway = await prisma.cashRunway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashRunwayFindFirstArgs>(args?: SelectSubset<T, CashRunwayFindFirstArgs<ExtArgs>>): Prisma__CashRunwayClient<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashRunway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRunwayFindFirstOrThrowArgs} args - Arguments to find a CashRunway
     * @example
     * // Get one CashRunway
     * const cashRunway = await prisma.cashRunway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashRunwayFindFirstOrThrowArgs>(args?: SelectSubset<T, CashRunwayFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashRunwayClient<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashRunways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRunwayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashRunways
     * const cashRunways = await prisma.cashRunway.findMany()
     * 
     * // Get first 10 CashRunways
     * const cashRunways = await prisma.cashRunway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashRunwayWithIdOnly = await prisma.cashRunway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashRunwayFindManyArgs>(args?: SelectSubset<T, CashRunwayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashRunway.
     * @param {CashRunwayCreateArgs} args - Arguments to create a CashRunway.
     * @example
     * // Create one CashRunway
     * const CashRunway = await prisma.cashRunway.create({
     *   data: {
     *     // ... data to create a CashRunway
     *   }
     * })
     * 
     */
    create<T extends CashRunwayCreateArgs>(args: SelectSubset<T, CashRunwayCreateArgs<ExtArgs>>): Prisma__CashRunwayClient<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashRunways.
     * @param {CashRunwayCreateManyArgs} args - Arguments to create many CashRunways.
     * @example
     * // Create many CashRunways
     * const cashRunway = await prisma.cashRunway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashRunwayCreateManyArgs>(args?: SelectSubset<T, CashRunwayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashRunways and returns the data saved in the database.
     * @param {CashRunwayCreateManyAndReturnArgs} args - Arguments to create many CashRunways.
     * @example
     * // Create many CashRunways
     * const cashRunway = await prisma.cashRunway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashRunways and only return the `id`
     * const cashRunwayWithIdOnly = await prisma.cashRunway.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashRunwayCreateManyAndReturnArgs>(args?: SelectSubset<T, CashRunwayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashRunway.
     * @param {CashRunwayDeleteArgs} args - Arguments to delete one CashRunway.
     * @example
     * // Delete one CashRunway
     * const CashRunway = await prisma.cashRunway.delete({
     *   where: {
     *     // ... filter to delete one CashRunway
     *   }
     * })
     * 
     */
    delete<T extends CashRunwayDeleteArgs>(args: SelectSubset<T, CashRunwayDeleteArgs<ExtArgs>>): Prisma__CashRunwayClient<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashRunway.
     * @param {CashRunwayUpdateArgs} args - Arguments to update one CashRunway.
     * @example
     * // Update one CashRunway
     * const cashRunway = await prisma.cashRunway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashRunwayUpdateArgs>(args: SelectSubset<T, CashRunwayUpdateArgs<ExtArgs>>): Prisma__CashRunwayClient<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashRunways.
     * @param {CashRunwayDeleteManyArgs} args - Arguments to filter CashRunways to delete.
     * @example
     * // Delete a few CashRunways
     * const { count } = await prisma.cashRunway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashRunwayDeleteManyArgs>(args?: SelectSubset<T, CashRunwayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashRunways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRunwayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashRunways
     * const cashRunway = await prisma.cashRunway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashRunwayUpdateManyArgs>(args: SelectSubset<T, CashRunwayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashRunways and returns the data updated in the database.
     * @param {CashRunwayUpdateManyAndReturnArgs} args - Arguments to update many CashRunways.
     * @example
     * // Update many CashRunways
     * const cashRunway = await prisma.cashRunway.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashRunways and only return the `id`
     * const cashRunwayWithIdOnly = await prisma.cashRunway.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashRunwayUpdateManyAndReturnArgs>(args: SelectSubset<T, CashRunwayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashRunway.
     * @param {CashRunwayUpsertArgs} args - Arguments to update or create a CashRunway.
     * @example
     * // Update or create a CashRunway
     * const cashRunway = await prisma.cashRunway.upsert({
     *   create: {
     *     // ... data to create a CashRunway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashRunway we want to update
     *   }
     * })
     */
    upsert<T extends CashRunwayUpsertArgs>(args: SelectSubset<T, CashRunwayUpsertArgs<ExtArgs>>): Prisma__CashRunwayClient<$Result.GetResult<Prisma.$CashRunwayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashRunways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRunwayCountArgs} args - Arguments to filter CashRunways to count.
     * @example
     * // Count the number of CashRunways
     * const count = await prisma.cashRunway.count({
     *   where: {
     *     // ... the filter for the CashRunways we want to count
     *   }
     * })
    **/
    count<T extends CashRunwayCountArgs>(
      args?: Subset<T, CashRunwayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashRunwayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashRunway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRunwayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashRunwayAggregateArgs>(args: Subset<T, CashRunwayAggregateArgs>): Prisma.PrismaPromise<GetCashRunwayAggregateType<T>>

    /**
     * Group by CashRunway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRunwayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashRunwayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashRunwayGroupByArgs['orderBy'] }
        : { orderBy?: CashRunwayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashRunwayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashRunwayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashRunway model
   */
  readonly fields: CashRunwayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashRunway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashRunwayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashRunway model
   */
  interface CashRunwayFieldRefs {
    readonly id: FieldRef<"CashRunway", 'String'>
    readonly date: FieldRef<"CashRunway", 'DateTime'>
    readonly cashBalance: FieldRef<"CashRunway", 'Float'>
    readonly monthlyBurnRate: FieldRef<"CashRunway", 'Float'>
    readonly monthlyRevenue: FieldRef<"CashRunway", 'Float'>
    readonly netBurnRate: FieldRef<"CashRunway", 'Float'>
    readonly runwayMonths: FieldRef<"CashRunway", 'Float'>
    readonly coverageDay30: FieldRef<"CashRunway", 'Float'>
    readonly coverageDay60: FieldRef<"CashRunway", 'Float'>
    readonly coverageDay90: FieldRef<"CashRunway", 'Float'>
    readonly coverageDay120: FieldRef<"CashRunway", 'Float'>
    readonly coverageDay180: FieldRef<"CashRunway", 'Float'>
    readonly createdAt: FieldRef<"CashRunway", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashRunway findUnique
   */
  export type CashRunwayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * Filter, which CashRunway to fetch.
     */
    where: CashRunwayWhereUniqueInput
  }

  /**
   * CashRunway findUniqueOrThrow
   */
  export type CashRunwayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * Filter, which CashRunway to fetch.
     */
    where: CashRunwayWhereUniqueInput
  }

  /**
   * CashRunway findFirst
   */
  export type CashRunwayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * Filter, which CashRunway to fetch.
     */
    where?: CashRunwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRunways to fetch.
     */
    orderBy?: CashRunwayOrderByWithRelationInput | CashRunwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashRunways.
     */
    cursor?: CashRunwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRunways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRunways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashRunways.
     */
    distinct?: CashRunwayScalarFieldEnum | CashRunwayScalarFieldEnum[]
  }

  /**
   * CashRunway findFirstOrThrow
   */
  export type CashRunwayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * Filter, which CashRunway to fetch.
     */
    where?: CashRunwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRunways to fetch.
     */
    orderBy?: CashRunwayOrderByWithRelationInput | CashRunwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashRunways.
     */
    cursor?: CashRunwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRunways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRunways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashRunways.
     */
    distinct?: CashRunwayScalarFieldEnum | CashRunwayScalarFieldEnum[]
  }

  /**
   * CashRunway findMany
   */
  export type CashRunwayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * Filter, which CashRunways to fetch.
     */
    where?: CashRunwayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRunways to fetch.
     */
    orderBy?: CashRunwayOrderByWithRelationInput | CashRunwayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashRunways.
     */
    cursor?: CashRunwayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRunways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRunways.
     */
    skip?: number
    distinct?: CashRunwayScalarFieldEnum | CashRunwayScalarFieldEnum[]
  }

  /**
   * CashRunway create
   */
  export type CashRunwayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * The data needed to create a CashRunway.
     */
    data: XOR<CashRunwayCreateInput, CashRunwayUncheckedCreateInput>
  }

  /**
   * CashRunway createMany
   */
  export type CashRunwayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashRunways.
     */
    data: CashRunwayCreateManyInput | CashRunwayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashRunway createManyAndReturn
   */
  export type CashRunwayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * The data used to create many CashRunways.
     */
    data: CashRunwayCreateManyInput | CashRunwayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashRunway update
   */
  export type CashRunwayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * The data needed to update a CashRunway.
     */
    data: XOR<CashRunwayUpdateInput, CashRunwayUncheckedUpdateInput>
    /**
     * Choose, which CashRunway to update.
     */
    where: CashRunwayWhereUniqueInput
  }

  /**
   * CashRunway updateMany
   */
  export type CashRunwayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashRunways.
     */
    data: XOR<CashRunwayUpdateManyMutationInput, CashRunwayUncheckedUpdateManyInput>
    /**
     * Filter which CashRunways to update
     */
    where?: CashRunwayWhereInput
    /**
     * Limit how many CashRunways to update.
     */
    limit?: number
  }

  /**
   * CashRunway updateManyAndReturn
   */
  export type CashRunwayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * The data used to update CashRunways.
     */
    data: XOR<CashRunwayUpdateManyMutationInput, CashRunwayUncheckedUpdateManyInput>
    /**
     * Filter which CashRunways to update
     */
    where?: CashRunwayWhereInput
    /**
     * Limit how many CashRunways to update.
     */
    limit?: number
  }

  /**
   * CashRunway upsert
   */
  export type CashRunwayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * The filter to search for the CashRunway to update in case it exists.
     */
    where: CashRunwayWhereUniqueInput
    /**
     * In case the CashRunway found by the `where` argument doesn't exist, create a new CashRunway with this data.
     */
    create: XOR<CashRunwayCreateInput, CashRunwayUncheckedCreateInput>
    /**
     * In case the CashRunway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashRunwayUpdateInput, CashRunwayUncheckedUpdateInput>
  }

  /**
   * CashRunway delete
   */
  export type CashRunwayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
    /**
     * Filter which CashRunway to delete.
     */
    where: CashRunwayWhereUniqueInput
  }

  /**
   * CashRunway deleteMany
   */
  export type CashRunwayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashRunways to delete
     */
    where?: CashRunwayWhereInput
    /**
     * Limit how many CashRunways to delete.
     */
    limit?: number
  }

  /**
   * CashRunway without action
   */
  export type CashRunwayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRunway
     */
    select?: CashRunwaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRunway
     */
    omit?: CashRunwayOmit<ExtArgs> | null
  }


  /**
   * Model Production
   */

  export type AggregateProduction = {
    _count: ProductionCountAggregateOutputType | null
    _avg: ProductionAvgAggregateOutputType | null
    _sum: ProductionSumAggregateOutputType | null
    _min: ProductionMinAggregateOutputType | null
    _max: ProductionMaxAggregateOutputType | null
  }

  export type ProductionAvgAggregateOutputType = {
    quantity: number | null
    targetQuantity: number | null
    completedQuantity: number | null
    qualityScore: number | null
    defectRate: number | null
    efficiency: number | null
  }

  export type ProductionSumAggregateOutputType = {
    quantity: number | null
    targetQuantity: number | null
    completedQuantity: number | null
    qualityScore: number | null
    defectRate: number | null
    efficiency: number | null
  }

  export type ProductionMinAggregateOutputType = {
    id: string | null
    jobNumber: string | null
    productName: string | null
    productSKU: string | null
    quantity: number | null
    targetQuantity: number | null
    completedQuantity: number | null
    status: $Enums.ProductionStatus | null
    priority: $Enums.Priority | null
    startDate: Date | null
    targetDate: Date | null
    completionDate: Date | null
    qualityScore: number | null
    defectRate: number | null
    efficiency: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionMaxAggregateOutputType = {
    id: string | null
    jobNumber: string | null
    productName: string | null
    productSKU: string | null
    quantity: number | null
    targetQuantity: number | null
    completedQuantity: number | null
    status: $Enums.ProductionStatus | null
    priority: $Enums.Priority | null
    startDate: Date | null
    targetDate: Date | null
    completionDate: Date | null
    qualityScore: number | null
    defectRate: number | null
    efficiency: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionCountAggregateOutputType = {
    id: number
    jobNumber: number
    productName: number
    productSKU: number
    quantity: number
    targetQuantity: number
    completedQuantity: number
    status: number
    priority: number
    startDate: number
    targetDate: number
    completionDate: number
    qualityScore: number
    defectRate: number
    efficiency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionAvgAggregateInputType = {
    quantity?: true
    targetQuantity?: true
    completedQuantity?: true
    qualityScore?: true
    defectRate?: true
    efficiency?: true
  }

  export type ProductionSumAggregateInputType = {
    quantity?: true
    targetQuantity?: true
    completedQuantity?: true
    qualityScore?: true
    defectRate?: true
    efficiency?: true
  }

  export type ProductionMinAggregateInputType = {
    id?: true
    jobNumber?: true
    productName?: true
    productSKU?: true
    quantity?: true
    targetQuantity?: true
    completedQuantity?: true
    status?: true
    priority?: true
    startDate?: true
    targetDate?: true
    completionDate?: true
    qualityScore?: true
    defectRate?: true
    efficiency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionMaxAggregateInputType = {
    id?: true
    jobNumber?: true
    productName?: true
    productSKU?: true
    quantity?: true
    targetQuantity?: true
    completedQuantity?: true
    status?: true
    priority?: true
    startDate?: true
    targetDate?: true
    completionDate?: true
    qualityScore?: true
    defectRate?: true
    efficiency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionCountAggregateInputType = {
    id?: true
    jobNumber?: true
    productName?: true
    productSKU?: true
    quantity?: true
    targetQuantity?: true
    completedQuantity?: true
    status?: true
    priority?: true
    startDate?: true
    targetDate?: true
    completionDate?: true
    qualityScore?: true
    defectRate?: true
    efficiency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Production to aggregate.
     */
    where?: ProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productions to fetch.
     */
    orderBy?: ProductionOrderByWithRelationInput | ProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productions
    **/
    _count?: true | ProductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionMaxAggregateInputType
  }

  export type GetProductionAggregateType<T extends ProductionAggregateArgs> = {
        [P in keyof T & keyof AggregateProduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduction[P]>
      : GetScalarType<T[P], AggregateProduction[P]>
  }




  export type ProductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionWhereInput
    orderBy?: ProductionOrderByWithAggregationInput | ProductionOrderByWithAggregationInput[]
    by: ProductionScalarFieldEnum[] | ProductionScalarFieldEnum
    having?: ProductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionCountAggregateInputType | true
    _avg?: ProductionAvgAggregateInputType
    _sum?: ProductionSumAggregateInputType
    _min?: ProductionMinAggregateInputType
    _max?: ProductionMaxAggregateInputType
  }

  export type ProductionGroupByOutputType = {
    id: string
    jobNumber: string
    productName: string
    productSKU: string | null
    quantity: number
    targetQuantity: number
    completedQuantity: number
    status: $Enums.ProductionStatus
    priority: $Enums.Priority
    startDate: Date
    targetDate: Date
    completionDate: Date | null
    qualityScore: number | null
    defectRate: number | null
    efficiency: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProductionCountAggregateOutputType | null
    _avg: ProductionAvgAggregateOutputType | null
    _sum: ProductionSumAggregateOutputType | null
    _min: ProductionMinAggregateOutputType | null
    _max: ProductionMaxAggregateOutputType | null
  }

  type GetProductionGroupByPayload<T extends ProductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionGroupByOutputType[P]>
        }
      >
    >


  export type ProductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    productName?: boolean
    productSKU?: boolean
    quantity?: boolean
    targetQuantity?: boolean
    completedQuantity?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    targetDate?: boolean
    completionDate?: boolean
    qualityScore?: boolean
    defectRate?: boolean
    efficiency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    qualityChecks?: boolean | Production$qualityChecksArgs<ExtArgs>
    _count?: boolean | ProductionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["production"]>

  export type ProductionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    productName?: boolean
    productSKU?: boolean
    quantity?: boolean
    targetQuantity?: boolean
    completedQuantity?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    targetDate?: boolean
    completionDate?: boolean
    qualityScore?: boolean
    defectRate?: boolean
    efficiency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["production"]>

  export type ProductionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobNumber?: boolean
    productName?: boolean
    productSKU?: boolean
    quantity?: boolean
    targetQuantity?: boolean
    completedQuantity?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    targetDate?: boolean
    completionDate?: boolean
    qualityScore?: boolean
    defectRate?: boolean
    efficiency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["production"]>

  export type ProductionSelectScalar = {
    id?: boolean
    jobNumber?: boolean
    productName?: boolean
    productSKU?: boolean
    quantity?: boolean
    targetQuantity?: boolean
    completedQuantity?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    targetDate?: boolean
    completionDate?: boolean
    qualityScore?: boolean
    defectRate?: boolean
    efficiency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobNumber" | "productName" | "productSKU" | "quantity" | "targetQuantity" | "completedQuantity" | "status" | "priority" | "startDate" | "targetDate" | "completionDate" | "qualityScore" | "defectRate" | "efficiency" | "createdAt" | "updatedAt", ExtArgs["result"]["production"]>
  export type ProductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qualityChecks?: boolean | Production$qualityChecksArgs<ExtArgs>
    _count?: boolean | ProductionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Production"
    objects: {
      qualityChecks: Prisma.$QualityCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobNumber: string
      productName: string
      productSKU: string | null
      quantity: number
      targetQuantity: number
      completedQuantity: number
      status: $Enums.ProductionStatus
      priority: $Enums.Priority
      startDate: Date
      targetDate: Date
      completionDate: Date | null
      qualityScore: number | null
      defectRate: number | null
      efficiency: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["production"]>
    composites: {}
  }

  type ProductionGetPayload<S extends boolean | null | undefined | ProductionDefaultArgs> = $Result.GetResult<Prisma.$ProductionPayload, S>

  type ProductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionCountAggregateInputType | true
    }

  export interface ProductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Production'], meta: { name: 'Production' } }
    /**
     * Find zero or one Production that matches the filter.
     * @param {ProductionFindUniqueArgs} args - Arguments to find a Production
     * @example
     * // Get one Production
     * const production = await prisma.production.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionFindUniqueArgs>(args: SelectSubset<T, ProductionFindUniqueArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Production that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionFindUniqueOrThrowArgs} args - Arguments to find a Production
     * @example
     * // Get one Production
     * const production = await prisma.production.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Production that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionFindFirstArgs} args - Arguments to find a Production
     * @example
     * // Get one Production
     * const production = await prisma.production.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionFindFirstArgs>(args?: SelectSubset<T, ProductionFindFirstArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Production that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionFindFirstOrThrowArgs} args - Arguments to find a Production
     * @example
     * // Get one Production
     * const production = await prisma.production.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productions
     * const productions = await prisma.production.findMany()
     * 
     * // Get first 10 Productions
     * const productions = await prisma.production.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionWithIdOnly = await prisma.production.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionFindManyArgs>(args?: SelectSubset<T, ProductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Production.
     * @param {ProductionCreateArgs} args - Arguments to create a Production.
     * @example
     * // Create one Production
     * const Production = await prisma.production.create({
     *   data: {
     *     // ... data to create a Production
     *   }
     * })
     * 
     */
    create<T extends ProductionCreateArgs>(args: SelectSubset<T, ProductionCreateArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productions.
     * @param {ProductionCreateManyArgs} args - Arguments to create many Productions.
     * @example
     * // Create many Productions
     * const production = await prisma.production.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionCreateManyArgs>(args?: SelectSubset<T, ProductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productions and returns the data saved in the database.
     * @param {ProductionCreateManyAndReturnArgs} args - Arguments to create many Productions.
     * @example
     * // Create many Productions
     * const production = await prisma.production.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productions and only return the `id`
     * const productionWithIdOnly = await prisma.production.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Production.
     * @param {ProductionDeleteArgs} args - Arguments to delete one Production.
     * @example
     * // Delete one Production
     * const Production = await prisma.production.delete({
     *   where: {
     *     // ... filter to delete one Production
     *   }
     * })
     * 
     */
    delete<T extends ProductionDeleteArgs>(args: SelectSubset<T, ProductionDeleteArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Production.
     * @param {ProductionUpdateArgs} args - Arguments to update one Production.
     * @example
     * // Update one Production
     * const production = await prisma.production.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionUpdateArgs>(args: SelectSubset<T, ProductionUpdateArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productions.
     * @param {ProductionDeleteManyArgs} args - Arguments to filter Productions to delete.
     * @example
     * // Delete a few Productions
     * const { count } = await prisma.production.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionDeleteManyArgs>(args?: SelectSubset<T, ProductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productions
     * const production = await prisma.production.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionUpdateManyArgs>(args: SelectSubset<T, ProductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productions and returns the data updated in the database.
     * @param {ProductionUpdateManyAndReturnArgs} args - Arguments to update many Productions.
     * @example
     * // Update many Productions
     * const production = await prisma.production.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Productions and only return the `id`
     * const productionWithIdOnly = await prisma.production.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Production.
     * @param {ProductionUpsertArgs} args - Arguments to update or create a Production.
     * @example
     * // Update or create a Production
     * const production = await prisma.production.upsert({
     *   create: {
     *     // ... data to create a Production
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Production we want to update
     *   }
     * })
     */
    upsert<T extends ProductionUpsertArgs>(args: SelectSubset<T, ProductionUpsertArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionCountArgs} args - Arguments to filter Productions to count.
     * @example
     * // Count the number of Productions
     * const count = await prisma.production.count({
     *   where: {
     *     // ... the filter for the Productions we want to count
     *   }
     * })
    **/
    count<T extends ProductionCountArgs>(
      args?: Subset<T, ProductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Production.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionAggregateArgs>(args: Subset<T, ProductionAggregateArgs>): Prisma.PrismaPromise<GetProductionAggregateType<T>>

    /**
     * Group by Production.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionGroupByArgs['orderBy'] }
        : { orderBy?: ProductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Production model
   */
  readonly fields: ProductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Production.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qualityChecks<T extends Production$qualityChecksArgs<ExtArgs> = {}>(args?: Subset<T, Production$qualityChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Production model
   */
  interface ProductionFieldRefs {
    readonly id: FieldRef<"Production", 'String'>
    readonly jobNumber: FieldRef<"Production", 'String'>
    readonly productName: FieldRef<"Production", 'String'>
    readonly productSKU: FieldRef<"Production", 'String'>
    readonly quantity: FieldRef<"Production", 'Int'>
    readonly targetQuantity: FieldRef<"Production", 'Int'>
    readonly completedQuantity: FieldRef<"Production", 'Int'>
    readonly status: FieldRef<"Production", 'ProductionStatus'>
    readonly priority: FieldRef<"Production", 'Priority'>
    readonly startDate: FieldRef<"Production", 'DateTime'>
    readonly targetDate: FieldRef<"Production", 'DateTime'>
    readonly completionDate: FieldRef<"Production", 'DateTime'>
    readonly qualityScore: FieldRef<"Production", 'Float'>
    readonly defectRate: FieldRef<"Production", 'Float'>
    readonly efficiency: FieldRef<"Production", 'Float'>
    readonly createdAt: FieldRef<"Production", 'DateTime'>
    readonly updatedAt: FieldRef<"Production", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Production findUnique
   */
  export type ProductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Production to fetch.
     */
    where: ProductionWhereUniqueInput
  }

  /**
   * Production findUniqueOrThrow
   */
  export type ProductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Production to fetch.
     */
    where: ProductionWhereUniqueInput
  }

  /**
   * Production findFirst
   */
  export type ProductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Production to fetch.
     */
    where?: ProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productions to fetch.
     */
    orderBy?: ProductionOrderByWithRelationInput | ProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productions.
     */
    cursor?: ProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productions.
     */
    distinct?: ProductionScalarFieldEnum | ProductionScalarFieldEnum[]
  }

  /**
   * Production findFirstOrThrow
   */
  export type ProductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Production to fetch.
     */
    where?: ProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productions to fetch.
     */
    orderBy?: ProductionOrderByWithRelationInput | ProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productions.
     */
    cursor?: ProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productions.
     */
    distinct?: ProductionScalarFieldEnum | ProductionScalarFieldEnum[]
  }

  /**
   * Production findMany
   */
  export type ProductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter, which Productions to fetch.
     */
    where?: ProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productions to fetch.
     */
    orderBy?: ProductionOrderByWithRelationInput | ProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productions.
     */
    cursor?: ProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productions.
     */
    skip?: number
    distinct?: ProductionScalarFieldEnum | ProductionScalarFieldEnum[]
  }

  /**
   * Production create
   */
  export type ProductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * The data needed to create a Production.
     */
    data: XOR<ProductionCreateInput, ProductionUncheckedCreateInput>
  }

  /**
   * Production createMany
   */
  export type ProductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productions.
     */
    data: ProductionCreateManyInput | ProductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Production createManyAndReturn
   */
  export type ProductionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * The data used to create many Productions.
     */
    data: ProductionCreateManyInput | ProductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Production update
   */
  export type ProductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * The data needed to update a Production.
     */
    data: XOR<ProductionUpdateInput, ProductionUncheckedUpdateInput>
    /**
     * Choose, which Production to update.
     */
    where: ProductionWhereUniqueInput
  }

  /**
   * Production updateMany
   */
  export type ProductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productions.
     */
    data: XOR<ProductionUpdateManyMutationInput, ProductionUncheckedUpdateManyInput>
    /**
     * Filter which Productions to update
     */
    where?: ProductionWhereInput
    /**
     * Limit how many Productions to update.
     */
    limit?: number
  }

  /**
   * Production updateManyAndReturn
   */
  export type ProductionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * The data used to update Productions.
     */
    data: XOR<ProductionUpdateManyMutationInput, ProductionUncheckedUpdateManyInput>
    /**
     * Filter which Productions to update
     */
    where?: ProductionWhereInput
    /**
     * Limit how many Productions to update.
     */
    limit?: number
  }

  /**
   * Production upsert
   */
  export type ProductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * The filter to search for the Production to update in case it exists.
     */
    where: ProductionWhereUniqueInput
    /**
     * In case the Production found by the `where` argument doesn't exist, create a new Production with this data.
     */
    create: XOR<ProductionCreateInput, ProductionUncheckedCreateInput>
    /**
     * In case the Production was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionUpdateInput, ProductionUncheckedUpdateInput>
  }

  /**
   * Production delete
   */
  export type ProductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    /**
     * Filter which Production to delete.
     */
    where: ProductionWhereUniqueInput
  }

  /**
   * Production deleteMany
   */
  export type ProductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productions to delete
     */
    where?: ProductionWhereInput
    /**
     * Limit how many Productions to delete.
     */
    limit?: number
  }

  /**
   * Production.qualityChecks
   */
  export type Production$qualityChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    where?: QualityCheckWhereInput
    orderBy?: QualityCheckOrderByWithRelationInput | QualityCheckOrderByWithRelationInput[]
    cursor?: QualityCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QualityCheckScalarFieldEnum | QualityCheckScalarFieldEnum[]
  }

  /**
   * Production without action
   */
  export type ProductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    unitCost: number | null
    totalValue: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    unitCost: number | null
    totalValue: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    quantity: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    location: string | null
    warehouse: string | null
    unitCost: number | null
    totalValue: number | null
    lastMovement: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    quantity: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    location: string | null
    warehouse: string | null
    unitCost: number | null
    totalValue: number | null
    lastMovement: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    quantity: number
    reorderPoint: number
    reorderQuantity: number
    location: number
    warehouse: number
    unitCost: number
    totalValue: number
    lastMovement: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
    reorderPoint?: true
    reorderQuantity?: true
    unitCost?: true
    totalValue?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
    reorderPoint?: true
    reorderQuantity?: true
    unitCost?: true
    totalValue?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    reorderPoint?: true
    reorderQuantity?: true
    location?: true
    warehouse?: true
    unitCost?: true
    totalValue?: true
    lastMovement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    reorderPoint?: true
    reorderQuantity?: true
    location?: true
    warehouse?: true
    unitCost?: true
    totalValue?: true
    lastMovement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    reorderPoint?: true
    reorderQuantity?: true
    location?: true
    warehouse?: true
    unitCost?: true
    totalValue?: true
    lastMovement?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    sku: string
    name: string
    description: string | null
    quantity: number
    reorderPoint: number
    reorderQuantity: number
    location: string
    warehouse: string
    unitCost: number
    totalValue: number
    lastMovement: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    location?: boolean
    warehouse?: boolean
    unitCost?: boolean
    totalValue?: boolean
    lastMovement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    movements?: boolean | Inventory$movementsArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    location?: boolean
    warehouse?: boolean
    unitCost?: boolean
    totalValue?: boolean
    lastMovement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    location?: boolean
    warehouse?: boolean
    unitCost?: boolean
    totalValue?: boolean
    lastMovement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    location?: boolean
    warehouse?: boolean
    unitCost?: boolean
    totalValue?: boolean
    lastMovement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "name" | "description" | "quantity" | "reorderPoint" | "reorderQuantity" | "location" | "warehouse" | "unitCost" | "totalValue" | "lastMovement" | "createdAt" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | Inventory$movementsArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      movements: Prisma.$InventoryMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      description: string | null
      quantity: number
      reorderPoint: number
      reorderQuantity: number
      location: string
      warehouse: string
      unitCost: number
      totalValue: number
      lastMovement: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movements<T extends Inventory$movementsArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly sku: FieldRef<"Inventory", 'String'>
    readonly name: FieldRef<"Inventory", 'String'>
    readonly description: FieldRef<"Inventory", 'String'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
    readonly reorderPoint: FieldRef<"Inventory", 'Int'>
    readonly reorderQuantity: FieldRef<"Inventory", 'Int'>
    readonly location: FieldRef<"Inventory", 'String'>
    readonly warehouse: FieldRef<"Inventory", 'String'>
    readonly unitCost: FieldRef<"Inventory", 'Float'>
    readonly totalValue: FieldRef<"Inventory", 'Float'>
    readonly lastMovement: FieldRef<"Inventory", 'DateTime'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory.movements
   */
  export type Inventory$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: string | null
    inventoryId: string | null
    type: $Enums.MovementType | null
    quantity: number | null
    reference: string | null
    reason: string | null
    performedBy: string | null
    createdAt: Date | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: string | null
    inventoryId: string | null
    type: $Enums.MovementType | null
    quantity: number | null
    reference: string | null
    reason: string | null
    performedBy: string | null
    createdAt: Date | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    inventoryId: number
    type: number
    quantity: number
    reference: number
    reason: number
    performedBy: number
    createdAt: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    inventoryId?: true
    type?: true
    quantity?: true
    reference?: true
    reason?: true
    performedBy?: true
    createdAt?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    inventoryId?: true
    type?: true
    quantity?: true
    reference?: true
    reason?: true
    performedBy?: true
    createdAt?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    inventoryId?: true
    type?: true
    quantity?: true
    reference?: true
    reason?: true
    performedBy?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: string
    inventoryId: string
    type: $Enums.MovementType
    quantity: number
    reference: string | null
    reason: string | null
    performedBy: string | null
    createdAt: Date
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryId?: boolean
    type?: boolean
    quantity?: boolean
    reference?: boolean
    reason?: boolean
    performedBy?: boolean
    createdAt?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryId?: boolean
    type?: boolean
    quantity?: boolean
    reference?: boolean
    reason?: boolean
    performedBy?: boolean
    createdAt?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryId?: boolean
    type?: boolean
    quantity?: boolean
    reference?: boolean
    reason?: boolean
    performedBy?: boolean
    createdAt?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectScalar = {
    id?: boolean
    inventoryId?: boolean
    type?: boolean
    quantity?: boolean
    reference?: boolean
    reason?: boolean
    performedBy?: boolean
    createdAt?: boolean
  }

  export type InventoryMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inventoryId" | "type" | "quantity" | "reference" | "reason" | "performedBy" | "createdAt", ExtArgs["result"]["inventoryMovement"]>
  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      inventory: Prisma.$InventoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inventoryId: string
      type: $Enums.MovementType
      quantity: number
      reference: string | null
      reason: string | null
      performedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryMovements and returns the data saved in the database.
     * @param {InventoryMovementCreateManyAndReturnArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements and returns the data updated in the database.
     * @param {InventoryMovementUpdateManyAndReturnArgs} args - Arguments to update many InventoryMovements.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'String'>
    readonly inventoryId: FieldRef<"InventoryMovement", 'String'>
    readonly type: FieldRef<"InventoryMovement", 'MovementType'>
    readonly quantity: FieldRef<"InventoryMovement", 'Int'>
    readonly reference: FieldRef<"InventoryMovement", 'String'>
    readonly reason: FieldRef<"InventoryMovement", 'String'>
    readonly performedBy: FieldRef<"InventoryMovement", 'String'>
    readonly createdAt: FieldRef<"InventoryMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement createManyAndReturn
   */
  export type InventoryMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
  }

  /**
   * InventoryMovement updateManyAndReturn
   */
  export type InventoryMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to delete.
     */
    limit?: number
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model AIInsight
   */

  export type AggregateAIInsight = {
    _count: AIInsightCountAggregateOutputType | null
    _avg: AIInsightAvgAggregateOutputType | null
    _sum: AIInsightSumAggregateOutputType | null
    _min: AIInsightMinAggregateOutputType | null
    _max: AIInsightMaxAggregateOutputType | null
  }

  export type AIInsightAvgAggregateOutputType = {
    confidence: number | null
    embedding: number | null
  }

  export type AIInsightSumAggregateOutputType = {
    confidence: number | null
    embedding: number[]
  }

  export type AIInsightMinAggregateOutputType = {
    id: string | null
    type: string | null
    category: string | null
    title: string | null
    content: string | null
    confidence: number | null
    priority: string | null
    actionable: boolean | null
    actioned: boolean | null
    createdAt: Date | null
  }

  export type AIInsightMaxAggregateOutputType = {
    id: string | null
    type: string | null
    category: string | null
    title: string | null
    content: string | null
    confidence: number | null
    priority: string | null
    actionable: boolean | null
    actioned: boolean | null
    createdAt: Date | null
  }

  export type AIInsightCountAggregateOutputType = {
    id: number
    type: number
    category: number
    title: number
    content: number
    confidence: number
    priority: number
    embedding: number
    metadata: number
    actionable: number
    actioned: number
    createdAt: number
    _all: number
  }


  export type AIInsightAvgAggregateInputType = {
    confidence?: true
    embedding?: true
  }

  export type AIInsightSumAggregateInputType = {
    confidence?: true
    embedding?: true
  }

  export type AIInsightMinAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    content?: true
    confidence?: true
    priority?: true
    actionable?: true
    actioned?: true
    createdAt?: true
  }

  export type AIInsightMaxAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    content?: true
    confidence?: true
    priority?: true
    actionable?: true
    actioned?: true
    createdAt?: true
  }

  export type AIInsightCountAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    content?: true
    confidence?: true
    priority?: true
    embedding?: true
    metadata?: true
    actionable?: true
    actioned?: true
    createdAt?: true
    _all?: true
  }

  export type AIInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIInsight to aggregate.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIInsights
    **/
    _count?: true | AIInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIInsightMaxAggregateInputType
  }

  export type GetAIInsightAggregateType<T extends AIInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateAIInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIInsight[P]>
      : GetScalarType<T[P], AggregateAIInsight[P]>
  }




  export type AIInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIInsightWhereInput
    orderBy?: AIInsightOrderByWithAggregationInput | AIInsightOrderByWithAggregationInput[]
    by: AIInsightScalarFieldEnum[] | AIInsightScalarFieldEnum
    having?: AIInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIInsightCountAggregateInputType | true
    _avg?: AIInsightAvgAggregateInputType
    _sum?: AIInsightSumAggregateInputType
    _min?: AIInsightMinAggregateInputType
    _max?: AIInsightMaxAggregateInputType
  }

  export type AIInsightGroupByOutputType = {
    id: string
    type: string
    category: string
    title: string
    content: string
    confidence: number
    priority: string
    embedding: number[]
    metadata: JsonValue
    actionable: boolean
    actioned: boolean
    createdAt: Date
    _count: AIInsightCountAggregateOutputType | null
    _avg: AIInsightAvgAggregateOutputType | null
    _sum: AIInsightSumAggregateOutputType | null
    _min: AIInsightMinAggregateOutputType | null
    _max: AIInsightMaxAggregateOutputType | null
  }

  type GetAIInsightGroupByPayload<T extends AIInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIInsightGroupByOutputType[P]>
            : GetScalarType<T[P], AIInsightGroupByOutputType[P]>
        }
      >
    >


  export type AIInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    confidence?: boolean
    priority?: boolean
    embedding?: boolean
    metadata?: boolean
    actionable?: boolean
    actioned?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIInsight"]>

  export type AIInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    confidence?: boolean
    priority?: boolean
    embedding?: boolean
    metadata?: boolean
    actionable?: boolean
    actioned?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIInsight"]>

  export type AIInsightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    confidence?: boolean
    priority?: boolean
    embedding?: boolean
    metadata?: boolean
    actionable?: boolean
    actioned?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIInsight"]>

  export type AIInsightSelectScalar = {
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    confidence?: boolean
    priority?: boolean
    embedding?: boolean
    metadata?: boolean
    actionable?: boolean
    actioned?: boolean
    createdAt?: boolean
  }

  export type AIInsightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "category" | "title" | "content" | "confidence" | "priority" | "embedding" | "metadata" | "actionable" | "actioned" | "createdAt", ExtArgs["result"]["aIInsight"]>

  export type $AIInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIInsight"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      category: string
      title: string
      content: string
      confidence: number
      priority: string
      embedding: number[]
      metadata: Prisma.JsonValue
      actionable: boolean
      actioned: boolean
      createdAt: Date
    }, ExtArgs["result"]["aIInsight"]>
    composites: {}
  }

  type AIInsightGetPayload<S extends boolean | null | undefined | AIInsightDefaultArgs> = $Result.GetResult<Prisma.$AIInsightPayload, S>

  type AIInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIInsightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIInsightCountAggregateInputType | true
    }

  export interface AIInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIInsight'], meta: { name: 'AIInsight' } }
    /**
     * Find zero or one AIInsight that matches the filter.
     * @param {AIInsightFindUniqueArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIInsightFindUniqueArgs>(args: SelectSubset<T, AIInsightFindUniqueArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIInsight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIInsightFindUniqueOrThrowArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, AIInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindFirstArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIInsightFindFirstArgs>(args?: SelectSubset<T, AIInsightFindFirstArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindFirstOrThrowArgs} args - Arguments to find a AIInsight
     * @example
     * // Get one AIInsight
     * const aIInsight = await prisma.aIInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, AIInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIInsights
     * const aIInsights = await prisma.aIInsight.findMany()
     * 
     * // Get first 10 AIInsights
     * const aIInsights = await prisma.aIInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIInsightWithIdOnly = await prisma.aIInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIInsightFindManyArgs>(args?: SelectSubset<T, AIInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIInsight.
     * @param {AIInsightCreateArgs} args - Arguments to create a AIInsight.
     * @example
     * // Create one AIInsight
     * const AIInsight = await prisma.aIInsight.create({
     *   data: {
     *     // ... data to create a AIInsight
     *   }
     * })
     * 
     */
    create<T extends AIInsightCreateArgs>(args: SelectSubset<T, AIInsightCreateArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIInsights.
     * @param {AIInsightCreateManyArgs} args - Arguments to create many AIInsights.
     * @example
     * // Create many AIInsights
     * const aIInsight = await prisma.aIInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIInsightCreateManyArgs>(args?: SelectSubset<T, AIInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIInsights and returns the data saved in the database.
     * @param {AIInsightCreateManyAndReturnArgs} args - Arguments to create many AIInsights.
     * @example
     * // Create many AIInsights
     * const aIInsight = await prisma.aIInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIInsights and only return the `id`
     * const aIInsightWithIdOnly = await prisma.aIInsight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, AIInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIInsight.
     * @param {AIInsightDeleteArgs} args - Arguments to delete one AIInsight.
     * @example
     * // Delete one AIInsight
     * const AIInsight = await prisma.aIInsight.delete({
     *   where: {
     *     // ... filter to delete one AIInsight
     *   }
     * })
     * 
     */
    delete<T extends AIInsightDeleteArgs>(args: SelectSubset<T, AIInsightDeleteArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIInsight.
     * @param {AIInsightUpdateArgs} args - Arguments to update one AIInsight.
     * @example
     * // Update one AIInsight
     * const aIInsight = await prisma.aIInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIInsightUpdateArgs>(args: SelectSubset<T, AIInsightUpdateArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIInsights.
     * @param {AIInsightDeleteManyArgs} args - Arguments to filter AIInsights to delete.
     * @example
     * // Delete a few AIInsights
     * const { count } = await prisma.aIInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIInsightDeleteManyArgs>(args?: SelectSubset<T, AIInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIInsights
     * const aIInsight = await prisma.aIInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIInsightUpdateManyArgs>(args: SelectSubset<T, AIInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIInsights and returns the data updated in the database.
     * @param {AIInsightUpdateManyAndReturnArgs} args - Arguments to update many AIInsights.
     * @example
     * // Update many AIInsights
     * const aIInsight = await prisma.aIInsight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIInsights and only return the `id`
     * const aIInsightWithIdOnly = await prisma.aIInsight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIInsightUpdateManyAndReturnArgs>(args: SelectSubset<T, AIInsightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIInsight.
     * @param {AIInsightUpsertArgs} args - Arguments to update or create a AIInsight.
     * @example
     * // Update or create a AIInsight
     * const aIInsight = await prisma.aIInsight.upsert({
     *   create: {
     *     // ... data to create a AIInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIInsight we want to update
     *   }
     * })
     */
    upsert<T extends AIInsightUpsertArgs>(args: SelectSubset<T, AIInsightUpsertArgs<ExtArgs>>): Prisma__AIInsightClient<$Result.GetResult<Prisma.$AIInsightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightCountArgs} args - Arguments to filter AIInsights to count.
     * @example
     * // Count the number of AIInsights
     * const count = await prisma.aIInsight.count({
     *   where: {
     *     // ... the filter for the AIInsights we want to count
     *   }
     * })
    **/
    count<T extends AIInsightCountArgs>(
      args?: Subset<T, AIInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIInsightAggregateArgs>(args: Subset<T, AIInsightAggregateArgs>): Prisma.PrismaPromise<GetAIInsightAggregateType<T>>

    /**
     * Group by AIInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIInsightGroupByArgs['orderBy'] }
        : { orderBy?: AIInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIInsight model
   */
  readonly fields: AIInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIInsight model
   */
  interface AIInsightFieldRefs {
    readonly id: FieldRef<"AIInsight", 'String'>
    readonly type: FieldRef<"AIInsight", 'String'>
    readonly category: FieldRef<"AIInsight", 'String'>
    readonly title: FieldRef<"AIInsight", 'String'>
    readonly content: FieldRef<"AIInsight", 'String'>
    readonly confidence: FieldRef<"AIInsight", 'Float'>
    readonly priority: FieldRef<"AIInsight", 'String'>
    readonly embedding: FieldRef<"AIInsight", 'Float[]'>
    readonly metadata: FieldRef<"AIInsight", 'Json'>
    readonly actionable: FieldRef<"AIInsight", 'Boolean'>
    readonly actioned: FieldRef<"AIInsight", 'Boolean'>
    readonly createdAt: FieldRef<"AIInsight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIInsight findUnique
   */
  export type AIInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight findUniqueOrThrow
   */
  export type AIInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight findFirst
   */
  export type AIInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIInsights.
     */
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight findFirstOrThrow
   */
  export type AIInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Filter, which AIInsight to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIInsights.
     */
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight findMany
   */
  export type AIInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Filter, which AIInsights to fetch.
     */
    where?: AIInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInsights to fetch.
     */
    orderBy?: AIInsightOrderByWithRelationInput | AIInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIInsights.
     */
    cursor?: AIInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInsights.
     */
    skip?: number
    distinct?: AIInsightScalarFieldEnum | AIInsightScalarFieldEnum[]
  }

  /**
   * AIInsight create
   */
  export type AIInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * The data needed to create a AIInsight.
     */
    data: XOR<AIInsightCreateInput, AIInsightUncheckedCreateInput>
  }

  /**
   * AIInsight createMany
   */
  export type AIInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIInsights.
     */
    data: AIInsightCreateManyInput | AIInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIInsight createManyAndReturn
   */
  export type AIInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * The data used to create many AIInsights.
     */
    data: AIInsightCreateManyInput | AIInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIInsight update
   */
  export type AIInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * The data needed to update a AIInsight.
     */
    data: XOR<AIInsightUpdateInput, AIInsightUncheckedUpdateInput>
    /**
     * Choose, which AIInsight to update.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight updateMany
   */
  export type AIInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIInsights.
     */
    data: XOR<AIInsightUpdateManyMutationInput, AIInsightUncheckedUpdateManyInput>
    /**
     * Filter which AIInsights to update
     */
    where?: AIInsightWhereInput
    /**
     * Limit how many AIInsights to update.
     */
    limit?: number
  }

  /**
   * AIInsight updateManyAndReturn
   */
  export type AIInsightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * The data used to update AIInsights.
     */
    data: XOR<AIInsightUpdateManyMutationInput, AIInsightUncheckedUpdateManyInput>
    /**
     * Filter which AIInsights to update
     */
    where?: AIInsightWhereInput
    /**
     * Limit how many AIInsights to update.
     */
    limit?: number
  }

  /**
   * AIInsight upsert
   */
  export type AIInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * The filter to search for the AIInsight to update in case it exists.
     */
    where: AIInsightWhereUniqueInput
    /**
     * In case the AIInsight found by the `where` argument doesn't exist, create a new AIInsight with this data.
     */
    create: XOR<AIInsightCreateInput, AIInsightUncheckedCreateInput>
    /**
     * In case the AIInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIInsightUpdateInput, AIInsightUncheckedUpdateInput>
  }

  /**
   * AIInsight delete
   */
  export type AIInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
    /**
     * Filter which AIInsight to delete.
     */
    where: AIInsightWhereUniqueInput
  }

  /**
   * AIInsight deleteMany
   */
  export type AIInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIInsights to delete
     */
    where?: AIInsightWhereInput
    /**
     * Limit how many AIInsights to delete.
     */
    limit?: number
  }

  /**
   * AIInsight without action
   */
  export type AIInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInsight
     */
    select?: AIInsightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInsight
     */
    omit?: AIInsightOmit<ExtArgs> | null
  }


  /**
   * Model Dashboard
   */

  export type AggregateDashboard = {
    _count: DashboardCountAggregateOutputType | null
    _min: DashboardMinAggregateOutputType | null
    _max: DashboardMaxAggregateOutputType | null
  }

  export type DashboardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    type: number
    layout: number
    widgets: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DashboardMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    layout?: true
    widgets?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DashboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboard to aggregate.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dashboards
    **/
    _count?: true | DashboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardMaxAggregateInputType
  }

  export type GetDashboardAggregateType<T extends DashboardAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboard[P]>
      : GetScalarType<T[P], AggregateDashboard[P]>
  }




  export type DashboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardWhereInput
    orderBy?: DashboardOrderByWithAggregationInput | DashboardOrderByWithAggregationInput[]
    by: DashboardScalarFieldEnum[] | DashboardScalarFieldEnum
    having?: DashboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardCountAggregateInputType | true
    _min?: DashboardMinAggregateInputType
    _max?: DashboardMaxAggregateInputType
  }

  export type DashboardGroupByOutputType = {
    id: string
    userId: string
    name: string
    type: string
    layout: JsonValue
    widgets: JsonValue
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: DashboardCountAggregateOutputType | null
    _min: DashboardMinAggregateOutputType | null
    _max: DashboardMaxAggregateOutputType | null
  }

  type GetDashboardGroupByPayload<T extends DashboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardGroupByOutputType[P]>
        }
      >
    >


  export type DashboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    layout?: boolean
    widgets?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    layout?: boolean
    widgets?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    layout?: boolean
    widgets?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    layout?: boolean
    widgets?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DashboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "type" | "layout" | "widgets" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["dashboard"]>
  export type DashboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DashboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DashboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DashboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dashboard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      type: string
      layout: Prisma.JsonValue
      widgets: Prisma.JsonValue
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dashboard"]>
    composites: {}
  }

  type DashboardGetPayload<S extends boolean | null | undefined | DashboardDefaultArgs> = $Result.GetResult<Prisma.$DashboardPayload, S>

  type DashboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardCountAggregateInputType | true
    }

  export interface DashboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dashboard'], meta: { name: 'Dashboard' } }
    /**
     * Find zero or one Dashboard that matches the filter.
     * @param {DashboardFindUniqueArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardFindUniqueArgs>(args: SelectSubset<T, DashboardFindUniqueArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dashboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardFindUniqueOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dashboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardFindFirstArgs>(args?: SelectSubset<T, DashboardFindFirstArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dashboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dashboards
     * const dashboards = await prisma.dashboard.findMany()
     * 
     * // Get first 10 Dashboards
     * const dashboards = await prisma.dashboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardFindManyArgs>(args?: SelectSubset<T, DashboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dashboard.
     * @param {DashboardCreateArgs} args - Arguments to create a Dashboard.
     * @example
     * // Create one Dashboard
     * const Dashboard = await prisma.dashboard.create({
     *   data: {
     *     // ... data to create a Dashboard
     *   }
     * })
     * 
     */
    create<T extends DashboardCreateArgs>(args: SelectSubset<T, DashboardCreateArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dashboards.
     * @param {DashboardCreateManyArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardCreateManyArgs>(args?: SelectSubset<T, DashboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dashboards and returns the data saved in the database.
     * @param {DashboardCreateManyAndReturnArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dashboard.
     * @param {DashboardDeleteArgs} args - Arguments to delete one Dashboard.
     * @example
     * // Delete one Dashboard
     * const Dashboard = await prisma.dashboard.delete({
     *   where: {
     *     // ... filter to delete one Dashboard
     *   }
     * })
     * 
     */
    delete<T extends DashboardDeleteArgs>(args: SelectSubset<T, DashboardDeleteArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dashboard.
     * @param {DashboardUpdateArgs} args - Arguments to update one Dashboard.
     * @example
     * // Update one Dashboard
     * const dashboard = await prisma.dashboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardUpdateArgs>(args: SelectSubset<T, DashboardUpdateArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dashboards.
     * @param {DashboardDeleteManyArgs} args - Arguments to filter Dashboards to delete.
     * @example
     * // Delete a few Dashboards
     * const { count } = await prisma.dashboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardDeleteManyArgs>(args?: SelectSubset<T, DashboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardUpdateManyArgs>(args: SelectSubset<T, DashboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards and returns the data updated in the database.
     * @param {DashboardUpdateManyAndReturnArgs} args - Arguments to update many Dashboards.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dashboard.
     * @param {DashboardUpsertArgs} args - Arguments to update or create a Dashboard.
     * @example
     * // Update or create a Dashboard
     * const dashboard = await prisma.dashboard.upsert({
     *   create: {
     *     // ... data to create a Dashboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dashboard we want to update
     *   }
     * })
     */
    upsert<T extends DashboardUpsertArgs>(args: SelectSubset<T, DashboardUpsertArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardCountArgs} args - Arguments to filter Dashboards to count.
     * @example
     * // Count the number of Dashboards
     * const count = await prisma.dashboard.count({
     *   where: {
     *     // ... the filter for the Dashboards we want to count
     *   }
     * })
    **/
    count<T extends DashboardCountArgs>(
      args?: Subset<T, DashboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardAggregateArgs>(args: Subset<T, DashboardAggregateArgs>): Prisma.PrismaPromise<GetDashboardAggregateType<T>>

    /**
     * Group by Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardGroupByArgs['orderBy'] }
        : { orderBy?: DashboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dashboard model
   */
  readonly fields: DashboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dashboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dashboard model
   */
  interface DashboardFieldRefs {
    readonly id: FieldRef<"Dashboard", 'String'>
    readonly userId: FieldRef<"Dashboard", 'String'>
    readonly name: FieldRef<"Dashboard", 'String'>
    readonly type: FieldRef<"Dashboard", 'String'>
    readonly layout: FieldRef<"Dashboard", 'Json'>
    readonly widgets: FieldRef<"Dashboard", 'Json'>
    readonly isDefault: FieldRef<"Dashboard", 'Boolean'>
    readonly createdAt: FieldRef<"Dashboard", 'DateTime'>
    readonly updatedAt: FieldRef<"Dashboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dashboard findUnique
   */
  export type DashboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard findUniqueOrThrow
   */
  export type DashboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard findFirst
   */
  export type DashboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard findFirstOrThrow
   */
  export type DashboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard findMany
   */
  export type DashboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboards to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
  }

  /**
   * Dashboard create
   */
  export type DashboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Dashboard.
     */
    data: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>
  }

  /**
   * Dashboard createMany
   */
  export type DashboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dashboard createManyAndReturn
   */
  export type DashboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dashboard update
   */
  export type DashboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Dashboard.
     */
    data: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>
    /**
     * Choose, which Dashboard to update.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard updateMany
   */
  export type DashboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number
  }

  /**
   * Dashboard updateManyAndReturn
   */
  export type DashboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dashboard upsert
   */
  export type DashboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Dashboard to update in case it exists.
     */
    where: DashboardWhereUniqueInput
    /**
     * In case the Dashboard found by the `where` argument doesn't exist, create a new Dashboard with this data.
     */
    create: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>
    /**
     * In case the Dashboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>
  }

  /**
   * Dashboard delete
   */
  export type DashboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter which Dashboard to delete.
     */
    where: DashboardWhereUniqueInput
  }

  /**
   * Dashboard deleteMany
   */
  export type DashboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboards to delete
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to delete.
     */
    limit?: number
  }

  /**
   * Dashboard without action
   */
  export type DashboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
  }


  /**
   * Model Analytics
   */

  export type AggregateAnalytics = {
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  export type AnalyticsAvgAggregateOutputType = {
    value: number | null
    forecast: number | null
    actual: number | null
    variance: number | null
  }

  export type AnalyticsSumAggregateOutputType = {
    value: number | null
    forecast: number | null
    actual: number | null
    variance: number | null
  }

  export type AnalyticsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    metric: string | null
    value: number | null
    dimension: string | null
    forecast: number | null
    actual: number | null
    variance: number | null
    createdAt: Date | null
  }

  export type AnalyticsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    metric: string | null
    value: number | null
    dimension: string | null
    forecast: number | null
    actual: number | null
    variance: number | null
    createdAt: Date | null
  }

  export type AnalyticsCountAggregateOutputType = {
    id: number
    date: number
    metric: number
    value: number
    dimension: number
    forecast: number
    actual: number
    variance: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AnalyticsAvgAggregateInputType = {
    value?: true
    forecast?: true
    actual?: true
    variance?: true
  }

  export type AnalyticsSumAggregateInputType = {
    value?: true
    forecast?: true
    actual?: true
    variance?: true
  }

  export type AnalyticsMinAggregateInputType = {
    id?: true
    date?: true
    metric?: true
    value?: true
    dimension?: true
    forecast?: true
    actual?: true
    variance?: true
    createdAt?: true
  }

  export type AnalyticsMaxAggregateInputType = {
    id?: true
    date?: true
    metric?: true
    value?: true
    dimension?: true
    forecast?: true
    actual?: true
    variance?: true
    createdAt?: true
  }

  export type AnalyticsCountAggregateInputType = {
    id?: true
    date?: true
    metric?: true
    value?: true
    dimension?: true
    forecast?: true
    actual?: true
    variance?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to aggregate.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analytics
    **/
    _count?: true | AnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsMaxAggregateInputType
  }

  export type GetAnalyticsAggregateType<T extends AnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalytics[P]>
      : GetScalarType<T[P], AggregateAnalytics[P]>
  }




  export type AnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithAggregationInput | AnalyticsOrderByWithAggregationInput[]
    by: AnalyticsScalarFieldEnum[] | AnalyticsScalarFieldEnum
    having?: AnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsCountAggregateInputType | true
    _avg?: AnalyticsAvgAggregateInputType
    _sum?: AnalyticsSumAggregateInputType
    _min?: AnalyticsMinAggregateInputType
    _max?: AnalyticsMaxAggregateInputType
  }

  export type AnalyticsGroupByOutputType = {
    id: string
    date: Date
    metric: string
    value: number
    dimension: string | null
    forecast: number | null
    actual: number | null
    variance: number | null
    metadata: JsonValue
    createdAt: Date
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  type GetAnalyticsGroupByPayload<T extends AnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    metric?: boolean
    value?: boolean
    dimension?: boolean
    forecast?: boolean
    actual?: boolean
    variance?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    metric?: boolean
    value?: boolean
    dimension?: boolean
    forecast?: boolean
    actual?: boolean
    variance?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    metric?: boolean
    value?: boolean
    dimension?: boolean
    forecast?: boolean
    actual?: boolean
    variance?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectScalar = {
    id?: boolean
    date?: boolean
    metric?: boolean
    value?: boolean
    dimension?: boolean
    forecast?: boolean
    actual?: boolean
    variance?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "metric" | "value" | "dimension" | "forecast" | "actual" | "variance" | "metadata" | "createdAt", ExtArgs["result"]["analytics"]>

  export type $AnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      metric: string
      value: number
      dimension: string | null
      forecast: number | null
      actual: number | null
      variance: number | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["analytics"]>
    composites: {}
  }

  type AnalyticsGetPayload<S extends boolean | null | undefined | AnalyticsDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsPayload, S>

  type AnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsCountAggregateInputType | true
    }

  export interface AnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analytics'], meta: { name: 'Analytics' } }
    /**
     * Find zero or one Analytics that matches the filter.
     * @param {AnalyticsFindUniqueArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsFindUniqueArgs>(args: SelectSubset<T, AnalyticsFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Analytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsFindUniqueOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsFindFirstArgs>(args?: SelectSubset<T, AnalyticsFindFirstArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analytics
     * const analytics = await prisma.analytics.findMany()
     * 
     * // Get first 10 Analytics
     * const analytics = await prisma.analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsWithIdOnly = await prisma.analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsFindManyArgs>(args?: SelectSubset<T, AnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Analytics.
     * @param {AnalyticsCreateArgs} args - Arguments to create a Analytics.
     * @example
     * // Create one Analytics
     * const Analytics = await prisma.analytics.create({
     *   data: {
     *     // ... data to create a Analytics
     *   }
     * })
     * 
     */
    create<T extends AnalyticsCreateArgs>(args: SelectSubset<T, AnalyticsCreateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Analytics.
     * @param {AnalyticsCreateManyArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsCreateManyArgs>(args?: SelectSubset<T, AnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analytics and returns the data saved in the database.
     * @param {AnalyticsCreateManyAndReturnArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Analytics.
     * @param {AnalyticsDeleteArgs} args - Arguments to delete one Analytics.
     * @example
     * // Delete one Analytics
     * const Analytics = await prisma.analytics.delete({
     *   where: {
     *     // ... filter to delete one Analytics
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsDeleteArgs>(args: SelectSubset<T, AnalyticsDeleteArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Analytics.
     * @param {AnalyticsUpdateArgs} args - Arguments to update one Analytics.
     * @example
     * // Update one Analytics
     * const analytics = await prisma.analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsUpdateArgs>(args: SelectSubset<T, AnalyticsUpdateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Analytics.
     * @param {AnalyticsDeleteManyArgs} args - Arguments to filter Analytics to delete.
     * @example
     * // Delete a few Analytics
     * const { count } = await prisma.analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsDeleteManyArgs>(args?: SelectSubset<T, AnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsUpdateManyArgs>(args: SelectSubset<T, AnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics and returns the data updated in the database.
     * @param {AnalyticsUpdateManyAndReturnArgs} args - Arguments to update many Analytics.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Analytics.
     * @param {AnalyticsUpsertArgs} args - Arguments to update or create a Analytics.
     * @example
     * // Update or create a Analytics
     * const analytics = await prisma.analytics.upsert({
     *   create: {
     *     // ... data to create a Analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analytics we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsUpsertArgs>(args: SelectSubset<T, AnalyticsUpsertArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCountArgs} args - Arguments to filter Analytics to count.
     * @example
     * // Count the number of Analytics
     * const count = await prisma.analytics.count({
     *   where: {
     *     // ... the filter for the Analytics we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsCountArgs>(
      args?: Subset<T, AnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAggregateArgs>(args: Subset<T, AnalyticsAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAggregateType<T>>

    /**
     * Group by Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analytics model
   */
  readonly fields: AnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analytics model
   */
  interface AnalyticsFieldRefs {
    readonly id: FieldRef<"Analytics", 'String'>
    readonly date: FieldRef<"Analytics", 'DateTime'>
    readonly metric: FieldRef<"Analytics", 'String'>
    readonly value: FieldRef<"Analytics", 'Float'>
    readonly dimension: FieldRef<"Analytics", 'String'>
    readonly forecast: FieldRef<"Analytics", 'Float'>
    readonly actual: FieldRef<"Analytics", 'Float'>
    readonly variance: FieldRef<"Analytics", 'Float'>
    readonly metadata: FieldRef<"Analytics", 'Json'>
    readonly createdAt: FieldRef<"Analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Analytics findUnique
   */
  export type AnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findUniqueOrThrow
   */
  export type AnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findFirst
   */
  export type AnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findFirstOrThrow
   */
  export type AnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findMany
   */
  export type AnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics create
   */
  export type AnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to create a Analytics.
     */
    data: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
  }

  /**
   * Analytics createMany
   */
  export type AnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics createManyAndReturn
   */
  export type AnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics update
   */
  export type AnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to update a Analytics.
     */
    data: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
    /**
     * Choose, which Analytics to update.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics updateMany
   */
  export type AnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
  }

  /**
   * Analytics updateManyAndReturn
   */
  export type AnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
  }

  /**
   * Analytics upsert
   */
  export type AnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The filter to search for the Analytics to update in case it exists.
     */
    where: AnalyticsWhereUniqueInput
    /**
     * In case the Analytics found by the `where` argument doesn't exist, create a new Analytics with this data.
     */
    create: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
    /**
     * In case the Analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
  }

  /**
   * Analytics delete
   */
  export type AnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter which Analytics to delete.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics deleteMany
   */
  export type AnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to delete
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to delete.
     */
    limit?: number
  }

  /**
   * Analytics without action
   */
  export type AnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
  }


  /**
   * Model MCPRequest
   */

  export type AggregateMCPRequest = {
    _count: MCPRequestCountAggregateOutputType | null
    _avg: MCPRequestAvgAggregateOutputType | null
    _sum: MCPRequestSumAggregateOutputType | null
    _min: MCPRequestMinAggregateOutputType | null
    _max: MCPRequestMaxAggregateOutputType | null
  }

  export type MCPRequestAvgAggregateOutputType = {
    processingTime: number | null
  }

  export type MCPRequestSumAggregateOutputType = {
    processingTime: number | null
  }

  export type MCPRequestMinAggregateOutputType = {
    id: string | null
    tool: string | null
    status: string | null
    processingTime: number | null
    error: string | null
    createdAt: Date | null
  }

  export type MCPRequestMaxAggregateOutputType = {
    id: string | null
    tool: string | null
    status: string | null
    processingTime: number | null
    error: string | null
    createdAt: Date | null
  }

  export type MCPRequestCountAggregateOutputType = {
    id: number
    tool: number
    request: number
    response: number
    status: number
    processingTime: number
    error: number
    createdAt: number
    _all: number
  }


  export type MCPRequestAvgAggregateInputType = {
    processingTime?: true
  }

  export type MCPRequestSumAggregateInputType = {
    processingTime?: true
  }

  export type MCPRequestMinAggregateInputType = {
    id?: true
    tool?: true
    status?: true
    processingTime?: true
    error?: true
    createdAt?: true
  }

  export type MCPRequestMaxAggregateInputType = {
    id?: true
    tool?: true
    status?: true
    processingTime?: true
    error?: true
    createdAt?: true
  }

  export type MCPRequestCountAggregateInputType = {
    id?: true
    tool?: true
    request?: true
    response?: true
    status?: true
    processingTime?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type MCPRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCPRequest to aggregate.
     */
    where?: MCPRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPRequests to fetch.
     */
    orderBy?: MCPRequestOrderByWithRelationInput | MCPRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCPRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCPRequests
    **/
    _count?: true | MCPRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MCPRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MCPRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCPRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCPRequestMaxAggregateInputType
  }

  export type GetMCPRequestAggregateType<T extends MCPRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMCPRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCPRequest[P]>
      : GetScalarType<T[P], AggregateMCPRequest[P]>
  }




  export type MCPRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MCPRequestWhereInput
    orderBy?: MCPRequestOrderByWithAggregationInput | MCPRequestOrderByWithAggregationInput[]
    by: MCPRequestScalarFieldEnum[] | MCPRequestScalarFieldEnum
    having?: MCPRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCPRequestCountAggregateInputType | true
    _avg?: MCPRequestAvgAggregateInputType
    _sum?: MCPRequestSumAggregateInputType
    _min?: MCPRequestMinAggregateInputType
    _max?: MCPRequestMaxAggregateInputType
  }

  export type MCPRequestGroupByOutputType = {
    id: string
    tool: string
    request: JsonValue
    response: JsonValue | null
    status: string
    processingTime: number | null
    error: string | null
    createdAt: Date
    _count: MCPRequestCountAggregateOutputType | null
    _avg: MCPRequestAvgAggregateOutputType | null
    _sum: MCPRequestSumAggregateOutputType | null
    _min: MCPRequestMinAggregateOutputType | null
    _max: MCPRequestMaxAggregateOutputType | null
  }

  type GetMCPRequestGroupByPayload<T extends MCPRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCPRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCPRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCPRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MCPRequestGroupByOutputType[P]>
        }
      >
    >


  export type MCPRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tool?: boolean
    request?: boolean
    response?: boolean
    status?: boolean
    processingTime?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mCPRequest"]>

  export type MCPRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tool?: boolean
    request?: boolean
    response?: boolean
    status?: boolean
    processingTime?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mCPRequest"]>

  export type MCPRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tool?: boolean
    request?: boolean
    response?: boolean
    status?: boolean
    processingTime?: boolean
    error?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mCPRequest"]>

  export type MCPRequestSelectScalar = {
    id?: boolean
    tool?: boolean
    request?: boolean
    response?: boolean
    status?: boolean
    processingTime?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type MCPRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tool" | "request" | "response" | "status" | "processingTime" | "error" | "createdAt", ExtArgs["result"]["mCPRequest"]>

  export type $MCPRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MCPRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tool: string
      request: Prisma.JsonValue
      response: Prisma.JsonValue | null
      status: string
      processingTime: number | null
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["mCPRequest"]>
    composites: {}
  }

  type MCPRequestGetPayload<S extends boolean | null | undefined | MCPRequestDefaultArgs> = $Result.GetResult<Prisma.$MCPRequestPayload, S>

  type MCPRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MCPRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MCPRequestCountAggregateInputType | true
    }

  export interface MCPRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCPRequest'], meta: { name: 'MCPRequest' } }
    /**
     * Find zero or one MCPRequest that matches the filter.
     * @param {MCPRequestFindUniqueArgs} args - Arguments to find a MCPRequest
     * @example
     * // Get one MCPRequest
     * const mCPRequest = await prisma.mCPRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MCPRequestFindUniqueArgs>(args: SelectSubset<T, MCPRequestFindUniqueArgs<ExtArgs>>): Prisma__MCPRequestClient<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MCPRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MCPRequestFindUniqueOrThrowArgs} args - Arguments to find a MCPRequest
     * @example
     * // Get one MCPRequest
     * const mCPRequest = await prisma.mCPRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MCPRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MCPRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MCPRequestClient<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MCPRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPRequestFindFirstArgs} args - Arguments to find a MCPRequest
     * @example
     * // Get one MCPRequest
     * const mCPRequest = await prisma.mCPRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MCPRequestFindFirstArgs>(args?: SelectSubset<T, MCPRequestFindFirstArgs<ExtArgs>>): Prisma__MCPRequestClient<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MCPRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPRequestFindFirstOrThrowArgs} args - Arguments to find a MCPRequest
     * @example
     * // Get one MCPRequest
     * const mCPRequest = await prisma.mCPRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MCPRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MCPRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MCPRequestClient<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MCPRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCPRequests
     * const mCPRequests = await prisma.mCPRequest.findMany()
     * 
     * // Get first 10 MCPRequests
     * const mCPRequests = await prisma.mCPRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mCPRequestWithIdOnly = await prisma.mCPRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MCPRequestFindManyArgs>(args?: SelectSubset<T, MCPRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MCPRequest.
     * @param {MCPRequestCreateArgs} args - Arguments to create a MCPRequest.
     * @example
     * // Create one MCPRequest
     * const MCPRequest = await prisma.mCPRequest.create({
     *   data: {
     *     // ... data to create a MCPRequest
     *   }
     * })
     * 
     */
    create<T extends MCPRequestCreateArgs>(args: SelectSubset<T, MCPRequestCreateArgs<ExtArgs>>): Prisma__MCPRequestClient<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MCPRequests.
     * @param {MCPRequestCreateManyArgs} args - Arguments to create many MCPRequests.
     * @example
     * // Create many MCPRequests
     * const mCPRequest = await prisma.mCPRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MCPRequestCreateManyArgs>(args?: SelectSubset<T, MCPRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MCPRequests and returns the data saved in the database.
     * @param {MCPRequestCreateManyAndReturnArgs} args - Arguments to create many MCPRequests.
     * @example
     * // Create many MCPRequests
     * const mCPRequest = await prisma.mCPRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MCPRequests and only return the `id`
     * const mCPRequestWithIdOnly = await prisma.mCPRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MCPRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MCPRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MCPRequest.
     * @param {MCPRequestDeleteArgs} args - Arguments to delete one MCPRequest.
     * @example
     * // Delete one MCPRequest
     * const MCPRequest = await prisma.mCPRequest.delete({
     *   where: {
     *     // ... filter to delete one MCPRequest
     *   }
     * })
     * 
     */
    delete<T extends MCPRequestDeleteArgs>(args: SelectSubset<T, MCPRequestDeleteArgs<ExtArgs>>): Prisma__MCPRequestClient<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MCPRequest.
     * @param {MCPRequestUpdateArgs} args - Arguments to update one MCPRequest.
     * @example
     * // Update one MCPRequest
     * const mCPRequest = await prisma.mCPRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MCPRequestUpdateArgs>(args: SelectSubset<T, MCPRequestUpdateArgs<ExtArgs>>): Prisma__MCPRequestClient<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MCPRequests.
     * @param {MCPRequestDeleteManyArgs} args - Arguments to filter MCPRequests to delete.
     * @example
     * // Delete a few MCPRequests
     * const { count } = await prisma.mCPRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MCPRequestDeleteManyArgs>(args?: SelectSubset<T, MCPRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCPRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCPRequests
     * const mCPRequest = await prisma.mCPRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MCPRequestUpdateManyArgs>(args: SelectSubset<T, MCPRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCPRequests and returns the data updated in the database.
     * @param {MCPRequestUpdateManyAndReturnArgs} args - Arguments to update many MCPRequests.
     * @example
     * // Update many MCPRequests
     * const mCPRequest = await prisma.mCPRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MCPRequests and only return the `id`
     * const mCPRequestWithIdOnly = await prisma.mCPRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MCPRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, MCPRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MCPRequest.
     * @param {MCPRequestUpsertArgs} args - Arguments to update or create a MCPRequest.
     * @example
     * // Update or create a MCPRequest
     * const mCPRequest = await prisma.mCPRequest.upsert({
     *   create: {
     *     // ... data to create a MCPRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCPRequest we want to update
     *   }
     * })
     */
    upsert<T extends MCPRequestUpsertArgs>(args: SelectSubset<T, MCPRequestUpsertArgs<ExtArgs>>): Prisma__MCPRequestClient<$Result.GetResult<Prisma.$MCPRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MCPRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPRequestCountArgs} args - Arguments to filter MCPRequests to count.
     * @example
     * // Count the number of MCPRequests
     * const count = await prisma.mCPRequest.count({
     *   where: {
     *     // ... the filter for the MCPRequests we want to count
     *   }
     * })
    **/
    count<T extends MCPRequestCountArgs>(
      args?: Subset<T, MCPRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCPRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCPRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCPRequestAggregateArgs>(args: Subset<T, MCPRequestAggregateArgs>): Prisma.PrismaPromise<GetMCPRequestAggregateType<T>>

    /**
     * Group by MCPRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCPRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCPRequestGroupByArgs['orderBy'] }
        : { orderBy?: MCPRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCPRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCPRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCPRequest model
   */
  readonly fields: MCPRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCPRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MCPRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MCPRequest model
   */
  interface MCPRequestFieldRefs {
    readonly id: FieldRef<"MCPRequest", 'String'>
    readonly tool: FieldRef<"MCPRequest", 'String'>
    readonly request: FieldRef<"MCPRequest", 'Json'>
    readonly response: FieldRef<"MCPRequest", 'Json'>
    readonly status: FieldRef<"MCPRequest", 'String'>
    readonly processingTime: FieldRef<"MCPRequest", 'Int'>
    readonly error: FieldRef<"MCPRequest", 'String'>
    readonly createdAt: FieldRef<"MCPRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MCPRequest findUnique
   */
  export type MCPRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * Filter, which MCPRequest to fetch.
     */
    where: MCPRequestWhereUniqueInput
  }

  /**
   * MCPRequest findUniqueOrThrow
   */
  export type MCPRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * Filter, which MCPRequest to fetch.
     */
    where: MCPRequestWhereUniqueInput
  }

  /**
   * MCPRequest findFirst
   */
  export type MCPRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * Filter, which MCPRequest to fetch.
     */
    where?: MCPRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPRequests to fetch.
     */
    orderBy?: MCPRequestOrderByWithRelationInput | MCPRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCPRequests.
     */
    cursor?: MCPRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCPRequests.
     */
    distinct?: MCPRequestScalarFieldEnum | MCPRequestScalarFieldEnum[]
  }

  /**
   * MCPRequest findFirstOrThrow
   */
  export type MCPRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * Filter, which MCPRequest to fetch.
     */
    where?: MCPRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPRequests to fetch.
     */
    orderBy?: MCPRequestOrderByWithRelationInput | MCPRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCPRequests.
     */
    cursor?: MCPRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCPRequests.
     */
    distinct?: MCPRequestScalarFieldEnum | MCPRequestScalarFieldEnum[]
  }

  /**
   * MCPRequest findMany
   */
  export type MCPRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * Filter, which MCPRequests to fetch.
     */
    where?: MCPRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPRequests to fetch.
     */
    orderBy?: MCPRequestOrderByWithRelationInput | MCPRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCPRequests.
     */
    cursor?: MCPRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPRequests.
     */
    skip?: number
    distinct?: MCPRequestScalarFieldEnum | MCPRequestScalarFieldEnum[]
  }

  /**
   * MCPRequest create
   */
  export type MCPRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a MCPRequest.
     */
    data: XOR<MCPRequestCreateInput, MCPRequestUncheckedCreateInput>
  }

  /**
   * MCPRequest createMany
   */
  export type MCPRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCPRequests.
     */
    data: MCPRequestCreateManyInput | MCPRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MCPRequest createManyAndReturn
   */
  export type MCPRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * The data used to create many MCPRequests.
     */
    data: MCPRequestCreateManyInput | MCPRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MCPRequest update
   */
  export type MCPRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a MCPRequest.
     */
    data: XOR<MCPRequestUpdateInput, MCPRequestUncheckedUpdateInput>
    /**
     * Choose, which MCPRequest to update.
     */
    where: MCPRequestWhereUniqueInput
  }

  /**
   * MCPRequest updateMany
   */
  export type MCPRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCPRequests.
     */
    data: XOR<MCPRequestUpdateManyMutationInput, MCPRequestUncheckedUpdateManyInput>
    /**
     * Filter which MCPRequests to update
     */
    where?: MCPRequestWhereInput
    /**
     * Limit how many MCPRequests to update.
     */
    limit?: number
  }

  /**
   * MCPRequest updateManyAndReturn
   */
  export type MCPRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * The data used to update MCPRequests.
     */
    data: XOR<MCPRequestUpdateManyMutationInput, MCPRequestUncheckedUpdateManyInput>
    /**
     * Filter which MCPRequests to update
     */
    where?: MCPRequestWhereInput
    /**
     * Limit how many MCPRequests to update.
     */
    limit?: number
  }

  /**
   * MCPRequest upsert
   */
  export type MCPRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the MCPRequest to update in case it exists.
     */
    where: MCPRequestWhereUniqueInput
    /**
     * In case the MCPRequest found by the `where` argument doesn't exist, create a new MCPRequest with this data.
     */
    create: XOR<MCPRequestCreateInput, MCPRequestUncheckedCreateInput>
    /**
     * In case the MCPRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCPRequestUpdateInput, MCPRequestUncheckedUpdateInput>
  }

  /**
   * MCPRequest delete
   */
  export type MCPRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
    /**
     * Filter which MCPRequest to delete.
     */
    where: MCPRequestWhereUniqueInput
  }

  /**
   * MCPRequest deleteMany
   */
  export type MCPRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCPRequests to delete
     */
    where?: MCPRequestWhereInput
    /**
     * Limit how many MCPRequests to delete.
     */
    limit?: number
  }

  /**
   * MCPRequest without action
   */
  export type MCPRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPRequest
     */
    select?: MCPRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MCPRequest
     */
    omit?: MCPRequestOmit<ExtArgs> | null
  }


  /**
   * Model CashLedger
   */

  export type AggregateCashLedger = {
    _count: CashLedgerCountAggregateOutputType | null
    _avg: CashLedgerAvgAggregateOutputType | null
    _sum: CashLedgerSumAggregateOutputType | null
    _min: CashLedgerMinAggregateOutputType | null
    _max: CashLedgerMaxAggregateOutputType | null
  }

  export type CashLedgerAvgAggregateOutputType = {
    amount: number | null
    balance: number | null
  }

  export type CashLedgerSumAggregateOutputType = {
    amount: number | null
    balance: number | null
  }

  export type CashLedgerMinAggregateOutputType = {
    id: string | null
    date: Date | null
    description: string | null
    category: string | null
    subCategory: string | null
    amount: number | null
    balance: number | null
    source: string | null
    sourceId: string | null
    reconciledStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashLedgerMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    description: string | null
    category: string | null
    subCategory: string | null
    amount: number | null
    balance: number | null
    source: string | null
    sourceId: string | null
    reconciledStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashLedgerCountAggregateOutputType = {
    id: number
    date: number
    description: number
    category: number
    subCategory: number
    amount: number
    balance: number
    source: number
    sourceId: number
    reconciledStatus: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashLedgerAvgAggregateInputType = {
    amount?: true
    balance?: true
  }

  export type CashLedgerSumAggregateInputType = {
    amount?: true
    balance?: true
  }

  export type CashLedgerMinAggregateInputType = {
    id?: true
    date?: true
    description?: true
    category?: true
    subCategory?: true
    amount?: true
    balance?: true
    source?: true
    sourceId?: true
    reconciledStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashLedgerMaxAggregateInputType = {
    id?: true
    date?: true
    description?: true
    category?: true
    subCategory?: true
    amount?: true
    balance?: true
    source?: true
    sourceId?: true
    reconciledStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashLedgerCountAggregateInputType = {
    id?: true
    date?: true
    description?: true
    category?: true
    subCategory?: true
    amount?: true
    balance?: true
    source?: true
    sourceId?: true
    reconciledStatus?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashLedger to aggregate.
     */
    where?: CashLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashLedgers to fetch.
     */
    orderBy?: CashLedgerOrderByWithRelationInput | CashLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashLedgers
    **/
    _count?: true | CashLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashLedgerMaxAggregateInputType
  }

  export type GetCashLedgerAggregateType<T extends CashLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateCashLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashLedger[P]>
      : GetScalarType<T[P], AggregateCashLedger[P]>
  }




  export type CashLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashLedgerWhereInput
    orderBy?: CashLedgerOrderByWithAggregationInput | CashLedgerOrderByWithAggregationInput[]
    by: CashLedgerScalarFieldEnum[] | CashLedgerScalarFieldEnum
    having?: CashLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashLedgerCountAggregateInputType | true
    _avg?: CashLedgerAvgAggregateInputType
    _sum?: CashLedgerSumAggregateInputType
    _min?: CashLedgerMinAggregateInputType
    _max?: CashLedgerMaxAggregateInputType
  }

  export type CashLedgerGroupByOutputType = {
    id: string
    date: Date
    description: string
    category: string
    subCategory: string | null
    amount: number
    balance: number
    source: string
    sourceId: string | null
    reconciledStatus: string
    tags: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CashLedgerCountAggregateOutputType | null
    _avg: CashLedgerAvgAggregateOutputType | null
    _sum: CashLedgerSumAggregateOutputType | null
    _min: CashLedgerMinAggregateOutputType | null
    _max: CashLedgerMaxAggregateOutputType | null
  }

  type GetCashLedgerGroupByPayload<T extends CashLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], CashLedgerGroupByOutputType[P]>
        }
      >
    >


  export type CashLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    category?: boolean
    subCategory?: boolean
    amount?: boolean
    balance?: boolean
    source?: boolean
    sourceId?: boolean
    reconciledStatus?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cashLedger"]>

  export type CashLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    category?: boolean
    subCategory?: boolean
    amount?: boolean
    balance?: boolean
    source?: boolean
    sourceId?: boolean
    reconciledStatus?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cashLedger"]>

  export type CashLedgerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    category?: boolean
    subCategory?: boolean
    amount?: boolean
    balance?: boolean
    source?: boolean
    sourceId?: boolean
    reconciledStatus?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cashLedger"]>

  export type CashLedgerSelectScalar = {
    id?: boolean
    date?: boolean
    description?: boolean
    category?: boolean
    subCategory?: boolean
    amount?: boolean
    balance?: boolean
    source?: boolean
    sourceId?: boolean
    reconciledStatus?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashLedgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "description" | "category" | "subCategory" | "amount" | "balance" | "source" | "sourceId" | "reconciledStatus" | "tags" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["cashLedger"]>

  export type $CashLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashLedger"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      description: string
      category: string
      subCategory: string | null
      amount: number
      balance: number
      source: string
      sourceId: string | null
      reconciledStatus: string
      tags: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashLedger"]>
    composites: {}
  }

  type CashLedgerGetPayload<S extends boolean | null | undefined | CashLedgerDefaultArgs> = $Result.GetResult<Prisma.$CashLedgerPayload, S>

  type CashLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashLedgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashLedgerCountAggregateInputType | true
    }

  export interface CashLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashLedger'], meta: { name: 'CashLedger' } }
    /**
     * Find zero or one CashLedger that matches the filter.
     * @param {CashLedgerFindUniqueArgs} args - Arguments to find a CashLedger
     * @example
     * // Get one CashLedger
     * const cashLedger = await prisma.cashLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashLedgerFindUniqueArgs>(args: SelectSubset<T, CashLedgerFindUniqueArgs<ExtArgs>>): Prisma__CashLedgerClient<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashLedger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashLedgerFindUniqueOrThrowArgs} args - Arguments to find a CashLedger
     * @example
     * // Get one CashLedger
     * const cashLedger = await prisma.cashLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, CashLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashLedgerClient<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashLedgerFindFirstArgs} args - Arguments to find a CashLedger
     * @example
     * // Get one CashLedger
     * const cashLedger = await prisma.cashLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashLedgerFindFirstArgs>(args?: SelectSubset<T, CashLedgerFindFirstArgs<ExtArgs>>): Prisma__CashLedgerClient<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashLedgerFindFirstOrThrowArgs} args - Arguments to find a CashLedger
     * @example
     * // Get one CashLedger
     * const cashLedger = await prisma.cashLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, CashLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashLedgerClient<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashLedgers
     * const cashLedgers = await prisma.cashLedger.findMany()
     * 
     * // Get first 10 CashLedgers
     * const cashLedgers = await prisma.cashLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashLedgerWithIdOnly = await prisma.cashLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashLedgerFindManyArgs>(args?: SelectSubset<T, CashLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashLedger.
     * @param {CashLedgerCreateArgs} args - Arguments to create a CashLedger.
     * @example
     * // Create one CashLedger
     * const CashLedger = await prisma.cashLedger.create({
     *   data: {
     *     // ... data to create a CashLedger
     *   }
     * })
     * 
     */
    create<T extends CashLedgerCreateArgs>(args: SelectSubset<T, CashLedgerCreateArgs<ExtArgs>>): Prisma__CashLedgerClient<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashLedgers.
     * @param {CashLedgerCreateManyArgs} args - Arguments to create many CashLedgers.
     * @example
     * // Create many CashLedgers
     * const cashLedger = await prisma.cashLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashLedgerCreateManyArgs>(args?: SelectSubset<T, CashLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashLedgers and returns the data saved in the database.
     * @param {CashLedgerCreateManyAndReturnArgs} args - Arguments to create many CashLedgers.
     * @example
     * // Create many CashLedgers
     * const cashLedger = await prisma.cashLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashLedgers and only return the `id`
     * const cashLedgerWithIdOnly = await prisma.cashLedger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, CashLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashLedger.
     * @param {CashLedgerDeleteArgs} args - Arguments to delete one CashLedger.
     * @example
     * // Delete one CashLedger
     * const CashLedger = await prisma.cashLedger.delete({
     *   where: {
     *     // ... filter to delete one CashLedger
     *   }
     * })
     * 
     */
    delete<T extends CashLedgerDeleteArgs>(args: SelectSubset<T, CashLedgerDeleteArgs<ExtArgs>>): Prisma__CashLedgerClient<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashLedger.
     * @param {CashLedgerUpdateArgs} args - Arguments to update one CashLedger.
     * @example
     * // Update one CashLedger
     * const cashLedger = await prisma.cashLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashLedgerUpdateArgs>(args: SelectSubset<T, CashLedgerUpdateArgs<ExtArgs>>): Prisma__CashLedgerClient<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashLedgers.
     * @param {CashLedgerDeleteManyArgs} args - Arguments to filter CashLedgers to delete.
     * @example
     * // Delete a few CashLedgers
     * const { count } = await prisma.cashLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashLedgerDeleteManyArgs>(args?: SelectSubset<T, CashLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashLedgers
     * const cashLedger = await prisma.cashLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashLedgerUpdateManyArgs>(args: SelectSubset<T, CashLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashLedgers and returns the data updated in the database.
     * @param {CashLedgerUpdateManyAndReturnArgs} args - Arguments to update many CashLedgers.
     * @example
     * // Update many CashLedgers
     * const cashLedger = await prisma.cashLedger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashLedgers and only return the `id`
     * const cashLedgerWithIdOnly = await prisma.cashLedger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashLedgerUpdateManyAndReturnArgs>(args: SelectSubset<T, CashLedgerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashLedger.
     * @param {CashLedgerUpsertArgs} args - Arguments to update or create a CashLedger.
     * @example
     * // Update or create a CashLedger
     * const cashLedger = await prisma.cashLedger.upsert({
     *   create: {
     *     // ... data to create a CashLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashLedger we want to update
     *   }
     * })
     */
    upsert<T extends CashLedgerUpsertArgs>(args: SelectSubset<T, CashLedgerUpsertArgs<ExtArgs>>): Prisma__CashLedgerClient<$Result.GetResult<Prisma.$CashLedgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashLedgerCountArgs} args - Arguments to filter CashLedgers to count.
     * @example
     * // Count the number of CashLedgers
     * const count = await prisma.cashLedger.count({
     *   where: {
     *     // ... the filter for the CashLedgers we want to count
     *   }
     * })
    **/
    count<T extends CashLedgerCountArgs>(
      args?: Subset<T, CashLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashLedgerAggregateArgs>(args: Subset<T, CashLedgerAggregateArgs>): Prisma.PrismaPromise<GetCashLedgerAggregateType<T>>

    /**
     * Group by CashLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashLedgerGroupByArgs['orderBy'] }
        : { orderBy?: CashLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashLedger model
   */
  readonly fields: CashLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashLedger model
   */
  interface CashLedgerFieldRefs {
    readonly id: FieldRef<"CashLedger", 'String'>
    readonly date: FieldRef<"CashLedger", 'DateTime'>
    readonly description: FieldRef<"CashLedger", 'String'>
    readonly category: FieldRef<"CashLedger", 'String'>
    readonly subCategory: FieldRef<"CashLedger", 'String'>
    readonly amount: FieldRef<"CashLedger", 'Float'>
    readonly balance: FieldRef<"CashLedger", 'Float'>
    readonly source: FieldRef<"CashLedger", 'String'>
    readonly sourceId: FieldRef<"CashLedger", 'String'>
    readonly reconciledStatus: FieldRef<"CashLedger", 'String'>
    readonly tags: FieldRef<"CashLedger", 'String[]'>
    readonly metadata: FieldRef<"CashLedger", 'Json'>
    readonly createdAt: FieldRef<"CashLedger", 'DateTime'>
    readonly updatedAt: FieldRef<"CashLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashLedger findUnique
   */
  export type CashLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * Filter, which CashLedger to fetch.
     */
    where: CashLedgerWhereUniqueInput
  }

  /**
   * CashLedger findUniqueOrThrow
   */
  export type CashLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * Filter, which CashLedger to fetch.
     */
    where: CashLedgerWhereUniqueInput
  }

  /**
   * CashLedger findFirst
   */
  export type CashLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * Filter, which CashLedger to fetch.
     */
    where?: CashLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashLedgers to fetch.
     */
    orderBy?: CashLedgerOrderByWithRelationInput | CashLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashLedgers.
     */
    cursor?: CashLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashLedgers.
     */
    distinct?: CashLedgerScalarFieldEnum | CashLedgerScalarFieldEnum[]
  }

  /**
   * CashLedger findFirstOrThrow
   */
  export type CashLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * Filter, which CashLedger to fetch.
     */
    where?: CashLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashLedgers to fetch.
     */
    orderBy?: CashLedgerOrderByWithRelationInput | CashLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashLedgers.
     */
    cursor?: CashLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashLedgers.
     */
    distinct?: CashLedgerScalarFieldEnum | CashLedgerScalarFieldEnum[]
  }

  /**
   * CashLedger findMany
   */
  export type CashLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * Filter, which CashLedgers to fetch.
     */
    where?: CashLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashLedgers to fetch.
     */
    orderBy?: CashLedgerOrderByWithRelationInput | CashLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashLedgers.
     */
    cursor?: CashLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashLedgers.
     */
    skip?: number
    distinct?: CashLedgerScalarFieldEnum | CashLedgerScalarFieldEnum[]
  }

  /**
   * CashLedger create
   */
  export type CashLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * The data needed to create a CashLedger.
     */
    data: XOR<CashLedgerCreateInput, CashLedgerUncheckedCreateInput>
  }

  /**
   * CashLedger createMany
   */
  export type CashLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashLedgers.
     */
    data: CashLedgerCreateManyInput | CashLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashLedger createManyAndReturn
   */
  export type CashLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * The data used to create many CashLedgers.
     */
    data: CashLedgerCreateManyInput | CashLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashLedger update
   */
  export type CashLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * The data needed to update a CashLedger.
     */
    data: XOR<CashLedgerUpdateInput, CashLedgerUncheckedUpdateInput>
    /**
     * Choose, which CashLedger to update.
     */
    where: CashLedgerWhereUniqueInput
  }

  /**
   * CashLedger updateMany
   */
  export type CashLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashLedgers.
     */
    data: XOR<CashLedgerUpdateManyMutationInput, CashLedgerUncheckedUpdateManyInput>
    /**
     * Filter which CashLedgers to update
     */
    where?: CashLedgerWhereInput
    /**
     * Limit how many CashLedgers to update.
     */
    limit?: number
  }

  /**
   * CashLedger updateManyAndReturn
   */
  export type CashLedgerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * The data used to update CashLedgers.
     */
    data: XOR<CashLedgerUpdateManyMutationInput, CashLedgerUncheckedUpdateManyInput>
    /**
     * Filter which CashLedgers to update
     */
    where?: CashLedgerWhereInput
    /**
     * Limit how many CashLedgers to update.
     */
    limit?: number
  }

  /**
   * CashLedger upsert
   */
  export type CashLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * The filter to search for the CashLedger to update in case it exists.
     */
    where: CashLedgerWhereUniqueInput
    /**
     * In case the CashLedger found by the `where` argument doesn't exist, create a new CashLedger with this data.
     */
    create: XOR<CashLedgerCreateInput, CashLedgerUncheckedCreateInput>
    /**
     * In case the CashLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashLedgerUpdateInput, CashLedgerUncheckedUpdateInput>
  }

  /**
   * CashLedger delete
   */
  export type CashLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
    /**
     * Filter which CashLedger to delete.
     */
    where: CashLedgerWhereUniqueInput
  }

  /**
   * CashLedger deleteMany
   */
  export type CashLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashLedgers to delete
     */
    where?: CashLedgerWhereInput
    /**
     * Limit how many CashLedgers to delete.
     */
    limit?: number
  }

  /**
   * CashLedger without action
   */
  export type CashLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashLedger
     */
    select?: CashLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashLedger
     */
    omit?: CashLedgerOmit<ExtArgs> | null
  }


  /**
   * Model CashProjection
   */

  export type AggregateCashProjection = {
    _count: CashProjectionCountAggregateOutputType | null
    _avg: CashProjectionAvgAggregateOutputType | null
    _sum: CashProjectionSumAggregateOutputType | null
    _min: CashProjectionMinAggregateOutputType | null
    _max: CashProjectionMaxAggregateOutputType | null
  }

  export type CashProjectionAvgAggregateOutputType = {
    projectedAmount: number | null
    actualAmount: number | null
    variance: number | null
    confidenceLevel: number | null
  }

  export type CashProjectionSumAggregateOutputType = {
    projectedAmount: number | null
    actualAmount: number | null
    variance: number | null
    confidenceLevel: number | null
  }

  export type CashProjectionMinAggregateOutputType = {
    id: string | null
    projectionDate: Date | null
    projectedAmount: number | null
    actualAmount: number | null
    variance: number | null
    confidenceLevel: number | null
    scenarioType: string | null
    projectionMethod: string | null
    dataSource: string | null
    isAdjusted: boolean | null
    adjustmentReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashProjectionMaxAggregateOutputType = {
    id: string | null
    projectionDate: Date | null
    projectedAmount: number | null
    actualAmount: number | null
    variance: number | null
    confidenceLevel: number | null
    scenarioType: string | null
    projectionMethod: string | null
    dataSource: string | null
    isAdjusted: boolean | null
    adjustmentReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashProjectionCountAggregateOutputType = {
    id: number
    projectionDate: number
    projectedAmount: number
    actualAmount: number
    variance: number
    confidenceLevel: number
    scenarioType: number
    assumptions: number
    projectionMethod: number
    dataSource: number
    isAdjusted: number
    adjustmentReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashProjectionAvgAggregateInputType = {
    projectedAmount?: true
    actualAmount?: true
    variance?: true
    confidenceLevel?: true
  }

  export type CashProjectionSumAggregateInputType = {
    projectedAmount?: true
    actualAmount?: true
    variance?: true
    confidenceLevel?: true
  }

  export type CashProjectionMinAggregateInputType = {
    id?: true
    projectionDate?: true
    projectedAmount?: true
    actualAmount?: true
    variance?: true
    confidenceLevel?: true
    scenarioType?: true
    projectionMethod?: true
    dataSource?: true
    isAdjusted?: true
    adjustmentReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashProjectionMaxAggregateInputType = {
    id?: true
    projectionDate?: true
    projectedAmount?: true
    actualAmount?: true
    variance?: true
    confidenceLevel?: true
    scenarioType?: true
    projectionMethod?: true
    dataSource?: true
    isAdjusted?: true
    adjustmentReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashProjectionCountAggregateInputType = {
    id?: true
    projectionDate?: true
    projectedAmount?: true
    actualAmount?: true
    variance?: true
    confidenceLevel?: true
    scenarioType?: true
    assumptions?: true
    projectionMethod?: true
    dataSource?: true
    isAdjusted?: true
    adjustmentReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashProjectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashProjection to aggregate.
     */
    where?: CashProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashProjections to fetch.
     */
    orderBy?: CashProjectionOrderByWithRelationInput | CashProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashProjections
    **/
    _count?: true | CashProjectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashProjectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashProjectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashProjectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashProjectionMaxAggregateInputType
  }

  export type GetCashProjectionAggregateType<T extends CashProjectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCashProjection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashProjection[P]>
      : GetScalarType<T[P], AggregateCashProjection[P]>
  }




  export type CashProjectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashProjectionWhereInput
    orderBy?: CashProjectionOrderByWithAggregationInput | CashProjectionOrderByWithAggregationInput[]
    by: CashProjectionScalarFieldEnum[] | CashProjectionScalarFieldEnum
    having?: CashProjectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashProjectionCountAggregateInputType | true
    _avg?: CashProjectionAvgAggregateInputType
    _sum?: CashProjectionSumAggregateInputType
    _min?: CashProjectionMinAggregateInputType
    _max?: CashProjectionMaxAggregateInputType
  }

  export type CashProjectionGroupByOutputType = {
    id: string
    projectionDate: Date
    projectedAmount: number
    actualAmount: number | null
    variance: number | null
    confidenceLevel: number
    scenarioType: string
    assumptions: JsonValue
    projectionMethod: string
    dataSource: string
    isAdjusted: boolean
    adjustmentReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: CashProjectionCountAggregateOutputType | null
    _avg: CashProjectionAvgAggregateOutputType | null
    _sum: CashProjectionSumAggregateOutputType | null
    _min: CashProjectionMinAggregateOutputType | null
    _max: CashProjectionMaxAggregateOutputType | null
  }

  type GetCashProjectionGroupByPayload<T extends CashProjectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashProjectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashProjectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashProjectionGroupByOutputType[P]>
            : GetScalarType<T[P], CashProjectionGroupByOutputType[P]>
        }
      >
    >


  export type CashProjectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectionDate?: boolean
    projectedAmount?: boolean
    actualAmount?: boolean
    variance?: boolean
    confidenceLevel?: boolean
    scenarioType?: boolean
    assumptions?: boolean
    projectionMethod?: boolean
    dataSource?: boolean
    isAdjusted?: boolean
    adjustmentReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cashProjection"]>

  export type CashProjectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectionDate?: boolean
    projectedAmount?: boolean
    actualAmount?: boolean
    variance?: boolean
    confidenceLevel?: boolean
    scenarioType?: boolean
    assumptions?: boolean
    projectionMethod?: boolean
    dataSource?: boolean
    isAdjusted?: boolean
    adjustmentReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cashProjection"]>

  export type CashProjectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectionDate?: boolean
    projectedAmount?: boolean
    actualAmount?: boolean
    variance?: boolean
    confidenceLevel?: boolean
    scenarioType?: boolean
    assumptions?: boolean
    projectionMethod?: boolean
    dataSource?: boolean
    isAdjusted?: boolean
    adjustmentReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cashProjection"]>

  export type CashProjectionSelectScalar = {
    id?: boolean
    projectionDate?: boolean
    projectedAmount?: boolean
    actualAmount?: boolean
    variance?: boolean
    confidenceLevel?: boolean
    scenarioType?: boolean
    assumptions?: boolean
    projectionMethod?: boolean
    dataSource?: boolean
    isAdjusted?: boolean
    adjustmentReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashProjectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectionDate" | "projectedAmount" | "actualAmount" | "variance" | "confidenceLevel" | "scenarioType" | "assumptions" | "projectionMethod" | "dataSource" | "isAdjusted" | "adjustmentReason" | "createdAt" | "updatedAt", ExtArgs["result"]["cashProjection"]>

  export type $CashProjectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashProjection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectionDate: Date
      projectedAmount: number
      actualAmount: number | null
      variance: number | null
      confidenceLevel: number
      scenarioType: string
      assumptions: Prisma.JsonValue
      projectionMethod: string
      dataSource: string
      isAdjusted: boolean
      adjustmentReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashProjection"]>
    composites: {}
  }

  type CashProjectionGetPayload<S extends boolean | null | undefined | CashProjectionDefaultArgs> = $Result.GetResult<Prisma.$CashProjectionPayload, S>

  type CashProjectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashProjectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashProjectionCountAggregateInputType | true
    }

  export interface CashProjectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashProjection'], meta: { name: 'CashProjection' } }
    /**
     * Find zero or one CashProjection that matches the filter.
     * @param {CashProjectionFindUniqueArgs} args - Arguments to find a CashProjection
     * @example
     * // Get one CashProjection
     * const cashProjection = await prisma.cashProjection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashProjectionFindUniqueArgs>(args: SelectSubset<T, CashProjectionFindUniqueArgs<ExtArgs>>): Prisma__CashProjectionClient<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashProjection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashProjectionFindUniqueOrThrowArgs} args - Arguments to find a CashProjection
     * @example
     * // Get one CashProjection
     * const cashProjection = await prisma.cashProjection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashProjectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CashProjectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashProjectionClient<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashProjection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashProjectionFindFirstArgs} args - Arguments to find a CashProjection
     * @example
     * // Get one CashProjection
     * const cashProjection = await prisma.cashProjection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashProjectionFindFirstArgs>(args?: SelectSubset<T, CashProjectionFindFirstArgs<ExtArgs>>): Prisma__CashProjectionClient<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashProjection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashProjectionFindFirstOrThrowArgs} args - Arguments to find a CashProjection
     * @example
     * // Get one CashProjection
     * const cashProjection = await prisma.cashProjection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashProjectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CashProjectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashProjectionClient<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashProjections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashProjectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashProjections
     * const cashProjections = await prisma.cashProjection.findMany()
     * 
     * // Get first 10 CashProjections
     * const cashProjections = await prisma.cashProjection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashProjectionWithIdOnly = await prisma.cashProjection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashProjectionFindManyArgs>(args?: SelectSubset<T, CashProjectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashProjection.
     * @param {CashProjectionCreateArgs} args - Arguments to create a CashProjection.
     * @example
     * // Create one CashProjection
     * const CashProjection = await prisma.cashProjection.create({
     *   data: {
     *     // ... data to create a CashProjection
     *   }
     * })
     * 
     */
    create<T extends CashProjectionCreateArgs>(args: SelectSubset<T, CashProjectionCreateArgs<ExtArgs>>): Prisma__CashProjectionClient<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashProjections.
     * @param {CashProjectionCreateManyArgs} args - Arguments to create many CashProjections.
     * @example
     * // Create many CashProjections
     * const cashProjection = await prisma.cashProjection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashProjectionCreateManyArgs>(args?: SelectSubset<T, CashProjectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashProjections and returns the data saved in the database.
     * @param {CashProjectionCreateManyAndReturnArgs} args - Arguments to create many CashProjections.
     * @example
     * // Create many CashProjections
     * const cashProjection = await prisma.cashProjection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashProjections and only return the `id`
     * const cashProjectionWithIdOnly = await prisma.cashProjection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashProjectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CashProjectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashProjection.
     * @param {CashProjectionDeleteArgs} args - Arguments to delete one CashProjection.
     * @example
     * // Delete one CashProjection
     * const CashProjection = await prisma.cashProjection.delete({
     *   where: {
     *     // ... filter to delete one CashProjection
     *   }
     * })
     * 
     */
    delete<T extends CashProjectionDeleteArgs>(args: SelectSubset<T, CashProjectionDeleteArgs<ExtArgs>>): Prisma__CashProjectionClient<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashProjection.
     * @param {CashProjectionUpdateArgs} args - Arguments to update one CashProjection.
     * @example
     * // Update one CashProjection
     * const cashProjection = await prisma.cashProjection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashProjectionUpdateArgs>(args: SelectSubset<T, CashProjectionUpdateArgs<ExtArgs>>): Prisma__CashProjectionClient<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashProjections.
     * @param {CashProjectionDeleteManyArgs} args - Arguments to filter CashProjections to delete.
     * @example
     * // Delete a few CashProjections
     * const { count } = await prisma.cashProjection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashProjectionDeleteManyArgs>(args?: SelectSubset<T, CashProjectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashProjectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashProjections
     * const cashProjection = await prisma.cashProjection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashProjectionUpdateManyArgs>(args: SelectSubset<T, CashProjectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashProjections and returns the data updated in the database.
     * @param {CashProjectionUpdateManyAndReturnArgs} args - Arguments to update many CashProjections.
     * @example
     * // Update many CashProjections
     * const cashProjection = await prisma.cashProjection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashProjections and only return the `id`
     * const cashProjectionWithIdOnly = await prisma.cashProjection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashProjectionUpdateManyAndReturnArgs>(args: SelectSubset<T, CashProjectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashProjection.
     * @param {CashProjectionUpsertArgs} args - Arguments to update or create a CashProjection.
     * @example
     * // Update or create a CashProjection
     * const cashProjection = await prisma.cashProjection.upsert({
     *   create: {
     *     // ... data to create a CashProjection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashProjection we want to update
     *   }
     * })
     */
    upsert<T extends CashProjectionUpsertArgs>(args: SelectSubset<T, CashProjectionUpsertArgs<ExtArgs>>): Prisma__CashProjectionClient<$Result.GetResult<Prisma.$CashProjectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashProjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashProjectionCountArgs} args - Arguments to filter CashProjections to count.
     * @example
     * // Count the number of CashProjections
     * const count = await prisma.cashProjection.count({
     *   where: {
     *     // ... the filter for the CashProjections we want to count
     *   }
     * })
    **/
    count<T extends CashProjectionCountArgs>(
      args?: Subset<T, CashProjectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashProjectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashProjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashProjectionAggregateArgs>(args: Subset<T, CashProjectionAggregateArgs>): Prisma.PrismaPromise<GetCashProjectionAggregateType<T>>

    /**
     * Group by CashProjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashProjectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashProjectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashProjectionGroupByArgs['orderBy'] }
        : { orderBy?: CashProjectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashProjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashProjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashProjection model
   */
  readonly fields: CashProjectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashProjection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashProjectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashProjection model
   */
  interface CashProjectionFieldRefs {
    readonly id: FieldRef<"CashProjection", 'String'>
    readonly projectionDate: FieldRef<"CashProjection", 'DateTime'>
    readonly projectedAmount: FieldRef<"CashProjection", 'Float'>
    readonly actualAmount: FieldRef<"CashProjection", 'Float'>
    readonly variance: FieldRef<"CashProjection", 'Float'>
    readonly confidenceLevel: FieldRef<"CashProjection", 'Float'>
    readonly scenarioType: FieldRef<"CashProjection", 'String'>
    readonly assumptions: FieldRef<"CashProjection", 'Json'>
    readonly projectionMethod: FieldRef<"CashProjection", 'String'>
    readonly dataSource: FieldRef<"CashProjection", 'String'>
    readonly isAdjusted: FieldRef<"CashProjection", 'Boolean'>
    readonly adjustmentReason: FieldRef<"CashProjection", 'String'>
    readonly createdAt: FieldRef<"CashProjection", 'DateTime'>
    readonly updatedAt: FieldRef<"CashProjection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashProjection findUnique
   */
  export type CashProjectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * Filter, which CashProjection to fetch.
     */
    where: CashProjectionWhereUniqueInput
  }

  /**
   * CashProjection findUniqueOrThrow
   */
  export type CashProjectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * Filter, which CashProjection to fetch.
     */
    where: CashProjectionWhereUniqueInput
  }

  /**
   * CashProjection findFirst
   */
  export type CashProjectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * Filter, which CashProjection to fetch.
     */
    where?: CashProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashProjections to fetch.
     */
    orderBy?: CashProjectionOrderByWithRelationInput | CashProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashProjections.
     */
    cursor?: CashProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashProjections.
     */
    distinct?: CashProjectionScalarFieldEnum | CashProjectionScalarFieldEnum[]
  }

  /**
   * CashProjection findFirstOrThrow
   */
  export type CashProjectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * Filter, which CashProjection to fetch.
     */
    where?: CashProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashProjections to fetch.
     */
    orderBy?: CashProjectionOrderByWithRelationInput | CashProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashProjections.
     */
    cursor?: CashProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashProjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashProjections.
     */
    distinct?: CashProjectionScalarFieldEnum | CashProjectionScalarFieldEnum[]
  }

  /**
   * CashProjection findMany
   */
  export type CashProjectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * Filter, which CashProjections to fetch.
     */
    where?: CashProjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashProjections to fetch.
     */
    orderBy?: CashProjectionOrderByWithRelationInput | CashProjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashProjections.
     */
    cursor?: CashProjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashProjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashProjections.
     */
    skip?: number
    distinct?: CashProjectionScalarFieldEnum | CashProjectionScalarFieldEnum[]
  }

  /**
   * CashProjection create
   */
  export type CashProjectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * The data needed to create a CashProjection.
     */
    data: XOR<CashProjectionCreateInput, CashProjectionUncheckedCreateInput>
  }

  /**
   * CashProjection createMany
   */
  export type CashProjectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashProjections.
     */
    data: CashProjectionCreateManyInput | CashProjectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashProjection createManyAndReturn
   */
  export type CashProjectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * The data used to create many CashProjections.
     */
    data: CashProjectionCreateManyInput | CashProjectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashProjection update
   */
  export type CashProjectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * The data needed to update a CashProjection.
     */
    data: XOR<CashProjectionUpdateInput, CashProjectionUncheckedUpdateInput>
    /**
     * Choose, which CashProjection to update.
     */
    where: CashProjectionWhereUniqueInput
  }

  /**
   * CashProjection updateMany
   */
  export type CashProjectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashProjections.
     */
    data: XOR<CashProjectionUpdateManyMutationInput, CashProjectionUncheckedUpdateManyInput>
    /**
     * Filter which CashProjections to update
     */
    where?: CashProjectionWhereInput
    /**
     * Limit how many CashProjections to update.
     */
    limit?: number
  }

  /**
   * CashProjection updateManyAndReturn
   */
  export type CashProjectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * The data used to update CashProjections.
     */
    data: XOR<CashProjectionUpdateManyMutationInput, CashProjectionUncheckedUpdateManyInput>
    /**
     * Filter which CashProjections to update
     */
    where?: CashProjectionWhereInput
    /**
     * Limit how many CashProjections to update.
     */
    limit?: number
  }

  /**
   * CashProjection upsert
   */
  export type CashProjectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * The filter to search for the CashProjection to update in case it exists.
     */
    where: CashProjectionWhereUniqueInput
    /**
     * In case the CashProjection found by the `where` argument doesn't exist, create a new CashProjection with this data.
     */
    create: XOR<CashProjectionCreateInput, CashProjectionUncheckedCreateInput>
    /**
     * In case the CashProjection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashProjectionUpdateInput, CashProjectionUncheckedUpdateInput>
  }

  /**
   * CashProjection delete
   */
  export type CashProjectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
    /**
     * Filter which CashProjection to delete.
     */
    where: CashProjectionWhereUniqueInput
  }

  /**
   * CashProjection deleteMany
   */
  export type CashProjectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashProjections to delete
     */
    where?: CashProjectionWhereInput
    /**
     * Limit how many CashProjections to delete.
     */
    limit?: number
  }

  /**
   * CashProjection without action
   */
  export type CashProjectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashProjection
     */
    select?: CashProjectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashProjection
     */
    omit?: CashProjectionOmit<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
    taxAmount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
    taxAmount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    date: Date | null
    vendor: string | null
    category: string | null
    subCategory: string | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    invoiceNumber: string | null
    approvedBy: string | null
    department: string | null
    project: string | null
    isRecurring: boolean | null
    recurringPeriod: string | null
    taxAmount: number | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    vendor: string | null
    category: string | null
    subCategory: string | null
    amount: number | null
    currency: string | null
    paymentMethod: string | null
    invoiceNumber: string | null
    approvedBy: string | null
    department: string | null
    project: string | null
    isRecurring: boolean | null
    recurringPeriod: string | null
    taxAmount: number | null
    notes: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    date: number
    vendor: number
    category: number
    subCategory: number
    amount: number
    currency: number
    paymentMethod: number
    invoiceNumber: number
    approvedBy: number
    department: number
    project: number
    isRecurring: number
    recurringPeriod: number
    taxAmount: number
    tags: number
    attachments: number
    notes: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
    taxAmount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
    taxAmount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    date?: true
    vendor?: true
    category?: true
    subCategory?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    invoiceNumber?: true
    approvedBy?: true
    department?: true
    project?: true
    isRecurring?: true
    recurringPeriod?: true
    taxAmount?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    date?: true
    vendor?: true
    category?: true
    subCategory?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    invoiceNumber?: true
    approvedBy?: true
    department?: true
    project?: true
    isRecurring?: true
    recurringPeriod?: true
    taxAmount?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    date?: true
    vendor?: true
    category?: true
    subCategory?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    invoiceNumber?: true
    approvedBy?: true
    department?: true
    project?: true
    isRecurring?: true
    recurringPeriod?: true
    taxAmount?: true
    tags?: true
    attachments?: true
    notes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    date: Date
    vendor: string
    category: string
    subCategory: string | null
    amount: number
    currency: string
    paymentMethod: string
    invoiceNumber: string | null
    approvedBy: string | null
    department: string | null
    project: string | null
    isRecurring: boolean
    recurringPeriod: string | null
    taxAmount: number | null
    tags: string[]
    attachments: string[]
    notes: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    vendor?: boolean
    category?: boolean
    subCategory?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    invoiceNumber?: boolean
    approvedBy?: boolean
    department?: boolean
    project?: boolean
    isRecurring?: boolean
    recurringPeriod?: boolean
    taxAmount?: boolean
    tags?: boolean
    attachments?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    vendor?: boolean
    category?: boolean
    subCategory?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    invoiceNumber?: boolean
    approvedBy?: boolean
    department?: boolean
    project?: boolean
    isRecurring?: boolean
    recurringPeriod?: boolean
    taxAmount?: boolean
    tags?: boolean
    attachments?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    vendor?: boolean
    category?: boolean
    subCategory?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    invoiceNumber?: boolean
    approvedBy?: boolean
    department?: boolean
    project?: boolean
    isRecurring?: boolean
    recurringPeriod?: boolean
    taxAmount?: boolean
    tags?: boolean
    attachments?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    date?: boolean
    vendor?: boolean
    category?: boolean
    subCategory?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    invoiceNumber?: boolean
    approvedBy?: boolean
    department?: boolean
    project?: boolean
    isRecurring?: boolean
    recurringPeriod?: boolean
    taxAmount?: boolean
    tags?: boolean
    attachments?: boolean
    notes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "vendor" | "category" | "subCategory" | "amount" | "currency" | "paymentMethod" | "invoiceNumber" | "approvedBy" | "department" | "project" | "isRecurring" | "recurringPeriod" | "taxAmount" | "tags" | "attachments" | "notes" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      vendor: string
      category: string
      subCategory: string | null
      amount: number
      currency: string
      paymentMethod: string
      invoiceNumber: string | null
      approvedBy: string | null
      department: string | null
      project: string | null
      isRecurring: boolean
      recurringPeriod: string | null
      taxAmount: number | null
      tags: string[]
      attachments: string[]
      notes: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly vendor: FieldRef<"Expense", 'String'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly subCategory: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly currency: FieldRef<"Expense", 'String'>
    readonly paymentMethod: FieldRef<"Expense", 'String'>
    readonly invoiceNumber: FieldRef<"Expense", 'String'>
    readonly approvedBy: FieldRef<"Expense", 'String'>
    readonly department: FieldRef<"Expense", 'String'>
    readonly project: FieldRef<"Expense", 'String'>
    readonly isRecurring: FieldRef<"Expense", 'Boolean'>
    readonly recurringPeriod: FieldRef<"Expense", 'String'>
    readonly taxAmount: FieldRef<"Expense", 'Float'>
    readonly tags: FieldRef<"Expense", 'String[]'>
    readonly attachments: FieldRef<"Expense", 'String[]'>
    readonly notes: FieldRef<"Expense", 'String'>
    readonly status: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
  }


  /**
   * Model ExecutiveMetric
   */

  export type AggregateExecutiveMetric = {
    _count: ExecutiveMetricCountAggregateOutputType | null
    _avg: ExecutiveMetricAvgAggregateOutputType | null
    _sum: ExecutiveMetricSumAggregateOutputType | null
    _min: ExecutiveMetricMinAggregateOutputType | null
    _max: ExecutiveMetricMaxAggregateOutputType | null
  }

  export type ExecutiveMetricAvgAggregateOutputType = {
    revenue: number | null
    revenueTarget: number | null
    revenueTrend: number | null
    cashFlow: number | null
    cashFlowTarget: number | null
    cashFlowTrend: number | null
    currentRatio: number | null
    currentRatioTarget: number | null
    currentRatioTrend: number | null
    quickRatio: number | null
    quickRatioTarget: number | null
    quickRatioTrend: number | null
    oee: number | null
    oeeTarget: number | null
    oeeTrend: number | null
    throughput: number | null
    throughputTarget: number | null
    throughputTrend: number | null
    marketShare: number | null
    marketShareTarget: number | null
    marketShareTrend: number | null
    customerSatisfaction: number | null
    customerSatisfactionTarget: number | null
    customerSatisfactionTrend: number | null
    currentAssets: number | null
    currentLiabilities: number | null
    inventory: number | null
    daysInventory: number | null
    daysReceivables: number | null
    daysPayables: number | null
    cashUnlock: number | null
    confidence: number | null
  }

  export type ExecutiveMetricSumAggregateOutputType = {
    revenue: number | null
    revenueTarget: number | null
    revenueTrend: number | null
    cashFlow: number | null
    cashFlowTarget: number | null
    cashFlowTrend: number | null
    currentRatio: number | null
    currentRatioTarget: number | null
    currentRatioTrend: number | null
    quickRatio: number | null
    quickRatioTarget: number | null
    quickRatioTrend: number | null
    oee: number | null
    oeeTarget: number | null
    oeeTrend: number | null
    throughput: number | null
    throughputTarget: number | null
    throughputTrend: number | null
    marketShare: number | null
    marketShareTarget: number | null
    marketShareTrend: number | null
    customerSatisfaction: number | null
    customerSatisfactionTarget: number | null
    customerSatisfactionTrend: number | null
    currentAssets: number | null
    currentLiabilities: number | null
    inventory: number | null
    daysInventory: number | null
    daysReceivables: number | null
    daysPayables: number | null
    cashUnlock: number | null
    confidence: number | null
  }

  export type ExecutiveMetricMinAggregateOutputType = {
    id: string | null
    date: Date | null
    revenue: number | null
    revenueTarget: number | null
    revenueTrend: number | null
    cashFlow: number | null
    cashFlowTarget: number | null
    cashFlowTrend: number | null
    currentRatio: number | null
    currentRatioTarget: number | null
    currentRatioTrend: number | null
    quickRatio: number | null
    quickRatioTarget: number | null
    quickRatioTrend: number | null
    oee: number | null
    oeeTarget: number | null
    oeeTrend: number | null
    throughput: number | null
    throughputTarget: number | null
    throughputTrend: number | null
    marketShare: number | null
    marketShareTarget: number | null
    marketShareTrend: number | null
    customerSatisfaction: number | null
    customerSatisfactionTarget: number | null
    customerSatisfactionTrend: number | null
    currentAssets: number | null
    currentLiabilities: number | null
    inventory: number | null
    daysInventory: number | null
    daysReceivables: number | null
    daysPayables: number | null
    cashUnlock: number | null
    isActual: boolean | null
    confidence: number | null
    dataSource: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExecutiveMetricMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    revenue: number | null
    revenueTarget: number | null
    revenueTrend: number | null
    cashFlow: number | null
    cashFlowTarget: number | null
    cashFlowTrend: number | null
    currentRatio: number | null
    currentRatioTarget: number | null
    currentRatioTrend: number | null
    quickRatio: number | null
    quickRatioTarget: number | null
    quickRatioTrend: number | null
    oee: number | null
    oeeTarget: number | null
    oeeTrend: number | null
    throughput: number | null
    throughputTarget: number | null
    throughputTrend: number | null
    marketShare: number | null
    marketShareTarget: number | null
    marketShareTrend: number | null
    customerSatisfaction: number | null
    customerSatisfactionTarget: number | null
    customerSatisfactionTrend: number | null
    currentAssets: number | null
    currentLiabilities: number | null
    inventory: number | null
    daysInventory: number | null
    daysReceivables: number | null
    daysPayables: number | null
    cashUnlock: number | null
    isActual: boolean | null
    confidence: number | null
    dataSource: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExecutiveMetricCountAggregateOutputType = {
    id: number
    date: number
    revenue: number
    revenueTarget: number
    revenueTrend: number
    cashFlow: number
    cashFlowTarget: number
    cashFlowTrend: number
    currentRatio: number
    currentRatioTarget: number
    currentRatioTrend: number
    quickRatio: number
    quickRatioTarget: number
    quickRatioTrend: number
    oee: number
    oeeTarget: number
    oeeTrend: number
    throughput: number
    throughputTarget: number
    throughputTrend: number
    marketShare: number
    marketShareTarget: number
    marketShareTrend: number
    customerSatisfaction: number
    customerSatisfactionTarget: number
    customerSatisfactionTrend: number
    currentAssets: number
    currentLiabilities: number
    inventory: number
    daysInventory: number
    daysReceivables: number
    daysPayables: number
    cashUnlock: number
    isActual: number
    confidence: number
    dataSource: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExecutiveMetricAvgAggregateInputType = {
    revenue?: true
    revenueTarget?: true
    revenueTrend?: true
    cashFlow?: true
    cashFlowTarget?: true
    cashFlowTrend?: true
    currentRatio?: true
    currentRatioTarget?: true
    currentRatioTrend?: true
    quickRatio?: true
    quickRatioTarget?: true
    quickRatioTrend?: true
    oee?: true
    oeeTarget?: true
    oeeTrend?: true
    throughput?: true
    throughputTarget?: true
    throughputTrend?: true
    marketShare?: true
    marketShareTarget?: true
    marketShareTrend?: true
    customerSatisfaction?: true
    customerSatisfactionTarget?: true
    customerSatisfactionTrend?: true
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    daysInventory?: true
    daysReceivables?: true
    daysPayables?: true
    cashUnlock?: true
    confidence?: true
  }

  export type ExecutiveMetricSumAggregateInputType = {
    revenue?: true
    revenueTarget?: true
    revenueTrend?: true
    cashFlow?: true
    cashFlowTarget?: true
    cashFlowTrend?: true
    currentRatio?: true
    currentRatioTarget?: true
    currentRatioTrend?: true
    quickRatio?: true
    quickRatioTarget?: true
    quickRatioTrend?: true
    oee?: true
    oeeTarget?: true
    oeeTrend?: true
    throughput?: true
    throughputTarget?: true
    throughputTrend?: true
    marketShare?: true
    marketShareTarget?: true
    marketShareTrend?: true
    customerSatisfaction?: true
    customerSatisfactionTarget?: true
    customerSatisfactionTrend?: true
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    daysInventory?: true
    daysReceivables?: true
    daysPayables?: true
    cashUnlock?: true
    confidence?: true
  }

  export type ExecutiveMetricMinAggregateInputType = {
    id?: true
    date?: true
    revenue?: true
    revenueTarget?: true
    revenueTrend?: true
    cashFlow?: true
    cashFlowTarget?: true
    cashFlowTrend?: true
    currentRatio?: true
    currentRatioTarget?: true
    currentRatioTrend?: true
    quickRatio?: true
    quickRatioTarget?: true
    quickRatioTrend?: true
    oee?: true
    oeeTarget?: true
    oeeTrend?: true
    throughput?: true
    throughputTarget?: true
    throughputTrend?: true
    marketShare?: true
    marketShareTarget?: true
    marketShareTrend?: true
    customerSatisfaction?: true
    customerSatisfactionTarget?: true
    customerSatisfactionTrend?: true
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    daysInventory?: true
    daysReceivables?: true
    daysPayables?: true
    cashUnlock?: true
    isActual?: true
    confidence?: true
    dataSource?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExecutiveMetricMaxAggregateInputType = {
    id?: true
    date?: true
    revenue?: true
    revenueTarget?: true
    revenueTrend?: true
    cashFlow?: true
    cashFlowTarget?: true
    cashFlowTrend?: true
    currentRatio?: true
    currentRatioTarget?: true
    currentRatioTrend?: true
    quickRatio?: true
    quickRatioTarget?: true
    quickRatioTrend?: true
    oee?: true
    oeeTarget?: true
    oeeTrend?: true
    throughput?: true
    throughputTarget?: true
    throughputTrend?: true
    marketShare?: true
    marketShareTarget?: true
    marketShareTrend?: true
    customerSatisfaction?: true
    customerSatisfactionTarget?: true
    customerSatisfactionTrend?: true
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    daysInventory?: true
    daysReceivables?: true
    daysPayables?: true
    cashUnlock?: true
    isActual?: true
    confidence?: true
    dataSource?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExecutiveMetricCountAggregateInputType = {
    id?: true
    date?: true
    revenue?: true
    revenueTarget?: true
    revenueTrend?: true
    cashFlow?: true
    cashFlowTarget?: true
    cashFlowTrend?: true
    currentRatio?: true
    currentRatioTarget?: true
    currentRatioTrend?: true
    quickRatio?: true
    quickRatioTarget?: true
    quickRatioTrend?: true
    oee?: true
    oeeTarget?: true
    oeeTrend?: true
    throughput?: true
    throughputTarget?: true
    throughputTrend?: true
    marketShare?: true
    marketShareTarget?: true
    marketShareTrend?: true
    customerSatisfaction?: true
    customerSatisfactionTarget?: true
    customerSatisfactionTrend?: true
    currentAssets?: true
    currentLiabilities?: true
    inventory?: true
    daysInventory?: true
    daysReceivables?: true
    daysPayables?: true
    cashUnlock?: true
    isActual?: true
    confidence?: true
    dataSource?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExecutiveMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutiveMetric to aggregate.
     */
    where?: ExecutiveMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutiveMetrics to fetch.
     */
    orderBy?: ExecutiveMetricOrderByWithRelationInput | ExecutiveMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutiveMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutiveMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutiveMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExecutiveMetrics
    **/
    _count?: true | ExecutiveMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExecutiveMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExecutiveMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutiveMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutiveMetricMaxAggregateInputType
  }

  export type GetExecutiveMetricAggregateType<T extends ExecutiveMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutiveMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutiveMetric[P]>
      : GetScalarType<T[P], AggregateExecutiveMetric[P]>
  }




  export type ExecutiveMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutiveMetricWhereInput
    orderBy?: ExecutiveMetricOrderByWithAggregationInput | ExecutiveMetricOrderByWithAggregationInput[]
    by: ExecutiveMetricScalarFieldEnum[] | ExecutiveMetricScalarFieldEnum
    having?: ExecutiveMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutiveMetricCountAggregateInputType | true
    _avg?: ExecutiveMetricAvgAggregateInputType
    _sum?: ExecutiveMetricSumAggregateInputType
    _min?: ExecutiveMetricMinAggregateInputType
    _max?: ExecutiveMetricMaxAggregateInputType
  }

  export type ExecutiveMetricGroupByOutputType = {
    id: string
    date: Date
    revenue: number
    revenueTarget: number
    revenueTrend: number
    cashFlow: number
    cashFlowTarget: number
    cashFlowTrend: number
    currentRatio: number
    currentRatioTarget: number
    currentRatioTrend: number
    quickRatio: number
    quickRatioTarget: number
    quickRatioTrend: number
    oee: number
    oeeTarget: number
    oeeTrend: number
    throughput: number
    throughputTarget: number
    throughputTrend: number
    marketShare: number
    marketShareTarget: number
    marketShareTrend: number
    customerSatisfaction: number
    customerSatisfactionTarget: number
    customerSatisfactionTrend: number
    currentAssets: number
    currentLiabilities: number
    inventory: number
    daysInventory: number
    daysReceivables: number
    daysPayables: number
    cashUnlock: number
    isActual: boolean
    confidence: number
    dataSource: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExecutiveMetricCountAggregateOutputType | null
    _avg: ExecutiveMetricAvgAggregateOutputType | null
    _sum: ExecutiveMetricSumAggregateOutputType | null
    _min: ExecutiveMetricMinAggregateOutputType | null
    _max: ExecutiveMetricMaxAggregateOutputType | null
  }

  type GetExecutiveMetricGroupByPayload<T extends ExecutiveMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutiveMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutiveMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutiveMetricGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutiveMetricGroupByOutputType[P]>
        }
      >
    >


  export type ExecutiveMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    revenue?: boolean
    revenueTarget?: boolean
    revenueTrend?: boolean
    cashFlow?: boolean
    cashFlowTarget?: boolean
    cashFlowTrend?: boolean
    currentRatio?: boolean
    currentRatioTarget?: boolean
    currentRatioTrend?: boolean
    quickRatio?: boolean
    quickRatioTarget?: boolean
    quickRatioTrend?: boolean
    oee?: boolean
    oeeTarget?: boolean
    oeeTrend?: boolean
    throughput?: boolean
    throughputTarget?: boolean
    throughputTrend?: boolean
    marketShare?: boolean
    marketShareTarget?: boolean
    marketShareTrend?: boolean
    customerSatisfaction?: boolean
    customerSatisfactionTarget?: boolean
    customerSatisfactionTrend?: boolean
    currentAssets?: boolean
    currentLiabilities?: boolean
    inventory?: boolean
    daysInventory?: boolean
    daysReceivables?: boolean
    daysPayables?: boolean
    cashUnlock?: boolean
    isActual?: boolean
    confidence?: boolean
    dataSource?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["executiveMetric"]>

  export type ExecutiveMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    revenue?: boolean
    revenueTarget?: boolean
    revenueTrend?: boolean
    cashFlow?: boolean
    cashFlowTarget?: boolean
    cashFlowTrend?: boolean
    currentRatio?: boolean
    currentRatioTarget?: boolean
    currentRatioTrend?: boolean
    quickRatio?: boolean
    quickRatioTarget?: boolean
    quickRatioTrend?: boolean
    oee?: boolean
    oeeTarget?: boolean
    oeeTrend?: boolean
    throughput?: boolean
    throughputTarget?: boolean
    throughputTrend?: boolean
    marketShare?: boolean
    marketShareTarget?: boolean
    marketShareTrend?: boolean
    customerSatisfaction?: boolean
    customerSatisfactionTarget?: boolean
    customerSatisfactionTrend?: boolean
    currentAssets?: boolean
    currentLiabilities?: boolean
    inventory?: boolean
    daysInventory?: boolean
    daysReceivables?: boolean
    daysPayables?: boolean
    cashUnlock?: boolean
    isActual?: boolean
    confidence?: boolean
    dataSource?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["executiveMetric"]>

  export type ExecutiveMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    revenue?: boolean
    revenueTarget?: boolean
    revenueTrend?: boolean
    cashFlow?: boolean
    cashFlowTarget?: boolean
    cashFlowTrend?: boolean
    currentRatio?: boolean
    currentRatioTarget?: boolean
    currentRatioTrend?: boolean
    quickRatio?: boolean
    quickRatioTarget?: boolean
    quickRatioTrend?: boolean
    oee?: boolean
    oeeTarget?: boolean
    oeeTrend?: boolean
    throughput?: boolean
    throughputTarget?: boolean
    throughputTrend?: boolean
    marketShare?: boolean
    marketShareTarget?: boolean
    marketShareTrend?: boolean
    customerSatisfaction?: boolean
    customerSatisfactionTarget?: boolean
    customerSatisfactionTrend?: boolean
    currentAssets?: boolean
    currentLiabilities?: boolean
    inventory?: boolean
    daysInventory?: boolean
    daysReceivables?: boolean
    daysPayables?: boolean
    cashUnlock?: boolean
    isActual?: boolean
    confidence?: boolean
    dataSource?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["executiveMetric"]>

  export type ExecutiveMetricSelectScalar = {
    id?: boolean
    date?: boolean
    revenue?: boolean
    revenueTarget?: boolean
    revenueTrend?: boolean
    cashFlow?: boolean
    cashFlowTarget?: boolean
    cashFlowTrend?: boolean
    currentRatio?: boolean
    currentRatioTarget?: boolean
    currentRatioTrend?: boolean
    quickRatio?: boolean
    quickRatioTarget?: boolean
    quickRatioTrend?: boolean
    oee?: boolean
    oeeTarget?: boolean
    oeeTrend?: boolean
    throughput?: boolean
    throughputTarget?: boolean
    throughputTrend?: boolean
    marketShare?: boolean
    marketShareTarget?: boolean
    marketShareTrend?: boolean
    customerSatisfaction?: boolean
    customerSatisfactionTarget?: boolean
    customerSatisfactionTrend?: boolean
    currentAssets?: boolean
    currentLiabilities?: boolean
    inventory?: boolean
    daysInventory?: boolean
    daysReceivables?: boolean
    daysPayables?: boolean
    cashUnlock?: boolean
    isActual?: boolean
    confidence?: boolean
    dataSource?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExecutiveMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "revenue" | "revenueTarget" | "revenueTrend" | "cashFlow" | "cashFlowTarget" | "cashFlowTrend" | "currentRatio" | "currentRatioTarget" | "currentRatioTrend" | "quickRatio" | "quickRatioTarget" | "quickRatioTrend" | "oee" | "oeeTarget" | "oeeTrend" | "throughput" | "throughputTarget" | "throughputTrend" | "marketShare" | "marketShareTarget" | "marketShareTrend" | "customerSatisfaction" | "customerSatisfactionTarget" | "customerSatisfactionTrend" | "currentAssets" | "currentLiabilities" | "inventory" | "daysInventory" | "daysReceivables" | "daysPayables" | "cashUnlock" | "isActual" | "confidence" | "dataSource" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["executiveMetric"]>

  export type $ExecutiveMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExecutiveMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      revenue: number
      revenueTarget: number
      revenueTrend: number
      cashFlow: number
      cashFlowTarget: number
      cashFlowTrend: number
      currentRatio: number
      currentRatioTarget: number
      currentRatioTrend: number
      quickRatio: number
      quickRatioTarget: number
      quickRatioTrend: number
      oee: number
      oeeTarget: number
      oeeTrend: number
      throughput: number
      throughputTarget: number
      throughputTrend: number
      marketShare: number
      marketShareTarget: number
      marketShareTrend: number
      customerSatisfaction: number
      customerSatisfactionTarget: number
      customerSatisfactionTrend: number
      currentAssets: number
      currentLiabilities: number
      inventory: number
      daysInventory: number
      daysReceivables: number
      daysPayables: number
      cashUnlock: number
      isActual: boolean
      confidence: number
      dataSource: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["executiveMetric"]>
    composites: {}
  }

  type ExecutiveMetricGetPayload<S extends boolean | null | undefined | ExecutiveMetricDefaultArgs> = $Result.GetResult<Prisma.$ExecutiveMetricPayload, S>

  type ExecutiveMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExecutiveMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExecutiveMetricCountAggregateInputType | true
    }

  export interface ExecutiveMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExecutiveMetric'], meta: { name: 'ExecutiveMetric' } }
    /**
     * Find zero or one ExecutiveMetric that matches the filter.
     * @param {ExecutiveMetricFindUniqueArgs} args - Arguments to find a ExecutiveMetric
     * @example
     * // Get one ExecutiveMetric
     * const executiveMetric = await prisma.executiveMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutiveMetricFindUniqueArgs>(args: SelectSubset<T, ExecutiveMetricFindUniqueArgs<ExtArgs>>): Prisma__ExecutiveMetricClient<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExecutiveMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExecutiveMetricFindUniqueOrThrowArgs} args - Arguments to find a ExecutiveMetric
     * @example
     * // Get one ExecutiveMetric
     * const executiveMetric = await prisma.executiveMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutiveMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutiveMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutiveMetricClient<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExecutiveMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveMetricFindFirstArgs} args - Arguments to find a ExecutiveMetric
     * @example
     * // Get one ExecutiveMetric
     * const executiveMetric = await prisma.executiveMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutiveMetricFindFirstArgs>(args?: SelectSubset<T, ExecutiveMetricFindFirstArgs<ExtArgs>>): Prisma__ExecutiveMetricClient<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExecutiveMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveMetricFindFirstOrThrowArgs} args - Arguments to find a ExecutiveMetric
     * @example
     * // Get one ExecutiveMetric
     * const executiveMetric = await prisma.executiveMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutiveMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutiveMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutiveMetricClient<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExecutiveMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExecutiveMetrics
     * const executiveMetrics = await prisma.executiveMetric.findMany()
     * 
     * // Get first 10 ExecutiveMetrics
     * const executiveMetrics = await prisma.executiveMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executiveMetricWithIdOnly = await prisma.executiveMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutiveMetricFindManyArgs>(args?: SelectSubset<T, ExecutiveMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExecutiveMetric.
     * @param {ExecutiveMetricCreateArgs} args - Arguments to create a ExecutiveMetric.
     * @example
     * // Create one ExecutiveMetric
     * const ExecutiveMetric = await prisma.executiveMetric.create({
     *   data: {
     *     // ... data to create a ExecutiveMetric
     *   }
     * })
     * 
     */
    create<T extends ExecutiveMetricCreateArgs>(args: SelectSubset<T, ExecutiveMetricCreateArgs<ExtArgs>>): Prisma__ExecutiveMetricClient<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExecutiveMetrics.
     * @param {ExecutiveMetricCreateManyArgs} args - Arguments to create many ExecutiveMetrics.
     * @example
     * // Create many ExecutiveMetrics
     * const executiveMetric = await prisma.executiveMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutiveMetricCreateManyArgs>(args?: SelectSubset<T, ExecutiveMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExecutiveMetrics and returns the data saved in the database.
     * @param {ExecutiveMetricCreateManyAndReturnArgs} args - Arguments to create many ExecutiveMetrics.
     * @example
     * // Create many ExecutiveMetrics
     * const executiveMetric = await prisma.executiveMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExecutiveMetrics and only return the `id`
     * const executiveMetricWithIdOnly = await prisma.executiveMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutiveMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutiveMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExecutiveMetric.
     * @param {ExecutiveMetricDeleteArgs} args - Arguments to delete one ExecutiveMetric.
     * @example
     * // Delete one ExecutiveMetric
     * const ExecutiveMetric = await prisma.executiveMetric.delete({
     *   where: {
     *     // ... filter to delete one ExecutiveMetric
     *   }
     * })
     * 
     */
    delete<T extends ExecutiveMetricDeleteArgs>(args: SelectSubset<T, ExecutiveMetricDeleteArgs<ExtArgs>>): Prisma__ExecutiveMetricClient<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExecutiveMetric.
     * @param {ExecutiveMetricUpdateArgs} args - Arguments to update one ExecutiveMetric.
     * @example
     * // Update one ExecutiveMetric
     * const executiveMetric = await prisma.executiveMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutiveMetricUpdateArgs>(args: SelectSubset<T, ExecutiveMetricUpdateArgs<ExtArgs>>): Prisma__ExecutiveMetricClient<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExecutiveMetrics.
     * @param {ExecutiveMetricDeleteManyArgs} args - Arguments to filter ExecutiveMetrics to delete.
     * @example
     * // Delete a few ExecutiveMetrics
     * const { count } = await prisma.executiveMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutiveMetricDeleteManyArgs>(args?: SelectSubset<T, ExecutiveMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutiveMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExecutiveMetrics
     * const executiveMetric = await prisma.executiveMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutiveMetricUpdateManyArgs>(args: SelectSubset<T, ExecutiveMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutiveMetrics and returns the data updated in the database.
     * @param {ExecutiveMetricUpdateManyAndReturnArgs} args - Arguments to update many ExecutiveMetrics.
     * @example
     * // Update many ExecutiveMetrics
     * const executiveMetric = await prisma.executiveMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExecutiveMetrics and only return the `id`
     * const executiveMetricWithIdOnly = await prisma.executiveMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExecutiveMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, ExecutiveMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExecutiveMetric.
     * @param {ExecutiveMetricUpsertArgs} args - Arguments to update or create a ExecutiveMetric.
     * @example
     * // Update or create a ExecutiveMetric
     * const executiveMetric = await prisma.executiveMetric.upsert({
     *   create: {
     *     // ... data to create a ExecutiveMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExecutiveMetric we want to update
     *   }
     * })
     */
    upsert<T extends ExecutiveMetricUpsertArgs>(args: SelectSubset<T, ExecutiveMetricUpsertArgs<ExtArgs>>): Prisma__ExecutiveMetricClient<$Result.GetResult<Prisma.$ExecutiveMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExecutiveMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveMetricCountArgs} args - Arguments to filter ExecutiveMetrics to count.
     * @example
     * // Count the number of ExecutiveMetrics
     * const count = await prisma.executiveMetric.count({
     *   where: {
     *     // ... the filter for the ExecutiveMetrics we want to count
     *   }
     * })
    **/
    count<T extends ExecutiveMetricCountArgs>(
      args?: Subset<T, ExecutiveMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutiveMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExecutiveMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutiveMetricAggregateArgs>(args: Subset<T, ExecutiveMetricAggregateArgs>): Prisma.PrismaPromise<GetExecutiveMetricAggregateType<T>>

    /**
     * Group by ExecutiveMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutiveMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutiveMetricGroupByArgs['orderBy'] }
        : { orderBy?: ExecutiveMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutiveMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutiveMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExecutiveMetric model
   */
  readonly fields: ExecutiveMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExecutiveMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutiveMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExecutiveMetric model
   */
  interface ExecutiveMetricFieldRefs {
    readonly id: FieldRef<"ExecutiveMetric", 'String'>
    readonly date: FieldRef<"ExecutiveMetric", 'DateTime'>
    readonly revenue: FieldRef<"ExecutiveMetric", 'Float'>
    readonly revenueTarget: FieldRef<"ExecutiveMetric", 'Float'>
    readonly revenueTrend: FieldRef<"ExecutiveMetric", 'Float'>
    readonly cashFlow: FieldRef<"ExecutiveMetric", 'Float'>
    readonly cashFlowTarget: FieldRef<"ExecutiveMetric", 'Float'>
    readonly cashFlowTrend: FieldRef<"ExecutiveMetric", 'Float'>
    readonly currentRatio: FieldRef<"ExecutiveMetric", 'Float'>
    readonly currentRatioTarget: FieldRef<"ExecutiveMetric", 'Float'>
    readonly currentRatioTrend: FieldRef<"ExecutiveMetric", 'Float'>
    readonly quickRatio: FieldRef<"ExecutiveMetric", 'Float'>
    readonly quickRatioTarget: FieldRef<"ExecutiveMetric", 'Float'>
    readonly quickRatioTrend: FieldRef<"ExecutiveMetric", 'Float'>
    readonly oee: FieldRef<"ExecutiveMetric", 'Float'>
    readonly oeeTarget: FieldRef<"ExecutiveMetric", 'Float'>
    readonly oeeTrend: FieldRef<"ExecutiveMetric", 'Float'>
    readonly throughput: FieldRef<"ExecutiveMetric", 'Float'>
    readonly throughputTarget: FieldRef<"ExecutiveMetric", 'Float'>
    readonly throughputTrend: FieldRef<"ExecutiveMetric", 'Float'>
    readonly marketShare: FieldRef<"ExecutiveMetric", 'Float'>
    readonly marketShareTarget: FieldRef<"ExecutiveMetric", 'Float'>
    readonly marketShareTrend: FieldRef<"ExecutiveMetric", 'Float'>
    readonly customerSatisfaction: FieldRef<"ExecutiveMetric", 'Float'>
    readonly customerSatisfactionTarget: FieldRef<"ExecutiveMetric", 'Float'>
    readonly customerSatisfactionTrend: FieldRef<"ExecutiveMetric", 'Float'>
    readonly currentAssets: FieldRef<"ExecutiveMetric", 'Float'>
    readonly currentLiabilities: FieldRef<"ExecutiveMetric", 'Float'>
    readonly inventory: FieldRef<"ExecutiveMetric", 'Float'>
    readonly daysInventory: FieldRef<"ExecutiveMetric", 'Float'>
    readonly daysReceivables: FieldRef<"ExecutiveMetric", 'Float'>
    readonly daysPayables: FieldRef<"ExecutiveMetric", 'Float'>
    readonly cashUnlock: FieldRef<"ExecutiveMetric", 'Float'>
    readonly isActual: FieldRef<"ExecutiveMetric", 'Boolean'>
    readonly confidence: FieldRef<"ExecutiveMetric", 'Float'>
    readonly dataSource: FieldRef<"ExecutiveMetric", 'String'>
    readonly notes: FieldRef<"ExecutiveMetric", 'String'>
    readonly createdAt: FieldRef<"ExecutiveMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"ExecutiveMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExecutiveMetric findUnique
   */
  export type ExecutiveMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveMetric to fetch.
     */
    where: ExecutiveMetricWhereUniqueInput
  }

  /**
   * ExecutiveMetric findUniqueOrThrow
   */
  export type ExecutiveMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveMetric to fetch.
     */
    where: ExecutiveMetricWhereUniqueInput
  }

  /**
   * ExecutiveMetric findFirst
   */
  export type ExecutiveMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveMetric to fetch.
     */
    where?: ExecutiveMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutiveMetrics to fetch.
     */
    orderBy?: ExecutiveMetricOrderByWithRelationInput | ExecutiveMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutiveMetrics.
     */
    cursor?: ExecutiveMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutiveMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutiveMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutiveMetrics.
     */
    distinct?: ExecutiveMetricScalarFieldEnum | ExecutiveMetricScalarFieldEnum[]
  }

  /**
   * ExecutiveMetric findFirstOrThrow
   */
  export type ExecutiveMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveMetric to fetch.
     */
    where?: ExecutiveMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutiveMetrics to fetch.
     */
    orderBy?: ExecutiveMetricOrderByWithRelationInput | ExecutiveMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutiveMetrics.
     */
    cursor?: ExecutiveMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutiveMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutiveMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutiveMetrics.
     */
    distinct?: ExecutiveMetricScalarFieldEnum | ExecutiveMetricScalarFieldEnum[]
  }

  /**
   * ExecutiveMetric findMany
   */
  export type ExecutiveMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveMetrics to fetch.
     */
    where?: ExecutiveMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutiveMetrics to fetch.
     */
    orderBy?: ExecutiveMetricOrderByWithRelationInput | ExecutiveMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExecutiveMetrics.
     */
    cursor?: ExecutiveMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutiveMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutiveMetrics.
     */
    skip?: number
    distinct?: ExecutiveMetricScalarFieldEnum | ExecutiveMetricScalarFieldEnum[]
  }

  /**
   * ExecutiveMetric create
   */
  export type ExecutiveMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a ExecutiveMetric.
     */
    data: XOR<ExecutiveMetricCreateInput, ExecutiveMetricUncheckedCreateInput>
  }

  /**
   * ExecutiveMetric createMany
   */
  export type ExecutiveMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExecutiveMetrics.
     */
    data: ExecutiveMetricCreateManyInput | ExecutiveMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutiveMetric createManyAndReturn
   */
  export type ExecutiveMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * The data used to create many ExecutiveMetrics.
     */
    data: ExecutiveMetricCreateManyInput | ExecutiveMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutiveMetric update
   */
  export type ExecutiveMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a ExecutiveMetric.
     */
    data: XOR<ExecutiveMetricUpdateInput, ExecutiveMetricUncheckedUpdateInput>
    /**
     * Choose, which ExecutiveMetric to update.
     */
    where: ExecutiveMetricWhereUniqueInput
  }

  /**
   * ExecutiveMetric updateMany
   */
  export type ExecutiveMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExecutiveMetrics.
     */
    data: XOR<ExecutiveMetricUpdateManyMutationInput, ExecutiveMetricUncheckedUpdateManyInput>
    /**
     * Filter which ExecutiveMetrics to update
     */
    where?: ExecutiveMetricWhereInput
    /**
     * Limit how many ExecutiveMetrics to update.
     */
    limit?: number
  }

  /**
   * ExecutiveMetric updateManyAndReturn
   */
  export type ExecutiveMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * The data used to update ExecutiveMetrics.
     */
    data: XOR<ExecutiveMetricUpdateManyMutationInput, ExecutiveMetricUncheckedUpdateManyInput>
    /**
     * Filter which ExecutiveMetrics to update
     */
    where?: ExecutiveMetricWhereInput
    /**
     * Limit how many ExecutiveMetrics to update.
     */
    limit?: number
  }

  /**
   * ExecutiveMetric upsert
   */
  export type ExecutiveMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the ExecutiveMetric to update in case it exists.
     */
    where: ExecutiveMetricWhereUniqueInput
    /**
     * In case the ExecutiveMetric found by the `where` argument doesn't exist, create a new ExecutiveMetric with this data.
     */
    create: XOR<ExecutiveMetricCreateInput, ExecutiveMetricUncheckedCreateInput>
    /**
     * In case the ExecutiveMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutiveMetricUpdateInput, ExecutiveMetricUncheckedUpdateInput>
  }

  /**
   * ExecutiveMetric delete
   */
  export type ExecutiveMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
    /**
     * Filter which ExecutiveMetric to delete.
     */
    where: ExecutiveMetricWhereUniqueInput
  }

  /**
   * ExecutiveMetric deleteMany
   */
  export type ExecutiveMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutiveMetrics to delete
     */
    where?: ExecutiveMetricWhereInput
    /**
     * Limit how many ExecutiveMetrics to delete.
     */
    limit?: number
  }

  /**
   * ExecutiveMetric without action
   */
  export type ExecutiveMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveMetric
     */
    select?: ExecutiveMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveMetric
     */
    omit?: ExecutiveMetricOmit<ExtArgs> | null
  }


  /**
   * Model ExecutiveAlert
   */

  export type AggregateExecutiveAlert = {
    _count: ExecutiveAlertCountAggregateOutputType | null
    _min: ExecutiveAlertMinAggregateOutputType | null
    _max: ExecutiveAlertMaxAggregateOutputType | null
  }

  export type ExecutiveAlertMinAggregateOutputType = {
    id: string | null
    severity: string | null
    type: string | null
    category: string | null
    title: string | null
    description: string | null
    impact: string | null
    action: string | null
    source: string | null
    isActive: boolean | null
    isDismissed: boolean | null
    dismissedBy: string | null
    dismissedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExecutiveAlertMaxAggregateOutputType = {
    id: string | null
    severity: string | null
    type: string | null
    category: string | null
    title: string | null
    description: string | null
    impact: string | null
    action: string | null
    source: string | null
    isActive: boolean | null
    isDismissed: boolean | null
    dismissedBy: string | null
    dismissedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExecutiveAlertCountAggregateOutputType = {
    id: number
    severity: number
    type: number
    category: number
    title: number
    description: number
    impact: number
    action: number
    source: number
    metrics: number
    isActive: number
    isDismissed: number
    dismissedBy: number
    dismissedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExecutiveAlertMinAggregateInputType = {
    id?: true
    severity?: true
    type?: true
    category?: true
    title?: true
    description?: true
    impact?: true
    action?: true
    source?: true
    isActive?: true
    isDismissed?: true
    dismissedBy?: true
    dismissedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExecutiveAlertMaxAggregateInputType = {
    id?: true
    severity?: true
    type?: true
    category?: true
    title?: true
    description?: true
    impact?: true
    action?: true
    source?: true
    isActive?: true
    isDismissed?: true
    dismissedBy?: true
    dismissedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExecutiveAlertCountAggregateInputType = {
    id?: true
    severity?: true
    type?: true
    category?: true
    title?: true
    description?: true
    impact?: true
    action?: true
    source?: true
    metrics?: true
    isActive?: true
    isDismissed?: true
    dismissedBy?: true
    dismissedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExecutiveAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutiveAlert to aggregate.
     */
    where?: ExecutiveAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutiveAlerts to fetch.
     */
    orderBy?: ExecutiveAlertOrderByWithRelationInput | ExecutiveAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutiveAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutiveAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutiveAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExecutiveAlerts
    **/
    _count?: true | ExecutiveAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutiveAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutiveAlertMaxAggregateInputType
  }

  export type GetExecutiveAlertAggregateType<T extends ExecutiveAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutiveAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutiveAlert[P]>
      : GetScalarType<T[P], AggregateExecutiveAlert[P]>
  }




  export type ExecutiveAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutiveAlertWhereInput
    orderBy?: ExecutiveAlertOrderByWithAggregationInput | ExecutiveAlertOrderByWithAggregationInput[]
    by: ExecutiveAlertScalarFieldEnum[] | ExecutiveAlertScalarFieldEnum
    having?: ExecutiveAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutiveAlertCountAggregateInputType | true
    _min?: ExecutiveAlertMinAggregateInputType
    _max?: ExecutiveAlertMaxAggregateInputType
  }

  export type ExecutiveAlertGroupByOutputType = {
    id: string
    severity: string
    type: string
    category: string
    title: string
    description: string
    impact: string | null
    action: string | null
    source: string
    metrics: JsonValue | null
    isActive: boolean
    isDismissed: boolean
    dismissedBy: string | null
    dismissedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ExecutiveAlertCountAggregateOutputType | null
    _min: ExecutiveAlertMinAggregateOutputType | null
    _max: ExecutiveAlertMaxAggregateOutputType | null
  }

  type GetExecutiveAlertGroupByPayload<T extends ExecutiveAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutiveAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutiveAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutiveAlertGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutiveAlertGroupByOutputType[P]>
        }
      >
    >


  export type ExecutiveAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    severity?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    impact?: boolean
    action?: boolean
    source?: boolean
    metrics?: boolean
    isActive?: boolean
    isDismissed?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["executiveAlert"]>

  export type ExecutiveAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    severity?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    impact?: boolean
    action?: boolean
    source?: boolean
    metrics?: boolean
    isActive?: boolean
    isDismissed?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["executiveAlert"]>

  export type ExecutiveAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    severity?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    impact?: boolean
    action?: boolean
    source?: boolean
    metrics?: boolean
    isActive?: boolean
    isDismissed?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["executiveAlert"]>

  export type ExecutiveAlertSelectScalar = {
    id?: boolean
    severity?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    impact?: boolean
    action?: boolean
    source?: boolean
    metrics?: boolean
    isActive?: boolean
    isDismissed?: boolean
    dismissedBy?: boolean
    dismissedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExecutiveAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "severity" | "type" | "category" | "title" | "description" | "impact" | "action" | "source" | "metrics" | "isActive" | "isDismissed" | "dismissedBy" | "dismissedAt" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["executiveAlert"]>

  export type $ExecutiveAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExecutiveAlert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      severity: string
      type: string
      category: string
      title: string
      description: string
      impact: string | null
      action: string | null
      source: string
      metrics: Prisma.JsonValue | null
      isActive: boolean
      isDismissed: boolean
      dismissedBy: string | null
      dismissedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["executiveAlert"]>
    composites: {}
  }

  type ExecutiveAlertGetPayload<S extends boolean | null | undefined | ExecutiveAlertDefaultArgs> = $Result.GetResult<Prisma.$ExecutiveAlertPayload, S>

  type ExecutiveAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExecutiveAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExecutiveAlertCountAggregateInputType | true
    }

  export interface ExecutiveAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExecutiveAlert'], meta: { name: 'ExecutiveAlert' } }
    /**
     * Find zero or one ExecutiveAlert that matches the filter.
     * @param {ExecutiveAlertFindUniqueArgs} args - Arguments to find a ExecutiveAlert
     * @example
     * // Get one ExecutiveAlert
     * const executiveAlert = await prisma.executiveAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutiveAlertFindUniqueArgs>(args: SelectSubset<T, ExecutiveAlertFindUniqueArgs<ExtArgs>>): Prisma__ExecutiveAlertClient<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExecutiveAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExecutiveAlertFindUniqueOrThrowArgs} args - Arguments to find a ExecutiveAlert
     * @example
     * // Get one ExecutiveAlert
     * const executiveAlert = await prisma.executiveAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutiveAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutiveAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutiveAlertClient<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExecutiveAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveAlertFindFirstArgs} args - Arguments to find a ExecutiveAlert
     * @example
     * // Get one ExecutiveAlert
     * const executiveAlert = await prisma.executiveAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutiveAlertFindFirstArgs>(args?: SelectSubset<T, ExecutiveAlertFindFirstArgs<ExtArgs>>): Prisma__ExecutiveAlertClient<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExecutiveAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveAlertFindFirstOrThrowArgs} args - Arguments to find a ExecutiveAlert
     * @example
     * // Get one ExecutiveAlert
     * const executiveAlert = await prisma.executiveAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutiveAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutiveAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutiveAlertClient<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExecutiveAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExecutiveAlerts
     * const executiveAlerts = await prisma.executiveAlert.findMany()
     * 
     * // Get first 10 ExecutiveAlerts
     * const executiveAlerts = await prisma.executiveAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executiveAlertWithIdOnly = await prisma.executiveAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutiveAlertFindManyArgs>(args?: SelectSubset<T, ExecutiveAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExecutiveAlert.
     * @param {ExecutiveAlertCreateArgs} args - Arguments to create a ExecutiveAlert.
     * @example
     * // Create one ExecutiveAlert
     * const ExecutiveAlert = await prisma.executiveAlert.create({
     *   data: {
     *     // ... data to create a ExecutiveAlert
     *   }
     * })
     * 
     */
    create<T extends ExecutiveAlertCreateArgs>(args: SelectSubset<T, ExecutiveAlertCreateArgs<ExtArgs>>): Prisma__ExecutiveAlertClient<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExecutiveAlerts.
     * @param {ExecutiveAlertCreateManyArgs} args - Arguments to create many ExecutiveAlerts.
     * @example
     * // Create many ExecutiveAlerts
     * const executiveAlert = await prisma.executiveAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutiveAlertCreateManyArgs>(args?: SelectSubset<T, ExecutiveAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExecutiveAlerts and returns the data saved in the database.
     * @param {ExecutiveAlertCreateManyAndReturnArgs} args - Arguments to create many ExecutiveAlerts.
     * @example
     * // Create many ExecutiveAlerts
     * const executiveAlert = await prisma.executiveAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExecutiveAlerts and only return the `id`
     * const executiveAlertWithIdOnly = await prisma.executiveAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutiveAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutiveAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExecutiveAlert.
     * @param {ExecutiveAlertDeleteArgs} args - Arguments to delete one ExecutiveAlert.
     * @example
     * // Delete one ExecutiveAlert
     * const ExecutiveAlert = await prisma.executiveAlert.delete({
     *   where: {
     *     // ... filter to delete one ExecutiveAlert
     *   }
     * })
     * 
     */
    delete<T extends ExecutiveAlertDeleteArgs>(args: SelectSubset<T, ExecutiveAlertDeleteArgs<ExtArgs>>): Prisma__ExecutiveAlertClient<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExecutiveAlert.
     * @param {ExecutiveAlertUpdateArgs} args - Arguments to update one ExecutiveAlert.
     * @example
     * // Update one ExecutiveAlert
     * const executiveAlert = await prisma.executiveAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutiveAlertUpdateArgs>(args: SelectSubset<T, ExecutiveAlertUpdateArgs<ExtArgs>>): Prisma__ExecutiveAlertClient<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExecutiveAlerts.
     * @param {ExecutiveAlertDeleteManyArgs} args - Arguments to filter ExecutiveAlerts to delete.
     * @example
     * // Delete a few ExecutiveAlerts
     * const { count } = await prisma.executiveAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutiveAlertDeleteManyArgs>(args?: SelectSubset<T, ExecutiveAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutiveAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExecutiveAlerts
     * const executiveAlert = await prisma.executiveAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutiveAlertUpdateManyArgs>(args: SelectSubset<T, ExecutiveAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutiveAlerts and returns the data updated in the database.
     * @param {ExecutiveAlertUpdateManyAndReturnArgs} args - Arguments to update many ExecutiveAlerts.
     * @example
     * // Update many ExecutiveAlerts
     * const executiveAlert = await prisma.executiveAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExecutiveAlerts and only return the `id`
     * const executiveAlertWithIdOnly = await prisma.executiveAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExecutiveAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, ExecutiveAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExecutiveAlert.
     * @param {ExecutiveAlertUpsertArgs} args - Arguments to update or create a ExecutiveAlert.
     * @example
     * // Update or create a ExecutiveAlert
     * const executiveAlert = await prisma.executiveAlert.upsert({
     *   create: {
     *     // ... data to create a ExecutiveAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExecutiveAlert we want to update
     *   }
     * })
     */
    upsert<T extends ExecutiveAlertUpsertArgs>(args: SelectSubset<T, ExecutiveAlertUpsertArgs<ExtArgs>>): Prisma__ExecutiveAlertClient<$Result.GetResult<Prisma.$ExecutiveAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExecutiveAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveAlertCountArgs} args - Arguments to filter ExecutiveAlerts to count.
     * @example
     * // Count the number of ExecutiveAlerts
     * const count = await prisma.executiveAlert.count({
     *   where: {
     *     // ... the filter for the ExecutiveAlerts we want to count
     *   }
     * })
    **/
    count<T extends ExecutiveAlertCountArgs>(
      args?: Subset<T, ExecutiveAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutiveAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExecutiveAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutiveAlertAggregateArgs>(args: Subset<T, ExecutiveAlertAggregateArgs>): Prisma.PrismaPromise<GetExecutiveAlertAggregateType<T>>

    /**
     * Group by ExecutiveAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutiveAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutiveAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutiveAlertGroupByArgs['orderBy'] }
        : { orderBy?: ExecutiveAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutiveAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutiveAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExecutiveAlert model
   */
  readonly fields: ExecutiveAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExecutiveAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutiveAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExecutiveAlert model
   */
  interface ExecutiveAlertFieldRefs {
    readonly id: FieldRef<"ExecutiveAlert", 'String'>
    readonly severity: FieldRef<"ExecutiveAlert", 'String'>
    readonly type: FieldRef<"ExecutiveAlert", 'String'>
    readonly category: FieldRef<"ExecutiveAlert", 'String'>
    readonly title: FieldRef<"ExecutiveAlert", 'String'>
    readonly description: FieldRef<"ExecutiveAlert", 'String'>
    readonly impact: FieldRef<"ExecutiveAlert", 'String'>
    readonly action: FieldRef<"ExecutiveAlert", 'String'>
    readonly source: FieldRef<"ExecutiveAlert", 'String'>
    readonly metrics: FieldRef<"ExecutiveAlert", 'Json'>
    readonly isActive: FieldRef<"ExecutiveAlert", 'Boolean'>
    readonly isDismissed: FieldRef<"ExecutiveAlert", 'Boolean'>
    readonly dismissedBy: FieldRef<"ExecutiveAlert", 'String'>
    readonly dismissedAt: FieldRef<"ExecutiveAlert", 'DateTime'>
    readonly expiresAt: FieldRef<"ExecutiveAlert", 'DateTime'>
    readonly createdAt: FieldRef<"ExecutiveAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"ExecutiveAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExecutiveAlert findUnique
   */
  export type ExecutiveAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveAlert to fetch.
     */
    where: ExecutiveAlertWhereUniqueInput
  }

  /**
   * ExecutiveAlert findUniqueOrThrow
   */
  export type ExecutiveAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveAlert to fetch.
     */
    where: ExecutiveAlertWhereUniqueInput
  }

  /**
   * ExecutiveAlert findFirst
   */
  export type ExecutiveAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveAlert to fetch.
     */
    where?: ExecutiveAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutiveAlerts to fetch.
     */
    orderBy?: ExecutiveAlertOrderByWithRelationInput | ExecutiveAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutiveAlerts.
     */
    cursor?: ExecutiveAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutiveAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutiveAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutiveAlerts.
     */
    distinct?: ExecutiveAlertScalarFieldEnum | ExecutiveAlertScalarFieldEnum[]
  }

  /**
   * ExecutiveAlert findFirstOrThrow
   */
  export type ExecutiveAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveAlert to fetch.
     */
    where?: ExecutiveAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutiveAlerts to fetch.
     */
    orderBy?: ExecutiveAlertOrderByWithRelationInput | ExecutiveAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutiveAlerts.
     */
    cursor?: ExecutiveAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutiveAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutiveAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutiveAlerts.
     */
    distinct?: ExecutiveAlertScalarFieldEnum | ExecutiveAlertScalarFieldEnum[]
  }

  /**
   * ExecutiveAlert findMany
   */
  export type ExecutiveAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * Filter, which ExecutiveAlerts to fetch.
     */
    where?: ExecutiveAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutiveAlerts to fetch.
     */
    orderBy?: ExecutiveAlertOrderByWithRelationInput | ExecutiveAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExecutiveAlerts.
     */
    cursor?: ExecutiveAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutiveAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutiveAlerts.
     */
    skip?: number
    distinct?: ExecutiveAlertScalarFieldEnum | ExecutiveAlertScalarFieldEnum[]
  }

  /**
   * ExecutiveAlert create
   */
  export type ExecutiveAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * The data needed to create a ExecutiveAlert.
     */
    data: XOR<ExecutiveAlertCreateInput, ExecutiveAlertUncheckedCreateInput>
  }

  /**
   * ExecutiveAlert createMany
   */
  export type ExecutiveAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExecutiveAlerts.
     */
    data: ExecutiveAlertCreateManyInput | ExecutiveAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutiveAlert createManyAndReturn
   */
  export type ExecutiveAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * The data used to create many ExecutiveAlerts.
     */
    data: ExecutiveAlertCreateManyInput | ExecutiveAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutiveAlert update
   */
  export type ExecutiveAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * The data needed to update a ExecutiveAlert.
     */
    data: XOR<ExecutiveAlertUpdateInput, ExecutiveAlertUncheckedUpdateInput>
    /**
     * Choose, which ExecutiveAlert to update.
     */
    where: ExecutiveAlertWhereUniqueInput
  }

  /**
   * ExecutiveAlert updateMany
   */
  export type ExecutiveAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExecutiveAlerts.
     */
    data: XOR<ExecutiveAlertUpdateManyMutationInput, ExecutiveAlertUncheckedUpdateManyInput>
    /**
     * Filter which ExecutiveAlerts to update
     */
    where?: ExecutiveAlertWhereInput
    /**
     * Limit how many ExecutiveAlerts to update.
     */
    limit?: number
  }

  /**
   * ExecutiveAlert updateManyAndReturn
   */
  export type ExecutiveAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * The data used to update ExecutiveAlerts.
     */
    data: XOR<ExecutiveAlertUpdateManyMutationInput, ExecutiveAlertUncheckedUpdateManyInput>
    /**
     * Filter which ExecutiveAlerts to update
     */
    where?: ExecutiveAlertWhereInput
    /**
     * Limit how many ExecutiveAlerts to update.
     */
    limit?: number
  }

  /**
   * ExecutiveAlert upsert
   */
  export type ExecutiveAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * The filter to search for the ExecutiveAlert to update in case it exists.
     */
    where: ExecutiveAlertWhereUniqueInput
    /**
     * In case the ExecutiveAlert found by the `where` argument doesn't exist, create a new ExecutiveAlert with this data.
     */
    create: XOR<ExecutiveAlertCreateInput, ExecutiveAlertUncheckedCreateInput>
    /**
     * In case the ExecutiveAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutiveAlertUpdateInput, ExecutiveAlertUncheckedUpdateInput>
  }

  /**
   * ExecutiveAlert delete
   */
  export type ExecutiveAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
    /**
     * Filter which ExecutiveAlert to delete.
     */
    where: ExecutiveAlertWhereUniqueInput
  }

  /**
   * ExecutiveAlert deleteMany
   */
  export type ExecutiveAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutiveAlerts to delete
     */
    where?: ExecutiveAlertWhereInput
    /**
     * Limit how many ExecutiveAlerts to delete.
     */
    limit?: number
  }

  /**
   * ExecutiveAlert without action
   */
  export type ExecutiveAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutiveAlert
     */
    select?: ExecutiveAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutiveAlert
     */
    omit?: ExecutiveAlertOmit<ExtArgs> | null
  }


  /**
   * Model EnterpriseCashCoverage
   */

  export type AggregateEnterpriseCashCoverage = {
    _count: EnterpriseCashCoverageCountAggregateOutputType | null
    _avg: EnterpriseCashCoverageAvgAggregateOutputType | null
    _sum: EnterpriseCashCoverageSumAggregateOutputType | null
    _min: EnterpriseCashCoverageMinAggregateOutputType | null
    _max: EnterpriseCashCoverageMaxAggregateOutputType | null
  }

  export type EnterpriseCashCoverageAvgAggregateOutputType = {
    startingCash: number | null
    endingCash: number | null
    salesRevenue: number | null
    subscriptionRevenue: number | null
    serviceRevenue: number | null
    otherRevenue: number | null
    totalRevenue: number | null
    payrollExpenses: number | null
    rentExpenses: number | null
    utilitiesExpenses: number | null
    marketingExpenses: number | null
    suppliesExpenses: number | null
    maintenanceExpenses: number | null
    insuranceExpenses: number | null
    professionalFees: number | null
    otherOperatingExpenses: number | null
    totalOperatingExpenses: number | null
    capitalExpenses: number | null
    loanPayments: number | null
    taxPayments: number | null
    dividendPayments: number | null
    otherNonOperatingExpenses: number | null
    netCashFlow: number | null
    operatingCashFlow: number | null
    financingCashFlow: number | null
    investingCashFlow: number | null
    cashCoverageRatio: number | null
    quickRatio: number | null
    currentRatio: number | null
    debtServiceCoverageRatio: number | null
    accountsReceivable: number | null
    accountsPayable: number | null
    inventory: number | null
    prepaidExpenses: number | null
    accruedLiabilities: number | null
    daysOfCashOnHand: number | null
    burnRate: number | null
    runwayMonths: number | null
    confidenceScore: number | null
  }

  export type EnterpriseCashCoverageSumAggregateOutputType = {
    startingCash: number | null
    endingCash: number | null
    salesRevenue: number | null
    subscriptionRevenue: number | null
    serviceRevenue: number | null
    otherRevenue: number | null
    totalRevenue: number | null
    payrollExpenses: number | null
    rentExpenses: number | null
    utilitiesExpenses: number | null
    marketingExpenses: number | null
    suppliesExpenses: number | null
    maintenanceExpenses: number | null
    insuranceExpenses: number | null
    professionalFees: number | null
    otherOperatingExpenses: number | null
    totalOperatingExpenses: number | null
    capitalExpenses: number | null
    loanPayments: number | null
    taxPayments: number | null
    dividendPayments: number | null
    otherNonOperatingExpenses: number | null
    netCashFlow: number | null
    operatingCashFlow: number | null
    financingCashFlow: number | null
    investingCashFlow: number | null
    cashCoverageRatio: number | null
    quickRatio: number | null
    currentRatio: number | null
    debtServiceCoverageRatio: number | null
    accountsReceivable: number | null
    accountsPayable: number | null
    inventory: number | null
    prepaidExpenses: number | null
    accruedLiabilities: number | null
    daysOfCashOnHand: number | null
    burnRate: number | null
    runwayMonths: number | null
    confidenceScore: number | null
  }

  export type EnterpriseCashCoverageMinAggregateOutputType = {
    id: string | null
    period: Date | null
    startingCash: number | null
    endingCash: number | null
    salesRevenue: number | null
    subscriptionRevenue: number | null
    serviceRevenue: number | null
    otherRevenue: number | null
    totalRevenue: number | null
    payrollExpenses: number | null
    rentExpenses: number | null
    utilitiesExpenses: number | null
    marketingExpenses: number | null
    suppliesExpenses: number | null
    maintenanceExpenses: number | null
    insuranceExpenses: number | null
    professionalFees: number | null
    otherOperatingExpenses: number | null
    totalOperatingExpenses: number | null
    capitalExpenses: number | null
    loanPayments: number | null
    taxPayments: number | null
    dividendPayments: number | null
    otherNonOperatingExpenses: number | null
    netCashFlow: number | null
    operatingCashFlow: number | null
    financingCashFlow: number | null
    investingCashFlow: number | null
    cashCoverageRatio: number | null
    quickRatio: number | null
    currentRatio: number | null
    debtServiceCoverageRatio: number | null
    accountsReceivable: number | null
    accountsPayable: number | null
    inventory: number | null
    prepaidExpenses: number | null
    accruedLiabilities: number | null
    daysOfCashOnHand: number | null
    burnRate: number | null
    runwayMonths: number | null
    isActual: boolean | null
    isForecast: boolean | null
    confidenceScore: number | null
    dataSource: string | null
    importedFrom: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnterpriseCashCoverageMaxAggregateOutputType = {
    id: string | null
    period: Date | null
    startingCash: number | null
    endingCash: number | null
    salesRevenue: number | null
    subscriptionRevenue: number | null
    serviceRevenue: number | null
    otherRevenue: number | null
    totalRevenue: number | null
    payrollExpenses: number | null
    rentExpenses: number | null
    utilitiesExpenses: number | null
    marketingExpenses: number | null
    suppliesExpenses: number | null
    maintenanceExpenses: number | null
    insuranceExpenses: number | null
    professionalFees: number | null
    otherOperatingExpenses: number | null
    totalOperatingExpenses: number | null
    capitalExpenses: number | null
    loanPayments: number | null
    taxPayments: number | null
    dividendPayments: number | null
    otherNonOperatingExpenses: number | null
    netCashFlow: number | null
    operatingCashFlow: number | null
    financingCashFlow: number | null
    investingCashFlow: number | null
    cashCoverageRatio: number | null
    quickRatio: number | null
    currentRatio: number | null
    debtServiceCoverageRatio: number | null
    accountsReceivable: number | null
    accountsPayable: number | null
    inventory: number | null
    prepaidExpenses: number | null
    accruedLiabilities: number | null
    daysOfCashOnHand: number | null
    burnRate: number | null
    runwayMonths: number | null
    isActual: boolean | null
    isForecast: boolean | null
    confidenceScore: number | null
    dataSource: string | null
    importedFrom: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnterpriseCashCoverageCountAggregateOutputType = {
    id: number
    period: number
    startingCash: number
    endingCash: number
    salesRevenue: number
    subscriptionRevenue: number
    serviceRevenue: number
    otherRevenue: number
    totalRevenue: number
    payrollExpenses: number
    rentExpenses: number
    utilitiesExpenses: number
    marketingExpenses: number
    suppliesExpenses: number
    maintenanceExpenses: number
    insuranceExpenses: number
    professionalFees: number
    otherOperatingExpenses: number
    totalOperatingExpenses: number
    capitalExpenses: number
    loanPayments: number
    taxPayments: number
    dividendPayments: number
    otherNonOperatingExpenses: number
    netCashFlow: number
    operatingCashFlow: number
    financingCashFlow: number
    investingCashFlow: number
    cashCoverageRatio: number
    quickRatio: number
    currentRatio: number
    debtServiceCoverageRatio: number
    accountsReceivable: number
    accountsPayable: number
    inventory: number
    prepaidExpenses: number
    accruedLiabilities: number
    daysOfCashOnHand: number
    burnRate: number
    runwayMonths: number
    isActual: number
    isForecast: number
    confidenceScore: number
    dataSource: number
    importedFrom: number
    notes: number
    adjustments: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnterpriseCashCoverageAvgAggregateInputType = {
    startingCash?: true
    endingCash?: true
    salesRevenue?: true
    subscriptionRevenue?: true
    serviceRevenue?: true
    otherRevenue?: true
    totalRevenue?: true
    payrollExpenses?: true
    rentExpenses?: true
    utilitiesExpenses?: true
    marketingExpenses?: true
    suppliesExpenses?: true
    maintenanceExpenses?: true
    insuranceExpenses?: true
    professionalFees?: true
    otherOperatingExpenses?: true
    totalOperatingExpenses?: true
    capitalExpenses?: true
    loanPayments?: true
    taxPayments?: true
    dividendPayments?: true
    otherNonOperatingExpenses?: true
    netCashFlow?: true
    operatingCashFlow?: true
    financingCashFlow?: true
    investingCashFlow?: true
    cashCoverageRatio?: true
    quickRatio?: true
    currentRatio?: true
    debtServiceCoverageRatio?: true
    accountsReceivable?: true
    accountsPayable?: true
    inventory?: true
    prepaidExpenses?: true
    accruedLiabilities?: true
    daysOfCashOnHand?: true
    burnRate?: true
    runwayMonths?: true
    confidenceScore?: true
  }

  export type EnterpriseCashCoverageSumAggregateInputType = {
    startingCash?: true
    endingCash?: true
    salesRevenue?: true
    subscriptionRevenue?: true
    serviceRevenue?: true
    otherRevenue?: true
    totalRevenue?: true
    payrollExpenses?: true
    rentExpenses?: true
    utilitiesExpenses?: true
    marketingExpenses?: true
    suppliesExpenses?: true
    maintenanceExpenses?: true
    insuranceExpenses?: true
    professionalFees?: true
    otherOperatingExpenses?: true
    totalOperatingExpenses?: true
    capitalExpenses?: true
    loanPayments?: true
    taxPayments?: true
    dividendPayments?: true
    otherNonOperatingExpenses?: true
    netCashFlow?: true
    operatingCashFlow?: true
    financingCashFlow?: true
    investingCashFlow?: true
    cashCoverageRatio?: true
    quickRatio?: true
    currentRatio?: true
    debtServiceCoverageRatio?: true
    accountsReceivable?: true
    accountsPayable?: true
    inventory?: true
    prepaidExpenses?: true
    accruedLiabilities?: true
    daysOfCashOnHand?: true
    burnRate?: true
    runwayMonths?: true
    confidenceScore?: true
  }

  export type EnterpriseCashCoverageMinAggregateInputType = {
    id?: true
    period?: true
    startingCash?: true
    endingCash?: true
    salesRevenue?: true
    subscriptionRevenue?: true
    serviceRevenue?: true
    otherRevenue?: true
    totalRevenue?: true
    payrollExpenses?: true
    rentExpenses?: true
    utilitiesExpenses?: true
    marketingExpenses?: true
    suppliesExpenses?: true
    maintenanceExpenses?: true
    insuranceExpenses?: true
    professionalFees?: true
    otherOperatingExpenses?: true
    totalOperatingExpenses?: true
    capitalExpenses?: true
    loanPayments?: true
    taxPayments?: true
    dividendPayments?: true
    otherNonOperatingExpenses?: true
    netCashFlow?: true
    operatingCashFlow?: true
    financingCashFlow?: true
    investingCashFlow?: true
    cashCoverageRatio?: true
    quickRatio?: true
    currentRatio?: true
    debtServiceCoverageRatio?: true
    accountsReceivable?: true
    accountsPayable?: true
    inventory?: true
    prepaidExpenses?: true
    accruedLiabilities?: true
    daysOfCashOnHand?: true
    burnRate?: true
    runwayMonths?: true
    isActual?: true
    isForecast?: true
    confidenceScore?: true
    dataSource?: true
    importedFrom?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnterpriseCashCoverageMaxAggregateInputType = {
    id?: true
    period?: true
    startingCash?: true
    endingCash?: true
    salesRevenue?: true
    subscriptionRevenue?: true
    serviceRevenue?: true
    otherRevenue?: true
    totalRevenue?: true
    payrollExpenses?: true
    rentExpenses?: true
    utilitiesExpenses?: true
    marketingExpenses?: true
    suppliesExpenses?: true
    maintenanceExpenses?: true
    insuranceExpenses?: true
    professionalFees?: true
    otherOperatingExpenses?: true
    totalOperatingExpenses?: true
    capitalExpenses?: true
    loanPayments?: true
    taxPayments?: true
    dividendPayments?: true
    otherNonOperatingExpenses?: true
    netCashFlow?: true
    operatingCashFlow?: true
    financingCashFlow?: true
    investingCashFlow?: true
    cashCoverageRatio?: true
    quickRatio?: true
    currentRatio?: true
    debtServiceCoverageRatio?: true
    accountsReceivable?: true
    accountsPayable?: true
    inventory?: true
    prepaidExpenses?: true
    accruedLiabilities?: true
    daysOfCashOnHand?: true
    burnRate?: true
    runwayMonths?: true
    isActual?: true
    isForecast?: true
    confidenceScore?: true
    dataSource?: true
    importedFrom?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnterpriseCashCoverageCountAggregateInputType = {
    id?: true
    period?: true
    startingCash?: true
    endingCash?: true
    salesRevenue?: true
    subscriptionRevenue?: true
    serviceRevenue?: true
    otherRevenue?: true
    totalRevenue?: true
    payrollExpenses?: true
    rentExpenses?: true
    utilitiesExpenses?: true
    marketingExpenses?: true
    suppliesExpenses?: true
    maintenanceExpenses?: true
    insuranceExpenses?: true
    professionalFees?: true
    otherOperatingExpenses?: true
    totalOperatingExpenses?: true
    capitalExpenses?: true
    loanPayments?: true
    taxPayments?: true
    dividendPayments?: true
    otherNonOperatingExpenses?: true
    netCashFlow?: true
    operatingCashFlow?: true
    financingCashFlow?: true
    investingCashFlow?: true
    cashCoverageRatio?: true
    quickRatio?: true
    currentRatio?: true
    debtServiceCoverageRatio?: true
    accountsReceivable?: true
    accountsPayable?: true
    inventory?: true
    prepaidExpenses?: true
    accruedLiabilities?: true
    daysOfCashOnHand?: true
    burnRate?: true
    runwayMonths?: true
    isActual?: true
    isForecast?: true
    confidenceScore?: true
    dataSource?: true
    importedFrom?: true
    notes?: true
    adjustments?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnterpriseCashCoverageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnterpriseCashCoverage to aggregate.
     */
    where?: EnterpriseCashCoverageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseCashCoverages to fetch.
     */
    orderBy?: EnterpriseCashCoverageOrderByWithRelationInput | EnterpriseCashCoverageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnterpriseCashCoverageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseCashCoverages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseCashCoverages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnterpriseCashCoverages
    **/
    _count?: true | EnterpriseCashCoverageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnterpriseCashCoverageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnterpriseCashCoverageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnterpriseCashCoverageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnterpriseCashCoverageMaxAggregateInputType
  }

  export type GetEnterpriseCashCoverageAggregateType<T extends EnterpriseCashCoverageAggregateArgs> = {
        [P in keyof T & keyof AggregateEnterpriseCashCoverage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnterpriseCashCoverage[P]>
      : GetScalarType<T[P], AggregateEnterpriseCashCoverage[P]>
  }




  export type EnterpriseCashCoverageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnterpriseCashCoverageWhereInput
    orderBy?: EnterpriseCashCoverageOrderByWithAggregationInput | EnterpriseCashCoverageOrderByWithAggregationInput[]
    by: EnterpriseCashCoverageScalarFieldEnum[] | EnterpriseCashCoverageScalarFieldEnum
    having?: EnterpriseCashCoverageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnterpriseCashCoverageCountAggregateInputType | true
    _avg?: EnterpriseCashCoverageAvgAggregateInputType
    _sum?: EnterpriseCashCoverageSumAggregateInputType
    _min?: EnterpriseCashCoverageMinAggregateInputType
    _max?: EnterpriseCashCoverageMaxAggregateInputType
  }

  export type EnterpriseCashCoverageGroupByOutputType = {
    id: string
    period: Date
    startingCash: number
    endingCash: number
    salesRevenue: number
    subscriptionRevenue: number
    serviceRevenue: number
    otherRevenue: number
    totalRevenue: number
    payrollExpenses: number
    rentExpenses: number
    utilitiesExpenses: number
    marketingExpenses: number
    suppliesExpenses: number
    maintenanceExpenses: number
    insuranceExpenses: number
    professionalFees: number
    otherOperatingExpenses: number
    totalOperatingExpenses: number
    capitalExpenses: number
    loanPayments: number
    taxPayments: number
    dividendPayments: number
    otherNonOperatingExpenses: number
    netCashFlow: number
    operatingCashFlow: number
    financingCashFlow: number
    investingCashFlow: number
    cashCoverageRatio: number
    quickRatio: number
    currentRatio: number
    debtServiceCoverageRatio: number
    accountsReceivable: number
    accountsPayable: number
    inventory: number
    prepaidExpenses: number
    accruedLiabilities: number
    daysOfCashOnHand: number
    burnRate: number
    runwayMonths: number
    isActual: boolean
    isForecast: boolean
    confidenceScore: number
    dataSource: string
    importedFrom: string | null
    notes: string | null
    adjustments: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: EnterpriseCashCoverageCountAggregateOutputType | null
    _avg: EnterpriseCashCoverageAvgAggregateOutputType | null
    _sum: EnterpriseCashCoverageSumAggregateOutputType | null
    _min: EnterpriseCashCoverageMinAggregateOutputType | null
    _max: EnterpriseCashCoverageMaxAggregateOutputType | null
  }

  type GetEnterpriseCashCoverageGroupByPayload<T extends EnterpriseCashCoverageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnterpriseCashCoverageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnterpriseCashCoverageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnterpriseCashCoverageGroupByOutputType[P]>
            : GetScalarType<T[P], EnterpriseCashCoverageGroupByOutputType[P]>
        }
      >
    >


  export type EnterpriseCashCoverageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    startingCash?: boolean
    endingCash?: boolean
    salesRevenue?: boolean
    subscriptionRevenue?: boolean
    serviceRevenue?: boolean
    otherRevenue?: boolean
    totalRevenue?: boolean
    payrollExpenses?: boolean
    rentExpenses?: boolean
    utilitiesExpenses?: boolean
    marketingExpenses?: boolean
    suppliesExpenses?: boolean
    maintenanceExpenses?: boolean
    insuranceExpenses?: boolean
    professionalFees?: boolean
    otherOperatingExpenses?: boolean
    totalOperatingExpenses?: boolean
    capitalExpenses?: boolean
    loanPayments?: boolean
    taxPayments?: boolean
    dividendPayments?: boolean
    otherNonOperatingExpenses?: boolean
    netCashFlow?: boolean
    operatingCashFlow?: boolean
    financingCashFlow?: boolean
    investingCashFlow?: boolean
    cashCoverageRatio?: boolean
    quickRatio?: boolean
    currentRatio?: boolean
    debtServiceCoverageRatio?: boolean
    accountsReceivable?: boolean
    accountsPayable?: boolean
    inventory?: boolean
    prepaidExpenses?: boolean
    accruedLiabilities?: boolean
    daysOfCashOnHand?: boolean
    burnRate?: boolean
    runwayMonths?: boolean
    isActual?: boolean
    isForecast?: boolean
    confidenceScore?: boolean
    dataSource?: boolean
    importedFrom?: boolean
    notes?: boolean
    adjustments?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["enterpriseCashCoverage"]>

  export type EnterpriseCashCoverageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    startingCash?: boolean
    endingCash?: boolean
    salesRevenue?: boolean
    subscriptionRevenue?: boolean
    serviceRevenue?: boolean
    otherRevenue?: boolean
    totalRevenue?: boolean
    payrollExpenses?: boolean
    rentExpenses?: boolean
    utilitiesExpenses?: boolean
    marketingExpenses?: boolean
    suppliesExpenses?: boolean
    maintenanceExpenses?: boolean
    insuranceExpenses?: boolean
    professionalFees?: boolean
    otherOperatingExpenses?: boolean
    totalOperatingExpenses?: boolean
    capitalExpenses?: boolean
    loanPayments?: boolean
    taxPayments?: boolean
    dividendPayments?: boolean
    otherNonOperatingExpenses?: boolean
    netCashFlow?: boolean
    operatingCashFlow?: boolean
    financingCashFlow?: boolean
    investingCashFlow?: boolean
    cashCoverageRatio?: boolean
    quickRatio?: boolean
    currentRatio?: boolean
    debtServiceCoverageRatio?: boolean
    accountsReceivable?: boolean
    accountsPayable?: boolean
    inventory?: boolean
    prepaidExpenses?: boolean
    accruedLiabilities?: boolean
    daysOfCashOnHand?: boolean
    burnRate?: boolean
    runwayMonths?: boolean
    isActual?: boolean
    isForecast?: boolean
    confidenceScore?: boolean
    dataSource?: boolean
    importedFrom?: boolean
    notes?: boolean
    adjustments?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["enterpriseCashCoverage"]>

  export type EnterpriseCashCoverageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    startingCash?: boolean
    endingCash?: boolean
    salesRevenue?: boolean
    subscriptionRevenue?: boolean
    serviceRevenue?: boolean
    otherRevenue?: boolean
    totalRevenue?: boolean
    payrollExpenses?: boolean
    rentExpenses?: boolean
    utilitiesExpenses?: boolean
    marketingExpenses?: boolean
    suppliesExpenses?: boolean
    maintenanceExpenses?: boolean
    insuranceExpenses?: boolean
    professionalFees?: boolean
    otherOperatingExpenses?: boolean
    totalOperatingExpenses?: boolean
    capitalExpenses?: boolean
    loanPayments?: boolean
    taxPayments?: boolean
    dividendPayments?: boolean
    otherNonOperatingExpenses?: boolean
    netCashFlow?: boolean
    operatingCashFlow?: boolean
    financingCashFlow?: boolean
    investingCashFlow?: boolean
    cashCoverageRatio?: boolean
    quickRatio?: boolean
    currentRatio?: boolean
    debtServiceCoverageRatio?: boolean
    accountsReceivable?: boolean
    accountsPayable?: boolean
    inventory?: boolean
    prepaidExpenses?: boolean
    accruedLiabilities?: boolean
    daysOfCashOnHand?: boolean
    burnRate?: boolean
    runwayMonths?: boolean
    isActual?: boolean
    isForecast?: boolean
    confidenceScore?: boolean
    dataSource?: boolean
    importedFrom?: boolean
    notes?: boolean
    adjustments?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["enterpriseCashCoverage"]>

  export type EnterpriseCashCoverageSelectScalar = {
    id?: boolean
    period?: boolean
    startingCash?: boolean
    endingCash?: boolean
    salesRevenue?: boolean
    subscriptionRevenue?: boolean
    serviceRevenue?: boolean
    otherRevenue?: boolean
    totalRevenue?: boolean
    payrollExpenses?: boolean
    rentExpenses?: boolean
    utilitiesExpenses?: boolean
    marketingExpenses?: boolean
    suppliesExpenses?: boolean
    maintenanceExpenses?: boolean
    insuranceExpenses?: boolean
    professionalFees?: boolean
    otherOperatingExpenses?: boolean
    totalOperatingExpenses?: boolean
    capitalExpenses?: boolean
    loanPayments?: boolean
    taxPayments?: boolean
    dividendPayments?: boolean
    otherNonOperatingExpenses?: boolean
    netCashFlow?: boolean
    operatingCashFlow?: boolean
    financingCashFlow?: boolean
    investingCashFlow?: boolean
    cashCoverageRatio?: boolean
    quickRatio?: boolean
    currentRatio?: boolean
    debtServiceCoverageRatio?: boolean
    accountsReceivable?: boolean
    accountsPayable?: boolean
    inventory?: boolean
    prepaidExpenses?: boolean
    accruedLiabilities?: boolean
    daysOfCashOnHand?: boolean
    burnRate?: boolean
    runwayMonths?: boolean
    isActual?: boolean
    isForecast?: boolean
    confidenceScore?: boolean
    dataSource?: boolean
    importedFrom?: boolean
    notes?: boolean
    adjustments?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnterpriseCashCoverageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "period" | "startingCash" | "endingCash" | "salesRevenue" | "subscriptionRevenue" | "serviceRevenue" | "otherRevenue" | "totalRevenue" | "payrollExpenses" | "rentExpenses" | "utilitiesExpenses" | "marketingExpenses" | "suppliesExpenses" | "maintenanceExpenses" | "insuranceExpenses" | "professionalFees" | "otherOperatingExpenses" | "totalOperatingExpenses" | "capitalExpenses" | "loanPayments" | "taxPayments" | "dividendPayments" | "otherNonOperatingExpenses" | "netCashFlow" | "operatingCashFlow" | "financingCashFlow" | "investingCashFlow" | "cashCoverageRatio" | "quickRatio" | "currentRatio" | "debtServiceCoverageRatio" | "accountsReceivable" | "accountsPayable" | "inventory" | "prepaidExpenses" | "accruedLiabilities" | "daysOfCashOnHand" | "burnRate" | "runwayMonths" | "isActual" | "isForecast" | "confidenceScore" | "dataSource" | "importedFrom" | "notes" | "adjustments" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["enterpriseCashCoverage"]>

  export type $EnterpriseCashCoveragePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnterpriseCashCoverage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      period: Date
      startingCash: number
      endingCash: number
      salesRevenue: number
      subscriptionRevenue: number
      serviceRevenue: number
      otherRevenue: number
      totalRevenue: number
      payrollExpenses: number
      rentExpenses: number
      utilitiesExpenses: number
      marketingExpenses: number
      suppliesExpenses: number
      maintenanceExpenses: number
      insuranceExpenses: number
      professionalFees: number
      otherOperatingExpenses: number
      totalOperatingExpenses: number
      capitalExpenses: number
      loanPayments: number
      taxPayments: number
      dividendPayments: number
      otherNonOperatingExpenses: number
      netCashFlow: number
      operatingCashFlow: number
      financingCashFlow: number
      investingCashFlow: number
      cashCoverageRatio: number
      quickRatio: number
      currentRatio: number
      debtServiceCoverageRatio: number
      accountsReceivable: number
      accountsPayable: number
      inventory: number
      prepaidExpenses: number
      accruedLiabilities: number
      daysOfCashOnHand: number
      burnRate: number
      runwayMonths: number
      isActual: boolean
      isForecast: boolean
      confidenceScore: number
      dataSource: string
      importedFrom: string | null
      notes: string | null
      adjustments: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["enterpriseCashCoverage"]>
    composites: {}
  }

  type EnterpriseCashCoverageGetPayload<S extends boolean | null | undefined | EnterpriseCashCoverageDefaultArgs> = $Result.GetResult<Prisma.$EnterpriseCashCoveragePayload, S>

  type EnterpriseCashCoverageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnterpriseCashCoverageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnterpriseCashCoverageCountAggregateInputType | true
    }

  export interface EnterpriseCashCoverageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnterpriseCashCoverage'], meta: { name: 'EnterpriseCashCoverage' } }
    /**
     * Find zero or one EnterpriseCashCoverage that matches the filter.
     * @param {EnterpriseCashCoverageFindUniqueArgs} args - Arguments to find a EnterpriseCashCoverage
     * @example
     * // Get one EnterpriseCashCoverage
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnterpriseCashCoverageFindUniqueArgs>(args: SelectSubset<T, EnterpriseCashCoverageFindUniqueArgs<ExtArgs>>): Prisma__EnterpriseCashCoverageClient<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EnterpriseCashCoverage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnterpriseCashCoverageFindUniqueOrThrowArgs} args - Arguments to find a EnterpriseCashCoverage
     * @example
     * // Get one EnterpriseCashCoverage
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnterpriseCashCoverageFindUniqueOrThrowArgs>(args: SelectSubset<T, EnterpriseCashCoverageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnterpriseCashCoverageClient<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnterpriseCashCoverage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseCashCoverageFindFirstArgs} args - Arguments to find a EnterpriseCashCoverage
     * @example
     * // Get one EnterpriseCashCoverage
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnterpriseCashCoverageFindFirstArgs>(args?: SelectSubset<T, EnterpriseCashCoverageFindFirstArgs<ExtArgs>>): Prisma__EnterpriseCashCoverageClient<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnterpriseCashCoverage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseCashCoverageFindFirstOrThrowArgs} args - Arguments to find a EnterpriseCashCoverage
     * @example
     * // Get one EnterpriseCashCoverage
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnterpriseCashCoverageFindFirstOrThrowArgs>(args?: SelectSubset<T, EnterpriseCashCoverageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnterpriseCashCoverageClient<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EnterpriseCashCoverages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseCashCoverageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnterpriseCashCoverages
     * const enterpriseCashCoverages = await prisma.enterpriseCashCoverage.findMany()
     * 
     * // Get first 10 EnterpriseCashCoverages
     * const enterpriseCashCoverages = await prisma.enterpriseCashCoverage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enterpriseCashCoverageWithIdOnly = await prisma.enterpriseCashCoverage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnterpriseCashCoverageFindManyArgs>(args?: SelectSubset<T, EnterpriseCashCoverageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EnterpriseCashCoverage.
     * @param {EnterpriseCashCoverageCreateArgs} args - Arguments to create a EnterpriseCashCoverage.
     * @example
     * // Create one EnterpriseCashCoverage
     * const EnterpriseCashCoverage = await prisma.enterpriseCashCoverage.create({
     *   data: {
     *     // ... data to create a EnterpriseCashCoverage
     *   }
     * })
     * 
     */
    create<T extends EnterpriseCashCoverageCreateArgs>(args: SelectSubset<T, EnterpriseCashCoverageCreateArgs<ExtArgs>>): Prisma__EnterpriseCashCoverageClient<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EnterpriseCashCoverages.
     * @param {EnterpriseCashCoverageCreateManyArgs} args - Arguments to create many EnterpriseCashCoverages.
     * @example
     * // Create many EnterpriseCashCoverages
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnterpriseCashCoverageCreateManyArgs>(args?: SelectSubset<T, EnterpriseCashCoverageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnterpriseCashCoverages and returns the data saved in the database.
     * @param {EnterpriseCashCoverageCreateManyAndReturnArgs} args - Arguments to create many EnterpriseCashCoverages.
     * @example
     * // Create many EnterpriseCashCoverages
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnterpriseCashCoverages and only return the `id`
     * const enterpriseCashCoverageWithIdOnly = await prisma.enterpriseCashCoverage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnterpriseCashCoverageCreateManyAndReturnArgs>(args?: SelectSubset<T, EnterpriseCashCoverageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EnterpriseCashCoverage.
     * @param {EnterpriseCashCoverageDeleteArgs} args - Arguments to delete one EnterpriseCashCoverage.
     * @example
     * // Delete one EnterpriseCashCoverage
     * const EnterpriseCashCoverage = await prisma.enterpriseCashCoverage.delete({
     *   where: {
     *     // ... filter to delete one EnterpriseCashCoverage
     *   }
     * })
     * 
     */
    delete<T extends EnterpriseCashCoverageDeleteArgs>(args: SelectSubset<T, EnterpriseCashCoverageDeleteArgs<ExtArgs>>): Prisma__EnterpriseCashCoverageClient<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EnterpriseCashCoverage.
     * @param {EnterpriseCashCoverageUpdateArgs} args - Arguments to update one EnterpriseCashCoverage.
     * @example
     * // Update one EnterpriseCashCoverage
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnterpriseCashCoverageUpdateArgs>(args: SelectSubset<T, EnterpriseCashCoverageUpdateArgs<ExtArgs>>): Prisma__EnterpriseCashCoverageClient<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EnterpriseCashCoverages.
     * @param {EnterpriseCashCoverageDeleteManyArgs} args - Arguments to filter EnterpriseCashCoverages to delete.
     * @example
     * // Delete a few EnterpriseCashCoverages
     * const { count } = await prisma.enterpriseCashCoverage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnterpriseCashCoverageDeleteManyArgs>(args?: SelectSubset<T, EnterpriseCashCoverageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnterpriseCashCoverages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseCashCoverageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnterpriseCashCoverages
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnterpriseCashCoverageUpdateManyArgs>(args: SelectSubset<T, EnterpriseCashCoverageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnterpriseCashCoverages and returns the data updated in the database.
     * @param {EnterpriseCashCoverageUpdateManyAndReturnArgs} args - Arguments to update many EnterpriseCashCoverages.
     * @example
     * // Update many EnterpriseCashCoverages
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnterpriseCashCoverages and only return the `id`
     * const enterpriseCashCoverageWithIdOnly = await prisma.enterpriseCashCoverage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnterpriseCashCoverageUpdateManyAndReturnArgs>(args: SelectSubset<T, EnterpriseCashCoverageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EnterpriseCashCoverage.
     * @param {EnterpriseCashCoverageUpsertArgs} args - Arguments to update or create a EnterpriseCashCoverage.
     * @example
     * // Update or create a EnterpriseCashCoverage
     * const enterpriseCashCoverage = await prisma.enterpriseCashCoverage.upsert({
     *   create: {
     *     // ... data to create a EnterpriseCashCoverage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnterpriseCashCoverage we want to update
     *   }
     * })
     */
    upsert<T extends EnterpriseCashCoverageUpsertArgs>(args: SelectSubset<T, EnterpriseCashCoverageUpsertArgs<ExtArgs>>): Prisma__EnterpriseCashCoverageClient<$Result.GetResult<Prisma.$EnterpriseCashCoveragePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EnterpriseCashCoverages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseCashCoverageCountArgs} args - Arguments to filter EnterpriseCashCoverages to count.
     * @example
     * // Count the number of EnterpriseCashCoverages
     * const count = await prisma.enterpriseCashCoverage.count({
     *   where: {
     *     // ... the filter for the EnterpriseCashCoverages we want to count
     *   }
     * })
    **/
    count<T extends EnterpriseCashCoverageCountArgs>(
      args?: Subset<T, EnterpriseCashCoverageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnterpriseCashCoverageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnterpriseCashCoverage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseCashCoverageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnterpriseCashCoverageAggregateArgs>(args: Subset<T, EnterpriseCashCoverageAggregateArgs>): Prisma.PrismaPromise<GetEnterpriseCashCoverageAggregateType<T>>

    /**
     * Group by EnterpriseCashCoverage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnterpriseCashCoverageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnterpriseCashCoverageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnterpriseCashCoverageGroupByArgs['orderBy'] }
        : { orderBy?: EnterpriseCashCoverageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnterpriseCashCoverageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnterpriseCashCoverageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnterpriseCashCoverage model
   */
  readonly fields: EnterpriseCashCoverageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnterpriseCashCoverage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnterpriseCashCoverageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnterpriseCashCoverage model
   */
  interface EnterpriseCashCoverageFieldRefs {
    readonly id: FieldRef<"EnterpriseCashCoverage", 'String'>
    readonly period: FieldRef<"EnterpriseCashCoverage", 'DateTime'>
    readonly startingCash: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly endingCash: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly salesRevenue: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly subscriptionRevenue: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly serviceRevenue: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly otherRevenue: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly totalRevenue: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly payrollExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly rentExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly utilitiesExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly marketingExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly suppliesExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly maintenanceExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly insuranceExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly professionalFees: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly otherOperatingExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly totalOperatingExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly capitalExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly loanPayments: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly taxPayments: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly dividendPayments: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly otherNonOperatingExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly netCashFlow: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly operatingCashFlow: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly financingCashFlow: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly investingCashFlow: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly cashCoverageRatio: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly quickRatio: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly currentRatio: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly debtServiceCoverageRatio: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly accountsReceivable: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly accountsPayable: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly inventory: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly prepaidExpenses: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly accruedLiabilities: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly daysOfCashOnHand: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly burnRate: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly runwayMonths: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly isActual: FieldRef<"EnterpriseCashCoverage", 'Boolean'>
    readonly isForecast: FieldRef<"EnterpriseCashCoverage", 'Boolean'>
    readonly confidenceScore: FieldRef<"EnterpriseCashCoverage", 'Float'>
    readonly dataSource: FieldRef<"EnterpriseCashCoverage", 'String'>
    readonly importedFrom: FieldRef<"EnterpriseCashCoverage", 'String'>
    readonly notes: FieldRef<"EnterpriseCashCoverage", 'String'>
    readonly adjustments: FieldRef<"EnterpriseCashCoverage", 'Json'>
    readonly metadata: FieldRef<"EnterpriseCashCoverage", 'Json'>
    readonly createdAt: FieldRef<"EnterpriseCashCoverage", 'DateTime'>
    readonly updatedAt: FieldRef<"EnterpriseCashCoverage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EnterpriseCashCoverage findUnique
   */
  export type EnterpriseCashCoverageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * Filter, which EnterpriseCashCoverage to fetch.
     */
    where: EnterpriseCashCoverageWhereUniqueInput
  }

  /**
   * EnterpriseCashCoverage findUniqueOrThrow
   */
  export type EnterpriseCashCoverageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * Filter, which EnterpriseCashCoverage to fetch.
     */
    where: EnterpriseCashCoverageWhereUniqueInput
  }

  /**
   * EnterpriseCashCoverage findFirst
   */
  export type EnterpriseCashCoverageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * Filter, which EnterpriseCashCoverage to fetch.
     */
    where?: EnterpriseCashCoverageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseCashCoverages to fetch.
     */
    orderBy?: EnterpriseCashCoverageOrderByWithRelationInput | EnterpriseCashCoverageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnterpriseCashCoverages.
     */
    cursor?: EnterpriseCashCoverageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseCashCoverages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseCashCoverages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnterpriseCashCoverages.
     */
    distinct?: EnterpriseCashCoverageScalarFieldEnum | EnterpriseCashCoverageScalarFieldEnum[]
  }

  /**
   * EnterpriseCashCoverage findFirstOrThrow
   */
  export type EnterpriseCashCoverageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * Filter, which EnterpriseCashCoverage to fetch.
     */
    where?: EnterpriseCashCoverageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseCashCoverages to fetch.
     */
    orderBy?: EnterpriseCashCoverageOrderByWithRelationInput | EnterpriseCashCoverageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnterpriseCashCoverages.
     */
    cursor?: EnterpriseCashCoverageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseCashCoverages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseCashCoverages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnterpriseCashCoverages.
     */
    distinct?: EnterpriseCashCoverageScalarFieldEnum | EnterpriseCashCoverageScalarFieldEnum[]
  }

  /**
   * EnterpriseCashCoverage findMany
   */
  export type EnterpriseCashCoverageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * Filter, which EnterpriseCashCoverages to fetch.
     */
    where?: EnterpriseCashCoverageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnterpriseCashCoverages to fetch.
     */
    orderBy?: EnterpriseCashCoverageOrderByWithRelationInput | EnterpriseCashCoverageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnterpriseCashCoverages.
     */
    cursor?: EnterpriseCashCoverageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnterpriseCashCoverages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnterpriseCashCoverages.
     */
    skip?: number
    distinct?: EnterpriseCashCoverageScalarFieldEnum | EnterpriseCashCoverageScalarFieldEnum[]
  }

  /**
   * EnterpriseCashCoverage create
   */
  export type EnterpriseCashCoverageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * The data needed to create a EnterpriseCashCoverage.
     */
    data: XOR<EnterpriseCashCoverageCreateInput, EnterpriseCashCoverageUncheckedCreateInput>
  }

  /**
   * EnterpriseCashCoverage createMany
   */
  export type EnterpriseCashCoverageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnterpriseCashCoverages.
     */
    data: EnterpriseCashCoverageCreateManyInput | EnterpriseCashCoverageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnterpriseCashCoverage createManyAndReturn
   */
  export type EnterpriseCashCoverageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * The data used to create many EnterpriseCashCoverages.
     */
    data: EnterpriseCashCoverageCreateManyInput | EnterpriseCashCoverageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnterpriseCashCoverage update
   */
  export type EnterpriseCashCoverageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * The data needed to update a EnterpriseCashCoverage.
     */
    data: XOR<EnterpriseCashCoverageUpdateInput, EnterpriseCashCoverageUncheckedUpdateInput>
    /**
     * Choose, which EnterpriseCashCoverage to update.
     */
    where: EnterpriseCashCoverageWhereUniqueInput
  }

  /**
   * EnterpriseCashCoverage updateMany
   */
  export type EnterpriseCashCoverageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnterpriseCashCoverages.
     */
    data: XOR<EnterpriseCashCoverageUpdateManyMutationInput, EnterpriseCashCoverageUncheckedUpdateManyInput>
    /**
     * Filter which EnterpriseCashCoverages to update
     */
    where?: EnterpriseCashCoverageWhereInput
    /**
     * Limit how many EnterpriseCashCoverages to update.
     */
    limit?: number
  }

  /**
   * EnterpriseCashCoverage updateManyAndReturn
   */
  export type EnterpriseCashCoverageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * The data used to update EnterpriseCashCoverages.
     */
    data: XOR<EnterpriseCashCoverageUpdateManyMutationInput, EnterpriseCashCoverageUncheckedUpdateManyInput>
    /**
     * Filter which EnterpriseCashCoverages to update
     */
    where?: EnterpriseCashCoverageWhereInput
    /**
     * Limit how many EnterpriseCashCoverages to update.
     */
    limit?: number
  }

  /**
   * EnterpriseCashCoverage upsert
   */
  export type EnterpriseCashCoverageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * The filter to search for the EnterpriseCashCoverage to update in case it exists.
     */
    where: EnterpriseCashCoverageWhereUniqueInput
    /**
     * In case the EnterpriseCashCoverage found by the `where` argument doesn't exist, create a new EnterpriseCashCoverage with this data.
     */
    create: XOR<EnterpriseCashCoverageCreateInput, EnterpriseCashCoverageUncheckedCreateInput>
    /**
     * In case the EnterpriseCashCoverage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnterpriseCashCoverageUpdateInput, EnterpriseCashCoverageUncheckedUpdateInput>
  }

  /**
   * EnterpriseCashCoverage delete
   */
  export type EnterpriseCashCoverageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
    /**
     * Filter which EnterpriseCashCoverage to delete.
     */
    where: EnterpriseCashCoverageWhereUniqueInput
  }

  /**
   * EnterpriseCashCoverage deleteMany
   */
  export type EnterpriseCashCoverageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnterpriseCashCoverages to delete
     */
    where?: EnterpriseCashCoverageWhereInput
    /**
     * Limit how many EnterpriseCashCoverages to delete.
     */
    limit?: number
  }

  /**
   * EnterpriseCashCoverage without action
   */
  export type EnterpriseCashCoverageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnterpriseCashCoverage
     */
    select?: EnterpriseCashCoverageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnterpriseCashCoverage
     */
    omit?: EnterpriseCashCoverageOmit<ExtArgs> | null
  }


  /**
   * Model XeroAccount
   */

  export type AggregateXeroAccount = {
    _count: XeroAccountCountAggregateOutputType | null
    _min: XeroAccountMinAggregateOutputType | null
    _max: XeroAccountMaxAggregateOutputType | null
  }

  export type XeroAccountMinAggregateOutputType = {
    id: string | null
    xeroId: string | null
    code: string | null
    name: string | null
    type: string | null
    bankAccountNumber: string | null
    status: string | null
    description: string | null
    class: string | null
    systemAccount: string | null
    enablePaymentsToAccount: boolean | null
    showInExpenseClaims: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroAccountMaxAggregateOutputType = {
    id: string | null
    xeroId: string | null
    code: string | null
    name: string | null
    type: string | null
    bankAccountNumber: string | null
    status: string | null
    description: string | null
    class: string | null
    systemAccount: string | null
    enablePaymentsToAccount: boolean | null
    showInExpenseClaims: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroAccountCountAggregateOutputType = {
    id: number
    xeroId: number
    code: number
    name: number
    type: number
    bankAccountNumber: number
    status: number
    description: number
    class: number
    systemAccount: number
    enablePaymentsToAccount: number
    showInExpenseClaims: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XeroAccountMinAggregateInputType = {
    id?: true
    xeroId?: true
    code?: true
    name?: true
    type?: true
    bankAccountNumber?: true
    status?: true
    description?: true
    class?: true
    systemAccount?: true
    enablePaymentsToAccount?: true
    showInExpenseClaims?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroAccountMaxAggregateInputType = {
    id?: true
    xeroId?: true
    code?: true
    name?: true
    type?: true
    bankAccountNumber?: true
    status?: true
    description?: true
    class?: true
    systemAccount?: true
    enablePaymentsToAccount?: true
    showInExpenseClaims?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroAccountCountAggregateInputType = {
    id?: true
    xeroId?: true
    code?: true
    name?: true
    type?: true
    bankAccountNumber?: true
    status?: true
    description?: true
    class?: true
    systemAccount?: true
    enablePaymentsToAccount?: true
    showInExpenseClaims?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XeroAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroAccount to aggregate.
     */
    where?: XeroAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroAccounts to fetch.
     */
    orderBy?: XeroAccountOrderByWithRelationInput | XeroAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XeroAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XeroAccounts
    **/
    _count?: true | XeroAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XeroAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XeroAccountMaxAggregateInputType
  }

  export type GetXeroAccountAggregateType<T extends XeroAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateXeroAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXeroAccount[P]>
      : GetScalarType<T[P], AggregateXeroAccount[P]>
  }




  export type XeroAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroAccountWhereInput
    orderBy?: XeroAccountOrderByWithAggregationInput | XeroAccountOrderByWithAggregationInput[]
    by: XeroAccountScalarFieldEnum[] | XeroAccountScalarFieldEnum
    having?: XeroAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XeroAccountCountAggregateInputType | true
    _min?: XeroAccountMinAggregateInputType
    _max?: XeroAccountMaxAggregateInputType
  }

  export type XeroAccountGroupByOutputType = {
    id: string
    xeroId: string
    code: string | null
    name: string
    type: string
    bankAccountNumber: string | null
    status: string
    description: string | null
    class: string | null
    systemAccount: string | null
    enablePaymentsToAccount: boolean
    showInExpenseClaims: boolean
    createdAt: Date
    updatedAt: Date
    _count: XeroAccountCountAggregateOutputType | null
    _min: XeroAccountMinAggregateOutputType | null
    _max: XeroAccountMaxAggregateOutputType | null
  }

  type GetXeroAccountGroupByPayload<T extends XeroAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XeroAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XeroAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XeroAccountGroupByOutputType[P]>
            : GetScalarType<T[P], XeroAccountGroupByOutputType[P]>
        }
      >
    >


  export type XeroAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    bankAccountNumber?: boolean
    status?: boolean
    description?: boolean
    class?: boolean
    systemAccount?: boolean
    enablePaymentsToAccount?: boolean
    showInExpenseClaims?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroAccount"]>

  export type XeroAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    bankAccountNumber?: boolean
    status?: boolean
    description?: boolean
    class?: boolean
    systemAccount?: boolean
    enablePaymentsToAccount?: boolean
    showInExpenseClaims?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroAccount"]>

  export type XeroAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    bankAccountNumber?: boolean
    status?: boolean
    description?: boolean
    class?: boolean
    systemAccount?: boolean
    enablePaymentsToAccount?: boolean
    showInExpenseClaims?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroAccount"]>

  export type XeroAccountSelectScalar = {
    id?: boolean
    xeroId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    bankAccountNumber?: boolean
    status?: boolean
    description?: boolean
    class?: boolean
    systemAccount?: boolean
    enablePaymentsToAccount?: boolean
    showInExpenseClaims?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XeroAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xeroId" | "code" | "name" | "type" | "bankAccountNumber" | "status" | "description" | "class" | "systemAccount" | "enablePaymentsToAccount" | "showInExpenseClaims" | "createdAt" | "updatedAt", ExtArgs["result"]["xeroAccount"]>

  export type $XeroAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XeroAccount"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      xeroId: string
      code: string | null
      name: string
      type: string
      bankAccountNumber: string | null
      status: string
      description: string | null
      class: string | null
      systemAccount: string | null
      enablePaymentsToAccount: boolean
      showInExpenseClaims: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xeroAccount"]>
    composites: {}
  }

  type XeroAccountGetPayload<S extends boolean | null | undefined | XeroAccountDefaultArgs> = $Result.GetResult<Prisma.$XeroAccountPayload, S>

  type XeroAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XeroAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XeroAccountCountAggregateInputType | true
    }

  export interface XeroAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XeroAccount'], meta: { name: 'XeroAccount' } }
    /**
     * Find zero or one XeroAccount that matches the filter.
     * @param {XeroAccountFindUniqueArgs} args - Arguments to find a XeroAccount
     * @example
     * // Get one XeroAccount
     * const xeroAccount = await prisma.xeroAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XeroAccountFindUniqueArgs>(args: SelectSubset<T, XeroAccountFindUniqueArgs<ExtArgs>>): Prisma__XeroAccountClient<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XeroAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XeroAccountFindUniqueOrThrowArgs} args - Arguments to find a XeroAccount
     * @example
     * // Get one XeroAccount
     * const xeroAccount = await prisma.xeroAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XeroAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, XeroAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XeroAccountClient<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroAccountFindFirstArgs} args - Arguments to find a XeroAccount
     * @example
     * // Get one XeroAccount
     * const xeroAccount = await prisma.xeroAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XeroAccountFindFirstArgs>(args?: SelectSubset<T, XeroAccountFindFirstArgs<ExtArgs>>): Prisma__XeroAccountClient<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroAccountFindFirstOrThrowArgs} args - Arguments to find a XeroAccount
     * @example
     * // Get one XeroAccount
     * const xeroAccount = await prisma.xeroAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XeroAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, XeroAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__XeroAccountClient<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XeroAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XeroAccounts
     * const xeroAccounts = await prisma.xeroAccount.findMany()
     * 
     * // Get first 10 XeroAccounts
     * const xeroAccounts = await prisma.xeroAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xeroAccountWithIdOnly = await prisma.xeroAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XeroAccountFindManyArgs>(args?: SelectSubset<T, XeroAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XeroAccount.
     * @param {XeroAccountCreateArgs} args - Arguments to create a XeroAccount.
     * @example
     * // Create one XeroAccount
     * const XeroAccount = await prisma.xeroAccount.create({
     *   data: {
     *     // ... data to create a XeroAccount
     *   }
     * })
     * 
     */
    create<T extends XeroAccountCreateArgs>(args: SelectSubset<T, XeroAccountCreateArgs<ExtArgs>>): Prisma__XeroAccountClient<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XeroAccounts.
     * @param {XeroAccountCreateManyArgs} args - Arguments to create many XeroAccounts.
     * @example
     * // Create many XeroAccounts
     * const xeroAccount = await prisma.xeroAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XeroAccountCreateManyArgs>(args?: SelectSubset<T, XeroAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XeroAccounts and returns the data saved in the database.
     * @param {XeroAccountCreateManyAndReturnArgs} args - Arguments to create many XeroAccounts.
     * @example
     * // Create many XeroAccounts
     * const xeroAccount = await prisma.xeroAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XeroAccounts and only return the `id`
     * const xeroAccountWithIdOnly = await prisma.xeroAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XeroAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, XeroAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XeroAccount.
     * @param {XeroAccountDeleteArgs} args - Arguments to delete one XeroAccount.
     * @example
     * // Delete one XeroAccount
     * const XeroAccount = await prisma.xeroAccount.delete({
     *   where: {
     *     // ... filter to delete one XeroAccount
     *   }
     * })
     * 
     */
    delete<T extends XeroAccountDeleteArgs>(args: SelectSubset<T, XeroAccountDeleteArgs<ExtArgs>>): Prisma__XeroAccountClient<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XeroAccount.
     * @param {XeroAccountUpdateArgs} args - Arguments to update one XeroAccount.
     * @example
     * // Update one XeroAccount
     * const xeroAccount = await prisma.xeroAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XeroAccountUpdateArgs>(args: SelectSubset<T, XeroAccountUpdateArgs<ExtArgs>>): Prisma__XeroAccountClient<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XeroAccounts.
     * @param {XeroAccountDeleteManyArgs} args - Arguments to filter XeroAccounts to delete.
     * @example
     * // Delete a few XeroAccounts
     * const { count } = await prisma.xeroAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XeroAccountDeleteManyArgs>(args?: SelectSubset<T, XeroAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XeroAccounts
     * const xeroAccount = await prisma.xeroAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XeroAccountUpdateManyArgs>(args: SelectSubset<T, XeroAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroAccounts and returns the data updated in the database.
     * @param {XeroAccountUpdateManyAndReturnArgs} args - Arguments to update many XeroAccounts.
     * @example
     * // Update many XeroAccounts
     * const xeroAccount = await prisma.xeroAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XeroAccounts and only return the `id`
     * const xeroAccountWithIdOnly = await prisma.xeroAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XeroAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, XeroAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XeroAccount.
     * @param {XeroAccountUpsertArgs} args - Arguments to update or create a XeroAccount.
     * @example
     * // Update or create a XeroAccount
     * const xeroAccount = await prisma.xeroAccount.upsert({
     *   create: {
     *     // ... data to create a XeroAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XeroAccount we want to update
     *   }
     * })
     */
    upsert<T extends XeroAccountUpsertArgs>(args: SelectSubset<T, XeroAccountUpsertArgs<ExtArgs>>): Prisma__XeroAccountClient<$Result.GetResult<Prisma.$XeroAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XeroAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroAccountCountArgs} args - Arguments to filter XeroAccounts to count.
     * @example
     * // Count the number of XeroAccounts
     * const count = await prisma.xeroAccount.count({
     *   where: {
     *     // ... the filter for the XeroAccounts we want to count
     *   }
     * })
    **/
    count<T extends XeroAccountCountArgs>(
      args?: Subset<T, XeroAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XeroAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XeroAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XeroAccountAggregateArgs>(args: Subset<T, XeroAccountAggregateArgs>): Prisma.PrismaPromise<GetXeroAccountAggregateType<T>>

    /**
     * Group by XeroAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XeroAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XeroAccountGroupByArgs['orderBy'] }
        : { orderBy?: XeroAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XeroAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXeroAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XeroAccount model
   */
  readonly fields: XeroAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XeroAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XeroAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XeroAccount model
   */
  interface XeroAccountFieldRefs {
    readonly id: FieldRef<"XeroAccount", 'String'>
    readonly xeroId: FieldRef<"XeroAccount", 'String'>
    readonly code: FieldRef<"XeroAccount", 'String'>
    readonly name: FieldRef<"XeroAccount", 'String'>
    readonly type: FieldRef<"XeroAccount", 'String'>
    readonly bankAccountNumber: FieldRef<"XeroAccount", 'String'>
    readonly status: FieldRef<"XeroAccount", 'String'>
    readonly description: FieldRef<"XeroAccount", 'String'>
    readonly class: FieldRef<"XeroAccount", 'String'>
    readonly systemAccount: FieldRef<"XeroAccount", 'String'>
    readonly enablePaymentsToAccount: FieldRef<"XeroAccount", 'Boolean'>
    readonly showInExpenseClaims: FieldRef<"XeroAccount", 'Boolean'>
    readonly createdAt: FieldRef<"XeroAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"XeroAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XeroAccount findUnique
   */
  export type XeroAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * Filter, which XeroAccount to fetch.
     */
    where: XeroAccountWhereUniqueInput
  }

  /**
   * XeroAccount findUniqueOrThrow
   */
  export type XeroAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * Filter, which XeroAccount to fetch.
     */
    where: XeroAccountWhereUniqueInput
  }

  /**
   * XeroAccount findFirst
   */
  export type XeroAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * Filter, which XeroAccount to fetch.
     */
    where?: XeroAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroAccounts to fetch.
     */
    orderBy?: XeroAccountOrderByWithRelationInput | XeroAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroAccounts.
     */
    cursor?: XeroAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroAccounts.
     */
    distinct?: XeroAccountScalarFieldEnum | XeroAccountScalarFieldEnum[]
  }

  /**
   * XeroAccount findFirstOrThrow
   */
  export type XeroAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * Filter, which XeroAccount to fetch.
     */
    where?: XeroAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroAccounts to fetch.
     */
    orderBy?: XeroAccountOrderByWithRelationInput | XeroAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroAccounts.
     */
    cursor?: XeroAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroAccounts.
     */
    distinct?: XeroAccountScalarFieldEnum | XeroAccountScalarFieldEnum[]
  }

  /**
   * XeroAccount findMany
   */
  export type XeroAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * Filter, which XeroAccounts to fetch.
     */
    where?: XeroAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroAccounts to fetch.
     */
    orderBy?: XeroAccountOrderByWithRelationInput | XeroAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XeroAccounts.
     */
    cursor?: XeroAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroAccounts.
     */
    skip?: number
    distinct?: XeroAccountScalarFieldEnum | XeroAccountScalarFieldEnum[]
  }

  /**
   * XeroAccount create
   */
  export type XeroAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * The data needed to create a XeroAccount.
     */
    data: XOR<XeroAccountCreateInput, XeroAccountUncheckedCreateInput>
  }

  /**
   * XeroAccount createMany
   */
  export type XeroAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XeroAccounts.
     */
    data: XeroAccountCreateManyInput | XeroAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroAccount createManyAndReturn
   */
  export type XeroAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * The data used to create many XeroAccounts.
     */
    data: XeroAccountCreateManyInput | XeroAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroAccount update
   */
  export type XeroAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * The data needed to update a XeroAccount.
     */
    data: XOR<XeroAccountUpdateInput, XeroAccountUncheckedUpdateInput>
    /**
     * Choose, which XeroAccount to update.
     */
    where: XeroAccountWhereUniqueInput
  }

  /**
   * XeroAccount updateMany
   */
  export type XeroAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XeroAccounts.
     */
    data: XOR<XeroAccountUpdateManyMutationInput, XeroAccountUncheckedUpdateManyInput>
    /**
     * Filter which XeroAccounts to update
     */
    where?: XeroAccountWhereInput
    /**
     * Limit how many XeroAccounts to update.
     */
    limit?: number
  }

  /**
   * XeroAccount updateManyAndReturn
   */
  export type XeroAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * The data used to update XeroAccounts.
     */
    data: XOR<XeroAccountUpdateManyMutationInput, XeroAccountUncheckedUpdateManyInput>
    /**
     * Filter which XeroAccounts to update
     */
    where?: XeroAccountWhereInput
    /**
     * Limit how many XeroAccounts to update.
     */
    limit?: number
  }

  /**
   * XeroAccount upsert
   */
  export type XeroAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * The filter to search for the XeroAccount to update in case it exists.
     */
    where: XeroAccountWhereUniqueInput
    /**
     * In case the XeroAccount found by the `where` argument doesn't exist, create a new XeroAccount with this data.
     */
    create: XOR<XeroAccountCreateInput, XeroAccountUncheckedCreateInput>
    /**
     * In case the XeroAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XeroAccountUpdateInput, XeroAccountUncheckedUpdateInput>
  }

  /**
   * XeroAccount delete
   */
  export type XeroAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
    /**
     * Filter which XeroAccount to delete.
     */
    where: XeroAccountWhereUniqueInput
  }

  /**
   * XeroAccount deleteMany
   */
  export type XeroAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroAccounts to delete
     */
    where?: XeroAccountWhereInput
    /**
     * Limit how many XeroAccounts to delete.
     */
    limit?: number
  }

  /**
   * XeroAccount without action
   */
  export type XeroAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroAccount
     */
    select?: XeroAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroAccount
     */
    omit?: XeroAccountOmit<ExtArgs> | null
  }


  /**
   * Model XeroContact
   */

  export type AggregateXeroContact = {
    _count: XeroContactCountAggregateOutputType | null
    _min: XeroContactMinAggregateOutputType | null
    _max: XeroContactMaxAggregateOutputType | null
  }

  export type XeroContactMinAggregateOutputType = {
    id: string | null
    xeroId: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    emailAddress: string | null
    contactStatus: string | null
    isSupplier: boolean | null
    isCustomer: boolean | null
    defaultCurrency: string | null
    accountNumber: string | null
    companyNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroContactMaxAggregateOutputType = {
    id: string | null
    xeroId: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    emailAddress: string | null
    contactStatus: string | null
    isSupplier: boolean | null
    isCustomer: boolean | null
    defaultCurrency: string | null
    accountNumber: string | null
    companyNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroContactCountAggregateOutputType = {
    id: number
    xeroId: number
    name: number
    firstName: number
    lastName: number
    emailAddress: number
    contactStatus: number
    isSupplier: number
    isCustomer: number
    defaultCurrency: number
    accountNumber: number
    companyNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XeroContactMinAggregateInputType = {
    id?: true
    xeroId?: true
    name?: true
    firstName?: true
    lastName?: true
    emailAddress?: true
    contactStatus?: true
    isSupplier?: true
    isCustomer?: true
    defaultCurrency?: true
    accountNumber?: true
    companyNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroContactMaxAggregateInputType = {
    id?: true
    xeroId?: true
    name?: true
    firstName?: true
    lastName?: true
    emailAddress?: true
    contactStatus?: true
    isSupplier?: true
    isCustomer?: true
    defaultCurrency?: true
    accountNumber?: true
    companyNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroContactCountAggregateInputType = {
    id?: true
    xeroId?: true
    name?: true
    firstName?: true
    lastName?: true
    emailAddress?: true
    contactStatus?: true
    isSupplier?: true
    isCustomer?: true
    defaultCurrency?: true
    accountNumber?: true
    companyNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XeroContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroContact to aggregate.
     */
    where?: XeroContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroContacts to fetch.
     */
    orderBy?: XeroContactOrderByWithRelationInput | XeroContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XeroContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XeroContacts
    **/
    _count?: true | XeroContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XeroContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XeroContactMaxAggregateInputType
  }

  export type GetXeroContactAggregateType<T extends XeroContactAggregateArgs> = {
        [P in keyof T & keyof AggregateXeroContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXeroContact[P]>
      : GetScalarType<T[P], AggregateXeroContact[P]>
  }




  export type XeroContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroContactWhereInput
    orderBy?: XeroContactOrderByWithAggregationInput | XeroContactOrderByWithAggregationInput[]
    by: XeroContactScalarFieldEnum[] | XeroContactScalarFieldEnum
    having?: XeroContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XeroContactCountAggregateInputType | true
    _min?: XeroContactMinAggregateInputType
    _max?: XeroContactMaxAggregateInputType
  }

  export type XeroContactGroupByOutputType = {
    id: string
    xeroId: string
    name: string
    firstName: string | null
    lastName: string | null
    emailAddress: string | null
    contactStatus: string | null
    isSupplier: boolean
    isCustomer: boolean
    defaultCurrency: string | null
    accountNumber: string | null
    companyNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: XeroContactCountAggregateOutputType | null
    _min: XeroContactMinAggregateOutputType | null
    _max: XeroContactMaxAggregateOutputType | null
  }

  type GetXeroContactGroupByPayload<T extends XeroContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XeroContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XeroContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XeroContactGroupByOutputType[P]>
            : GetScalarType<T[P], XeroContactGroupByOutputType[P]>
        }
      >
    >


  export type XeroContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    emailAddress?: boolean
    contactStatus?: boolean
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: boolean
    accountNumber?: boolean
    companyNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoices?: boolean | XeroContact$invoicesArgs<ExtArgs>
    bills?: boolean | XeroContact$billsArgs<ExtArgs>
    payments?: boolean | XeroContact$paymentsArgs<ExtArgs>
    _count?: boolean | XeroContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xeroContact"]>

  export type XeroContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    emailAddress?: boolean
    contactStatus?: boolean
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: boolean
    accountNumber?: boolean
    companyNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroContact"]>

  export type XeroContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    emailAddress?: boolean
    contactStatus?: boolean
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: boolean
    accountNumber?: boolean
    companyNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroContact"]>

  export type XeroContactSelectScalar = {
    id?: boolean
    xeroId?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    emailAddress?: boolean
    contactStatus?: boolean
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: boolean
    accountNumber?: boolean
    companyNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XeroContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xeroId" | "name" | "firstName" | "lastName" | "emailAddress" | "contactStatus" | "isSupplier" | "isCustomer" | "defaultCurrency" | "accountNumber" | "companyNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["xeroContact"]>
  export type XeroContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | XeroContact$invoicesArgs<ExtArgs>
    bills?: boolean | XeroContact$billsArgs<ExtArgs>
    payments?: boolean | XeroContact$paymentsArgs<ExtArgs>
    _count?: boolean | XeroContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type XeroContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type XeroContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $XeroContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XeroContact"
    objects: {
      invoices: Prisma.$XeroInvoicePayload<ExtArgs>[]
      bills: Prisma.$XeroBillPayload<ExtArgs>[]
      payments: Prisma.$XeroPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      xeroId: string
      name: string
      firstName: string | null
      lastName: string | null
      emailAddress: string | null
      contactStatus: string | null
      isSupplier: boolean
      isCustomer: boolean
      defaultCurrency: string | null
      accountNumber: string | null
      companyNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xeroContact"]>
    composites: {}
  }

  type XeroContactGetPayload<S extends boolean | null | undefined | XeroContactDefaultArgs> = $Result.GetResult<Prisma.$XeroContactPayload, S>

  type XeroContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XeroContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XeroContactCountAggregateInputType | true
    }

  export interface XeroContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XeroContact'], meta: { name: 'XeroContact' } }
    /**
     * Find zero or one XeroContact that matches the filter.
     * @param {XeroContactFindUniqueArgs} args - Arguments to find a XeroContact
     * @example
     * // Get one XeroContact
     * const xeroContact = await prisma.xeroContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XeroContactFindUniqueArgs>(args: SelectSubset<T, XeroContactFindUniqueArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XeroContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XeroContactFindUniqueOrThrowArgs} args - Arguments to find a XeroContact
     * @example
     * // Get one XeroContact
     * const xeroContact = await prisma.xeroContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XeroContactFindUniqueOrThrowArgs>(args: SelectSubset<T, XeroContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroContactFindFirstArgs} args - Arguments to find a XeroContact
     * @example
     * // Get one XeroContact
     * const xeroContact = await prisma.xeroContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XeroContactFindFirstArgs>(args?: SelectSubset<T, XeroContactFindFirstArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroContactFindFirstOrThrowArgs} args - Arguments to find a XeroContact
     * @example
     * // Get one XeroContact
     * const xeroContact = await prisma.xeroContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XeroContactFindFirstOrThrowArgs>(args?: SelectSubset<T, XeroContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XeroContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XeroContacts
     * const xeroContacts = await prisma.xeroContact.findMany()
     * 
     * // Get first 10 XeroContacts
     * const xeroContacts = await prisma.xeroContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xeroContactWithIdOnly = await prisma.xeroContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XeroContactFindManyArgs>(args?: SelectSubset<T, XeroContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XeroContact.
     * @param {XeroContactCreateArgs} args - Arguments to create a XeroContact.
     * @example
     * // Create one XeroContact
     * const XeroContact = await prisma.xeroContact.create({
     *   data: {
     *     // ... data to create a XeroContact
     *   }
     * })
     * 
     */
    create<T extends XeroContactCreateArgs>(args: SelectSubset<T, XeroContactCreateArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XeroContacts.
     * @param {XeroContactCreateManyArgs} args - Arguments to create many XeroContacts.
     * @example
     * // Create many XeroContacts
     * const xeroContact = await prisma.xeroContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XeroContactCreateManyArgs>(args?: SelectSubset<T, XeroContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XeroContacts and returns the data saved in the database.
     * @param {XeroContactCreateManyAndReturnArgs} args - Arguments to create many XeroContacts.
     * @example
     * // Create many XeroContacts
     * const xeroContact = await prisma.xeroContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XeroContacts and only return the `id`
     * const xeroContactWithIdOnly = await prisma.xeroContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XeroContactCreateManyAndReturnArgs>(args?: SelectSubset<T, XeroContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XeroContact.
     * @param {XeroContactDeleteArgs} args - Arguments to delete one XeroContact.
     * @example
     * // Delete one XeroContact
     * const XeroContact = await prisma.xeroContact.delete({
     *   where: {
     *     // ... filter to delete one XeroContact
     *   }
     * })
     * 
     */
    delete<T extends XeroContactDeleteArgs>(args: SelectSubset<T, XeroContactDeleteArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XeroContact.
     * @param {XeroContactUpdateArgs} args - Arguments to update one XeroContact.
     * @example
     * // Update one XeroContact
     * const xeroContact = await prisma.xeroContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XeroContactUpdateArgs>(args: SelectSubset<T, XeroContactUpdateArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XeroContacts.
     * @param {XeroContactDeleteManyArgs} args - Arguments to filter XeroContacts to delete.
     * @example
     * // Delete a few XeroContacts
     * const { count } = await prisma.xeroContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XeroContactDeleteManyArgs>(args?: SelectSubset<T, XeroContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XeroContacts
     * const xeroContact = await prisma.xeroContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XeroContactUpdateManyArgs>(args: SelectSubset<T, XeroContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroContacts and returns the data updated in the database.
     * @param {XeroContactUpdateManyAndReturnArgs} args - Arguments to update many XeroContacts.
     * @example
     * // Update many XeroContacts
     * const xeroContact = await prisma.xeroContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XeroContacts and only return the `id`
     * const xeroContactWithIdOnly = await prisma.xeroContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XeroContactUpdateManyAndReturnArgs>(args: SelectSubset<T, XeroContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XeroContact.
     * @param {XeroContactUpsertArgs} args - Arguments to update or create a XeroContact.
     * @example
     * // Update or create a XeroContact
     * const xeroContact = await prisma.xeroContact.upsert({
     *   create: {
     *     // ... data to create a XeroContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XeroContact we want to update
     *   }
     * })
     */
    upsert<T extends XeroContactUpsertArgs>(args: SelectSubset<T, XeroContactUpsertArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XeroContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroContactCountArgs} args - Arguments to filter XeroContacts to count.
     * @example
     * // Count the number of XeroContacts
     * const count = await prisma.xeroContact.count({
     *   where: {
     *     // ... the filter for the XeroContacts we want to count
     *   }
     * })
    **/
    count<T extends XeroContactCountArgs>(
      args?: Subset<T, XeroContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XeroContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XeroContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XeroContactAggregateArgs>(args: Subset<T, XeroContactAggregateArgs>): Prisma.PrismaPromise<GetXeroContactAggregateType<T>>

    /**
     * Group by XeroContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XeroContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XeroContactGroupByArgs['orderBy'] }
        : { orderBy?: XeroContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XeroContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXeroContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XeroContact model
   */
  readonly fields: XeroContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XeroContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XeroContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends XeroContact$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, XeroContact$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bills<T extends XeroContact$billsArgs<ExtArgs> = {}>(args?: Subset<T, XeroContact$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends XeroContact$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, XeroContact$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XeroContact model
   */
  interface XeroContactFieldRefs {
    readonly id: FieldRef<"XeroContact", 'String'>
    readonly xeroId: FieldRef<"XeroContact", 'String'>
    readonly name: FieldRef<"XeroContact", 'String'>
    readonly firstName: FieldRef<"XeroContact", 'String'>
    readonly lastName: FieldRef<"XeroContact", 'String'>
    readonly emailAddress: FieldRef<"XeroContact", 'String'>
    readonly contactStatus: FieldRef<"XeroContact", 'String'>
    readonly isSupplier: FieldRef<"XeroContact", 'Boolean'>
    readonly isCustomer: FieldRef<"XeroContact", 'Boolean'>
    readonly defaultCurrency: FieldRef<"XeroContact", 'String'>
    readonly accountNumber: FieldRef<"XeroContact", 'String'>
    readonly companyNumber: FieldRef<"XeroContact", 'String'>
    readonly createdAt: FieldRef<"XeroContact", 'DateTime'>
    readonly updatedAt: FieldRef<"XeroContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XeroContact findUnique
   */
  export type XeroContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * Filter, which XeroContact to fetch.
     */
    where: XeroContactWhereUniqueInput
  }

  /**
   * XeroContact findUniqueOrThrow
   */
  export type XeroContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * Filter, which XeroContact to fetch.
     */
    where: XeroContactWhereUniqueInput
  }

  /**
   * XeroContact findFirst
   */
  export type XeroContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * Filter, which XeroContact to fetch.
     */
    where?: XeroContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroContacts to fetch.
     */
    orderBy?: XeroContactOrderByWithRelationInput | XeroContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroContacts.
     */
    cursor?: XeroContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroContacts.
     */
    distinct?: XeroContactScalarFieldEnum | XeroContactScalarFieldEnum[]
  }

  /**
   * XeroContact findFirstOrThrow
   */
  export type XeroContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * Filter, which XeroContact to fetch.
     */
    where?: XeroContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroContacts to fetch.
     */
    orderBy?: XeroContactOrderByWithRelationInput | XeroContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroContacts.
     */
    cursor?: XeroContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroContacts.
     */
    distinct?: XeroContactScalarFieldEnum | XeroContactScalarFieldEnum[]
  }

  /**
   * XeroContact findMany
   */
  export type XeroContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * Filter, which XeroContacts to fetch.
     */
    where?: XeroContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroContacts to fetch.
     */
    orderBy?: XeroContactOrderByWithRelationInput | XeroContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XeroContacts.
     */
    cursor?: XeroContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroContacts.
     */
    skip?: number
    distinct?: XeroContactScalarFieldEnum | XeroContactScalarFieldEnum[]
  }

  /**
   * XeroContact create
   */
  export type XeroContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * The data needed to create a XeroContact.
     */
    data: XOR<XeroContactCreateInput, XeroContactUncheckedCreateInput>
  }

  /**
   * XeroContact createMany
   */
  export type XeroContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XeroContacts.
     */
    data: XeroContactCreateManyInput | XeroContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroContact createManyAndReturn
   */
  export type XeroContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * The data used to create many XeroContacts.
     */
    data: XeroContactCreateManyInput | XeroContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroContact update
   */
  export type XeroContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * The data needed to update a XeroContact.
     */
    data: XOR<XeroContactUpdateInput, XeroContactUncheckedUpdateInput>
    /**
     * Choose, which XeroContact to update.
     */
    where: XeroContactWhereUniqueInput
  }

  /**
   * XeroContact updateMany
   */
  export type XeroContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XeroContacts.
     */
    data: XOR<XeroContactUpdateManyMutationInput, XeroContactUncheckedUpdateManyInput>
    /**
     * Filter which XeroContacts to update
     */
    where?: XeroContactWhereInput
    /**
     * Limit how many XeroContacts to update.
     */
    limit?: number
  }

  /**
   * XeroContact updateManyAndReturn
   */
  export type XeroContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * The data used to update XeroContacts.
     */
    data: XOR<XeroContactUpdateManyMutationInput, XeroContactUncheckedUpdateManyInput>
    /**
     * Filter which XeroContacts to update
     */
    where?: XeroContactWhereInput
    /**
     * Limit how many XeroContacts to update.
     */
    limit?: number
  }

  /**
   * XeroContact upsert
   */
  export type XeroContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * The filter to search for the XeroContact to update in case it exists.
     */
    where: XeroContactWhereUniqueInput
    /**
     * In case the XeroContact found by the `where` argument doesn't exist, create a new XeroContact with this data.
     */
    create: XOR<XeroContactCreateInput, XeroContactUncheckedCreateInput>
    /**
     * In case the XeroContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XeroContactUpdateInput, XeroContactUncheckedUpdateInput>
  }

  /**
   * XeroContact delete
   */
  export type XeroContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    /**
     * Filter which XeroContact to delete.
     */
    where: XeroContactWhereUniqueInput
  }

  /**
   * XeroContact deleteMany
   */
  export type XeroContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroContacts to delete
     */
    where?: XeroContactWhereInput
    /**
     * Limit how many XeroContacts to delete.
     */
    limit?: number
  }

  /**
   * XeroContact.invoices
   */
  export type XeroContact$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    where?: XeroInvoiceWhereInput
    orderBy?: XeroInvoiceOrderByWithRelationInput | XeroInvoiceOrderByWithRelationInput[]
    cursor?: XeroInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XeroInvoiceScalarFieldEnum | XeroInvoiceScalarFieldEnum[]
  }

  /**
   * XeroContact.bills
   */
  export type XeroContact$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    where?: XeroBillWhereInput
    orderBy?: XeroBillOrderByWithRelationInput | XeroBillOrderByWithRelationInput[]
    cursor?: XeroBillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XeroBillScalarFieldEnum | XeroBillScalarFieldEnum[]
  }

  /**
   * XeroContact.payments
   */
  export type XeroContact$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    where?: XeroPaymentWhereInput
    orderBy?: XeroPaymentOrderByWithRelationInput | XeroPaymentOrderByWithRelationInput[]
    cursor?: XeroPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XeroPaymentScalarFieldEnum | XeroPaymentScalarFieldEnum[]
  }

  /**
   * XeroContact without action
   */
  export type XeroContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
  }


  /**
   * Model XeroInvoice
   */

  export type AggregateXeroInvoice = {
    _count: XeroInvoiceCountAggregateOutputType | null
    _avg: XeroInvoiceAvgAggregateOutputType | null
    _sum: XeroInvoiceSumAggregateOutputType | null
    _min: XeroInvoiceMinAggregateOutputType | null
    _max: XeroInvoiceMaxAggregateOutputType | null
  }

  export type XeroInvoiceAvgAggregateOutputType = {
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
  }

  export type XeroInvoiceSumAggregateOutputType = {
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
  }

  export type XeroInvoiceMinAggregateOutputType = {
    id: string | null
    xeroId: string | null
    invoiceNumber: string | null
    reference: string | null
    type: string | null
    contactId: string | null
    date: Date | null
    dueDate: Date | null
    status: string | null
    lineAmountTypes: string | null
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
    currencyCode: string | null
    fullyPaidOnDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroInvoiceMaxAggregateOutputType = {
    id: string | null
    xeroId: string | null
    invoiceNumber: string | null
    reference: string | null
    type: string | null
    contactId: string | null
    date: Date | null
    dueDate: Date | null
    status: string | null
    lineAmountTypes: string | null
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
    currencyCode: string | null
    fullyPaidOnDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroInvoiceCountAggregateOutputType = {
    id: number
    xeroId: number
    invoiceNumber: number
    reference: number
    type: number
    contactId: number
    date: number
    dueDate: number
    status: number
    lineAmountTypes: number
    subTotal: number
    totalTax: number
    total: number
    amountDue: number
    amountPaid: number
    amountCredited: number
    currencyCode: number
    fullyPaidOnDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XeroInvoiceAvgAggregateInputType = {
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
  }

  export type XeroInvoiceSumAggregateInputType = {
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
  }

  export type XeroInvoiceMinAggregateInputType = {
    id?: true
    xeroId?: true
    invoiceNumber?: true
    reference?: true
    type?: true
    contactId?: true
    date?: true
    dueDate?: true
    status?: true
    lineAmountTypes?: true
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
    currencyCode?: true
    fullyPaidOnDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroInvoiceMaxAggregateInputType = {
    id?: true
    xeroId?: true
    invoiceNumber?: true
    reference?: true
    type?: true
    contactId?: true
    date?: true
    dueDate?: true
    status?: true
    lineAmountTypes?: true
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
    currencyCode?: true
    fullyPaidOnDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroInvoiceCountAggregateInputType = {
    id?: true
    xeroId?: true
    invoiceNumber?: true
    reference?: true
    type?: true
    contactId?: true
    date?: true
    dueDate?: true
    status?: true
    lineAmountTypes?: true
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
    currencyCode?: true
    fullyPaidOnDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XeroInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroInvoice to aggregate.
     */
    where?: XeroInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroInvoices to fetch.
     */
    orderBy?: XeroInvoiceOrderByWithRelationInput | XeroInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XeroInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XeroInvoices
    **/
    _count?: true | XeroInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XeroInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XeroInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XeroInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XeroInvoiceMaxAggregateInputType
  }

  export type GetXeroInvoiceAggregateType<T extends XeroInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateXeroInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXeroInvoice[P]>
      : GetScalarType<T[P], AggregateXeroInvoice[P]>
  }




  export type XeroInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroInvoiceWhereInput
    orderBy?: XeroInvoiceOrderByWithAggregationInput | XeroInvoiceOrderByWithAggregationInput[]
    by: XeroInvoiceScalarFieldEnum[] | XeroInvoiceScalarFieldEnum
    having?: XeroInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XeroInvoiceCountAggregateInputType | true
    _avg?: XeroInvoiceAvgAggregateInputType
    _sum?: XeroInvoiceSumAggregateInputType
    _min?: XeroInvoiceMinAggregateInputType
    _max?: XeroInvoiceMaxAggregateInputType
  }

  export type XeroInvoiceGroupByOutputType = {
    id: string
    xeroId: string
    invoiceNumber: string | null
    reference: string | null
    type: string
    contactId: string
    date: Date | null
    dueDate: Date | null
    status: string
    lineAmountTypes: string | null
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
    currencyCode: string
    fullyPaidOnDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: XeroInvoiceCountAggregateOutputType | null
    _avg: XeroInvoiceAvgAggregateOutputType | null
    _sum: XeroInvoiceSumAggregateOutputType | null
    _min: XeroInvoiceMinAggregateOutputType | null
    _max: XeroInvoiceMaxAggregateOutputType | null
  }

  type GetXeroInvoiceGroupByPayload<T extends XeroInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XeroInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XeroInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XeroInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], XeroInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type XeroInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    invoiceNumber?: boolean
    reference?: boolean
    type?: boolean
    contactId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    lineAmountTypes?: boolean
    subTotal?: boolean
    totalTax?: boolean
    total?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    amountCredited?: boolean
    currencyCode?: boolean
    fullyPaidOnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
    payments?: boolean | XeroInvoice$paymentsArgs<ExtArgs>
    _count?: boolean | XeroInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xeroInvoice"]>

  export type XeroInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    invoiceNumber?: boolean
    reference?: boolean
    type?: boolean
    contactId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    lineAmountTypes?: boolean
    subTotal?: boolean
    totalTax?: boolean
    total?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    amountCredited?: boolean
    currencyCode?: boolean
    fullyPaidOnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xeroInvoice"]>

  export type XeroInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    invoiceNumber?: boolean
    reference?: boolean
    type?: boolean
    contactId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    lineAmountTypes?: boolean
    subTotal?: boolean
    totalTax?: boolean
    total?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    amountCredited?: boolean
    currencyCode?: boolean
    fullyPaidOnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xeroInvoice"]>

  export type XeroInvoiceSelectScalar = {
    id?: boolean
    xeroId?: boolean
    invoiceNumber?: boolean
    reference?: boolean
    type?: boolean
    contactId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    lineAmountTypes?: boolean
    subTotal?: boolean
    totalTax?: boolean
    total?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    amountCredited?: boolean
    currencyCode?: boolean
    fullyPaidOnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XeroInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xeroId" | "invoiceNumber" | "reference" | "type" | "contactId" | "date" | "dueDate" | "status" | "lineAmountTypes" | "subTotal" | "totalTax" | "total" | "amountDue" | "amountPaid" | "amountCredited" | "currencyCode" | "fullyPaidOnDate" | "createdAt" | "updatedAt", ExtArgs["result"]["xeroInvoice"]>
  export type XeroInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
    payments?: boolean | XeroInvoice$paymentsArgs<ExtArgs>
    _count?: boolean | XeroInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type XeroInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
  }
  export type XeroInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
  }

  export type $XeroInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XeroInvoice"
    objects: {
      contact: Prisma.$XeroContactPayload<ExtArgs>
      payments: Prisma.$XeroPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      xeroId: string
      invoiceNumber: string | null
      reference: string | null
      type: string
      contactId: string
      date: Date | null
      dueDate: Date | null
      status: string
      lineAmountTypes: string | null
      subTotal: number | null
      totalTax: number | null
      total: number | null
      amountDue: number | null
      amountPaid: number | null
      amountCredited: number | null
      currencyCode: string
      fullyPaidOnDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xeroInvoice"]>
    composites: {}
  }

  type XeroInvoiceGetPayload<S extends boolean | null | undefined | XeroInvoiceDefaultArgs> = $Result.GetResult<Prisma.$XeroInvoicePayload, S>

  type XeroInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XeroInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XeroInvoiceCountAggregateInputType | true
    }

  export interface XeroInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XeroInvoice'], meta: { name: 'XeroInvoice' } }
    /**
     * Find zero or one XeroInvoice that matches the filter.
     * @param {XeroInvoiceFindUniqueArgs} args - Arguments to find a XeroInvoice
     * @example
     * // Get one XeroInvoice
     * const xeroInvoice = await prisma.xeroInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XeroInvoiceFindUniqueArgs>(args: SelectSubset<T, XeroInvoiceFindUniqueArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XeroInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XeroInvoiceFindUniqueOrThrowArgs} args - Arguments to find a XeroInvoice
     * @example
     * // Get one XeroInvoice
     * const xeroInvoice = await prisma.xeroInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XeroInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, XeroInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroInvoiceFindFirstArgs} args - Arguments to find a XeroInvoice
     * @example
     * // Get one XeroInvoice
     * const xeroInvoice = await prisma.xeroInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XeroInvoiceFindFirstArgs>(args?: SelectSubset<T, XeroInvoiceFindFirstArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroInvoiceFindFirstOrThrowArgs} args - Arguments to find a XeroInvoice
     * @example
     * // Get one XeroInvoice
     * const xeroInvoice = await prisma.xeroInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XeroInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, XeroInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XeroInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XeroInvoices
     * const xeroInvoices = await prisma.xeroInvoice.findMany()
     * 
     * // Get first 10 XeroInvoices
     * const xeroInvoices = await prisma.xeroInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xeroInvoiceWithIdOnly = await prisma.xeroInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XeroInvoiceFindManyArgs>(args?: SelectSubset<T, XeroInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XeroInvoice.
     * @param {XeroInvoiceCreateArgs} args - Arguments to create a XeroInvoice.
     * @example
     * // Create one XeroInvoice
     * const XeroInvoice = await prisma.xeroInvoice.create({
     *   data: {
     *     // ... data to create a XeroInvoice
     *   }
     * })
     * 
     */
    create<T extends XeroInvoiceCreateArgs>(args: SelectSubset<T, XeroInvoiceCreateArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XeroInvoices.
     * @param {XeroInvoiceCreateManyArgs} args - Arguments to create many XeroInvoices.
     * @example
     * // Create many XeroInvoices
     * const xeroInvoice = await prisma.xeroInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XeroInvoiceCreateManyArgs>(args?: SelectSubset<T, XeroInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XeroInvoices and returns the data saved in the database.
     * @param {XeroInvoiceCreateManyAndReturnArgs} args - Arguments to create many XeroInvoices.
     * @example
     * // Create many XeroInvoices
     * const xeroInvoice = await prisma.xeroInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XeroInvoices and only return the `id`
     * const xeroInvoiceWithIdOnly = await prisma.xeroInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XeroInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, XeroInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XeroInvoice.
     * @param {XeroInvoiceDeleteArgs} args - Arguments to delete one XeroInvoice.
     * @example
     * // Delete one XeroInvoice
     * const XeroInvoice = await prisma.xeroInvoice.delete({
     *   where: {
     *     // ... filter to delete one XeroInvoice
     *   }
     * })
     * 
     */
    delete<T extends XeroInvoiceDeleteArgs>(args: SelectSubset<T, XeroInvoiceDeleteArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XeroInvoice.
     * @param {XeroInvoiceUpdateArgs} args - Arguments to update one XeroInvoice.
     * @example
     * // Update one XeroInvoice
     * const xeroInvoice = await prisma.xeroInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XeroInvoiceUpdateArgs>(args: SelectSubset<T, XeroInvoiceUpdateArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XeroInvoices.
     * @param {XeroInvoiceDeleteManyArgs} args - Arguments to filter XeroInvoices to delete.
     * @example
     * // Delete a few XeroInvoices
     * const { count } = await prisma.xeroInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XeroInvoiceDeleteManyArgs>(args?: SelectSubset<T, XeroInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XeroInvoices
     * const xeroInvoice = await prisma.xeroInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XeroInvoiceUpdateManyArgs>(args: SelectSubset<T, XeroInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroInvoices and returns the data updated in the database.
     * @param {XeroInvoiceUpdateManyAndReturnArgs} args - Arguments to update many XeroInvoices.
     * @example
     * // Update many XeroInvoices
     * const xeroInvoice = await prisma.xeroInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XeroInvoices and only return the `id`
     * const xeroInvoiceWithIdOnly = await prisma.xeroInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XeroInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, XeroInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XeroInvoice.
     * @param {XeroInvoiceUpsertArgs} args - Arguments to update or create a XeroInvoice.
     * @example
     * // Update or create a XeroInvoice
     * const xeroInvoice = await prisma.xeroInvoice.upsert({
     *   create: {
     *     // ... data to create a XeroInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XeroInvoice we want to update
     *   }
     * })
     */
    upsert<T extends XeroInvoiceUpsertArgs>(args: SelectSubset<T, XeroInvoiceUpsertArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XeroInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroInvoiceCountArgs} args - Arguments to filter XeroInvoices to count.
     * @example
     * // Count the number of XeroInvoices
     * const count = await prisma.xeroInvoice.count({
     *   where: {
     *     // ... the filter for the XeroInvoices we want to count
     *   }
     * })
    **/
    count<T extends XeroInvoiceCountArgs>(
      args?: Subset<T, XeroInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XeroInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XeroInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XeroInvoiceAggregateArgs>(args: Subset<T, XeroInvoiceAggregateArgs>): Prisma.PrismaPromise<GetXeroInvoiceAggregateType<T>>

    /**
     * Group by XeroInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XeroInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XeroInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: XeroInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XeroInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXeroInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XeroInvoice model
   */
  readonly fields: XeroInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XeroInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XeroInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends XeroContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, XeroContactDefaultArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends XeroInvoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, XeroInvoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XeroInvoice model
   */
  interface XeroInvoiceFieldRefs {
    readonly id: FieldRef<"XeroInvoice", 'String'>
    readonly xeroId: FieldRef<"XeroInvoice", 'String'>
    readonly invoiceNumber: FieldRef<"XeroInvoice", 'String'>
    readonly reference: FieldRef<"XeroInvoice", 'String'>
    readonly type: FieldRef<"XeroInvoice", 'String'>
    readonly contactId: FieldRef<"XeroInvoice", 'String'>
    readonly date: FieldRef<"XeroInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"XeroInvoice", 'DateTime'>
    readonly status: FieldRef<"XeroInvoice", 'String'>
    readonly lineAmountTypes: FieldRef<"XeroInvoice", 'String'>
    readonly subTotal: FieldRef<"XeroInvoice", 'Float'>
    readonly totalTax: FieldRef<"XeroInvoice", 'Float'>
    readonly total: FieldRef<"XeroInvoice", 'Float'>
    readonly amountDue: FieldRef<"XeroInvoice", 'Float'>
    readonly amountPaid: FieldRef<"XeroInvoice", 'Float'>
    readonly amountCredited: FieldRef<"XeroInvoice", 'Float'>
    readonly currencyCode: FieldRef<"XeroInvoice", 'String'>
    readonly fullyPaidOnDate: FieldRef<"XeroInvoice", 'DateTime'>
    readonly createdAt: FieldRef<"XeroInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"XeroInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XeroInvoice findUnique
   */
  export type XeroInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which XeroInvoice to fetch.
     */
    where: XeroInvoiceWhereUniqueInput
  }

  /**
   * XeroInvoice findUniqueOrThrow
   */
  export type XeroInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which XeroInvoice to fetch.
     */
    where: XeroInvoiceWhereUniqueInput
  }

  /**
   * XeroInvoice findFirst
   */
  export type XeroInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which XeroInvoice to fetch.
     */
    where?: XeroInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroInvoices to fetch.
     */
    orderBy?: XeroInvoiceOrderByWithRelationInput | XeroInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroInvoices.
     */
    cursor?: XeroInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroInvoices.
     */
    distinct?: XeroInvoiceScalarFieldEnum | XeroInvoiceScalarFieldEnum[]
  }

  /**
   * XeroInvoice findFirstOrThrow
   */
  export type XeroInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which XeroInvoice to fetch.
     */
    where?: XeroInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroInvoices to fetch.
     */
    orderBy?: XeroInvoiceOrderByWithRelationInput | XeroInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroInvoices.
     */
    cursor?: XeroInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroInvoices.
     */
    distinct?: XeroInvoiceScalarFieldEnum | XeroInvoiceScalarFieldEnum[]
  }

  /**
   * XeroInvoice findMany
   */
  export type XeroInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which XeroInvoices to fetch.
     */
    where?: XeroInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroInvoices to fetch.
     */
    orderBy?: XeroInvoiceOrderByWithRelationInput | XeroInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XeroInvoices.
     */
    cursor?: XeroInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroInvoices.
     */
    skip?: number
    distinct?: XeroInvoiceScalarFieldEnum | XeroInvoiceScalarFieldEnum[]
  }

  /**
   * XeroInvoice create
   */
  export type XeroInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a XeroInvoice.
     */
    data: XOR<XeroInvoiceCreateInput, XeroInvoiceUncheckedCreateInput>
  }

  /**
   * XeroInvoice createMany
   */
  export type XeroInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XeroInvoices.
     */
    data: XeroInvoiceCreateManyInput | XeroInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroInvoice createManyAndReturn
   */
  export type XeroInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many XeroInvoices.
     */
    data: XeroInvoiceCreateManyInput | XeroInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XeroInvoice update
   */
  export type XeroInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a XeroInvoice.
     */
    data: XOR<XeroInvoiceUpdateInput, XeroInvoiceUncheckedUpdateInput>
    /**
     * Choose, which XeroInvoice to update.
     */
    where: XeroInvoiceWhereUniqueInput
  }

  /**
   * XeroInvoice updateMany
   */
  export type XeroInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XeroInvoices.
     */
    data: XOR<XeroInvoiceUpdateManyMutationInput, XeroInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which XeroInvoices to update
     */
    where?: XeroInvoiceWhereInput
    /**
     * Limit how many XeroInvoices to update.
     */
    limit?: number
  }

  /**
   * XeroInvoice updateManyAndReturn
   */
  export type XeroInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update XeroInvoices.
     */
    data: XOR<XeroInvoiceUpdateManyMutationInput, XeroInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which XeroInvoices to update
     */
    where?: XeroInvoiceWhereInput
    /**
     * Limit how many XeroInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * XeroInvoice upsert
   */
  export type XeroInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the XeroInvoice to update in case it exists.
     */
    where: XeroInvoiceWhereUniqueInput
    /**
     * In case the XeroInvoice found by the `where` argument doesn't exist, create a new XeroInvoice with this data.
     */
    create: XOR<XeroInvoiceCreateInput, XeroInvoiceUncheckedCreateInput>
    /**
     * In case the XeroInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XeroInvoiceUpdateInput, XeroInvoiceUncheckedUpdateInput>
  }

  /**
   * XeroInvoice delete
   */
  export type XeroInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    /**
     * Filter which XeroInvoice to delete.
     */
    where: XeroInvoiceWhereUniqueInput
  }

  /**
   * XeroInvoice deleteMany
   */
  export type XeroInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroInvoices to delete
     */
    where?: XeroInvoiceWhereInput
    /**
     * Limit how many XeroInvoices to delete.
     */
    limit?: number
  }

  /**
   * XeroInvoice.payments
   */
  export type XeroInvoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    where?: XeroPaymentWhereInput
    orderBy?: XeroPaymentOrderByWithRelationInput | XeroPaymentOrderByWithRelationInput[]
    cursor?: XeroPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XeroPaymentScalarFieldEnum | XeroPaymentScalarFieldEnum[]
  }

  /**
   * XeroInvoice without action
   */
  export type XeroInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model XeroBill
   */

  export type AggregateXeroBill = {
    _count: XeroBillCountAggregateOutputType | null
    _avg: XeroBillAvgAggregateOutputType | null
    _sum: XeroBillSumAggregateOutputType | null
    _min: XeroBillMinAggregateOutputType | null
    _max: XeroBillMaxAggregateOutputType | null
  }

  export type XeroBillAvgAggregateOutputType = {
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
  }

  export type XeroBillSumAggregateOutputType = {
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
  }

  export type XeroBillMinAggregateOutputType = {
    id: string | null
    xeroId: string | null
    billNumber: string | null
    reference: string | null
    type: string | null
    contactId: string | null
    date: Date | null
    dueDate: Date | null
    status: string | null
    lineAmountTypes: string | null
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
    currencyCode: string | null
    fullyPaidOnDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroBillMaxAggregateOutputType = {
    id: string | null
    xeroId: string | null
    billNumber: string | null
    reference: string | null
    type: string | null
    contactId: string | null
    date: Date | null
    dueDate: Date | null
    status: string | null
    lineAmountTypes: string | null
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
    currencyCode: string | null
    fullyPaidOnDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroBillCountAggregateOutputType = {
    id: number
    xeroId: number
    billNumber: number
    reference: number
    type: number
    contactId: number
    date: number
    dueDate: number
    status: number
    lineAmountTypes: number
    subTotal: number
    totalTax: number
    total: number
    amountDue: number
    amountPaid: number
    amountCredited: number
    currencyCode: number
    fullyPaidOnDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XeroBillAvgAggregateInputType = {
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
  }

  export type XeroBillSumAggregateInputType = {
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
  }

  export type XeroBillMinAggregateInputType = {
    id?: true
    xeroId?: true
    billNumber?: true
    reference?: true
    type?: true
    contactId?: true
    date?: true
    dueDate?: true
    status?: true
    lineAmountTypes?: true
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
    currencyCode?: true
    fullyPaidOnDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroBillMaxAggregateInputType = {
    id?: true
    xeroId?: true
    billNumber?: true
    reference?: true
    type?: true
    contactId?: true
    date?: true
    dueDate?: true
    status?: true
    lineAmountTypes?: true
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
    currencyCode?: true
    fullyPaidOnDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroBillCountAggregateInputType = {
    id?: true
    xeroId?: true
    billNumber?: true
    reference?: true
    type?: true
    contactId?: true
    date?: true
    dueDate?: true
    status?: true
    lineAmountTypes?: true
    subTotal?: true
    totalTax?: true
    total?: true
    amountDue?: true
    amountPaid?: true
    amountCredited?: true
    currencyCode?: true
    fullyPaidOnDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XeroBillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroBill to aggregate.
     */
    where?: XeroBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroBills to fetch.
     */
    orderBy?: XeroBillOrderByWithRelationInput | XeroBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XeroBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XeroBills
    **/
    _count?: true | XeroBillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XeroBillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XeroBillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XeroBillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XeroBillMaxAggregateInputType
  }

  export type GetXeroBillAggregateType<T extends XeroBillAggregateArgs> = {
        [P in keyof T & keyof AggregateXeroBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXeroBill[P]>
      : GetScalarType<T[P], AggregateXeroBill[P]>
  }




  export type XeroBillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroBillWhereInput
    orderBy?: XeroBillOrderByWithAggregationInput | XeroBillOrderByWithAggregationInput[]
    by: XeroBillScalarFieldEnum[] | XeroBillScalarFieldEnum
    having?: XeroBillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XeroBillCountAggregateInputType | true
    _avg?: XeroBillAvgAggregateInputType
    _sum?: XeroBillSumAggregateInputType
    _min?: XeroBillMinAggregateInputType
    _max?: XeroBillMaxAggregateInputType
  }

  export type XeroBillGroupByOutputType = {
    id: string
    xeroId: string
    billNumber: string | null
    reference: string | null
    type: string
    contactId: string
    date: Date | null
    dueDate: Date | null
    status: string
    lineAmountTypes: string | null
    subTotal: number | null
    totalTax: number | null
    total: number | null
    amountDue: number | null
    amountPaid: number | null
    amountCredited: number | null
    currencyCode: string
    fullyPaidOnDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: XeroBillCountAggregateOutputType | null
    _avg: XeroBillAvgAggregateOutputType | null
    _sum: XeroBillSumAggregateOutputType | null
    _min: XeroBillMinAggregateOutputType | null
    _max: XeroBillMaxAggregateOutputType | null
  }

  type GetXeroBillGroupByPayload<T extends XeroBillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XeroBillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XeroBillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XeroBillGroupByOutputType[P]>
            : GetScalarType<T[P], XeroBillGroupByOutputType[P]>
        }
      >
    >


  export type XeroBillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    billNumber?: boolean
    reference?: boolean
    type?: boolean
    contactId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    lineAmountTypes?: boolean
    subTotal?: boolean
    totalTax?: boolean
    total?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    amountCredited?: boolean
    currencyCode?: boolean
    fullyPaidOnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
    payments?: boolean | XeroBill$paymentsArgs<ExtArgs>
    _count?: boolean | XeroBillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xeroBill"]>

  export type XeroBillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    billNumber?: boolean
    reference?: boolean
    type?: boolean
    contactId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    lineAmountTypes?: boolean
    subTotal?: boolean
    totalTax?: boolean
    total?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    amountCredited?: boolean
    currencyCode?: boolean
    fullyPaidOnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xeroBill"]>

  export type XeroBillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    billNumber?: boolean
    reference?: boolean
    type?: boolean
    contactId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    lineAmountTypes?: boolean
    subTotal?: boolean
    totalTax?: boolean
    total?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    amountCredited?: boolean
    currencyCode?: boolean
    fullyPaidOnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["xeroBill"]>

  export type XeroBillSelectScalar = {
    id?: boolean
    xeroId?: boolean
    billNumber?: boolean
    reference?: boolean
    type?: boolean
    contactId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    lineAmountTypes?: boolean
    subTotal?: boolean
    totalTax?: boolean
    total?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    amountCredited?: boolean
    currencyCode?: boolean
    fullyPaidOnDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XeroBillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xeroId" | "billNumber" | "reference" | "type" | "contactId" | "date" | "dueDate" | "status" | "lineAmountTypes" | "subTotal" | "totalTax" | "total" | "amountDue" | "amountPaid" | "amountCredited" | "currencyCode" | "fullyPaidOnDate" | "createdAt" | "updatedAt", ExtArgs["result"]["xeroBill"]>
  export type XeroBillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
    payments?: boolean | XeroBill$paymentsArgs<ExtArgs>
    _count?: boolean | XeroBillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type XeroBillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
  }
  export type XeroBillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroContactDefaultArgs<ExtArgs>
  }

  export type $XeroBillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XeroBill"
    objects: {
      contact: Prisma.$XeroContactPayload<ExtArgs>
      payments: Prisma.$XeroPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      xeroId: string
      billNumber: string | null
      reference: string | null
      type: string
      contactId: string
      date: Date | null
      dueDate: Date | null
      status: string
      lineAmountTypes: string | null
      subTotal: number | null
      totalTax: number | null
      total: number | null
      amountDue: number | null
      amountPaid: number | null
      amountCredited: number | null
      currencyCode: string
      fullyPaidOnDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xeroBill"]>
    composites: {}
  }

  type XeroBillGetPayload<S extends boolean | null | undefined | XeroBillDefaultArgs> = $Result.GetResult<Prisma.$XeroBillPayload, S>

  type XeroBillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XeroBillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XeroBillCountAggregateInputType | true
    }

  export interface XeroBillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XeroBill'], meta: { name: 'XeroBill' } }
    /**
     * Find zero or one XeroBill that matches the filter.
     * @param {XeroBillFindUniqueArgs} args - Arguments to find a XeroBill
     * @example
     * // Get one XeroBill
     * const xeroBill = await prisma.xeroBill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XeroBillFindUniqueArgs>(args: SelectSubset<T, XeroBillFindUniqueArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XeroBill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XeroBillFindUniqueOrThrowArgs} args - Arguments to find a XeroBill
     * @example
     * // Get one XeroBill
     * const xeroBill = await prisma.xeroBill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XeroBillFindUniqueOrThrowArgs>(args: SelectSubset<T, XeroBillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroBill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBillFindFirstArgs} args - Arguments to find a XeroBill
     * @example
     * // Get one XeroBill
     * const xeroBill = await prisma.xeroBill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XeroBillFindFirstArgs>(args?: SelectSubset<T, XeroBillFindFirstArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroBill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBillFindFirstOrThrowArgs} args - Arguments to find a XeroBill
     * @example
     * // Get one XeroBill
     * const xeroBill = await prisma.xeroBill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XeroBillFindFirstOrThrowArgs>(args?: SelectSubset<T, XeroBillFindFirstOrThrowArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XeroBills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XeroBills
     * const xeroBills = await prisma.xeroBill.findMany()
     * 
     * // Get first 10 XeroBills
     * const xeroBills = await prisma.xeroBill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xeroBillWithIdOnly = await prisma.xeroBill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XeroBillFindManyArgs>(args?: SelectSubset<T, XeroBillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XeroBill.
     * @param {XeroBillCreateArgs} args - Arguments to create a XeroBill.
     * @example
     * // Create one XeroBill
     * const XeroBill = await prisma.xeroBill.create({
     *   data: {
     *     // ... data to create a XeroBill
     *   }
     * })
     * 
     */
    create<T extends XeroBillCreateArgs>(args: SelectSubset<T, XeroBillCreateArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XeroBills.
     * @param {XeroBillCreateManyArgs} args - Arguments to create many XeroBills.
     * @example
     * // Create many XeroBills
     * const xeroBill = await prisma.xeroBill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XeroBillCreateManyArgs>(args?: SelectSubset<T, XeroBillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XeroBills and returns the data saved in the database.
     * @param {XeroBillCreateManyAndReturnArgs} args - Arguments to create many XeroBills.
     * @example
     * // Create many XeroBills
     * const xeroBill = await prisma.xeroBill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XeroBills and only return the `id`
     * const xeroBillWithIdOnly = await prisma.xeroBill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XeroBillCreateManyAndReturnArgs>(args?: SelectSubset<T, XeroBillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XeroBill.
     * @param {XeroBillDeleteArgs} args - Arguments to delete one XeroBill.
     * @example
     * // Delete one XeroBill
     * const XeroBill = await prisma.xeroBill.delete({
     *   where: {
     *     // ... filter to delete one XeroBill
     *   }
     * })
     * 
     */
    delete<T extends XeroBillDeleteArgs>(args: SelectSubset<T, XeroBillDeleteArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XeroBill.
     * @param {XeroBillUpdateArgs} args - Arguments to update one XeroBill.
     * @example
     * // Update one XeroBill
     * const xeroBill = await prisma.xeroBill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XeroBillUpdateArgs>(args: SelectSubset<T, XeroBillUpdateArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XeroBills.
     * @param {XeroBillDeleteManyArgs} args - Arguments to filter XeroBills to delete.
     * @example
     * // Delete a few XeroBills
     * const { count } = await prisma.xeroBill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XeroBillDeleteManyArgs>(args?: SelectSubset<T, XeroBillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XeroBills
     * const xeroBill = await prisma.xeroBill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XeroBillUpdateManyArgs>(args: SelectSubset<T, XeroBillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroBills and returns the data updated in the database.
     * @param {XeroBillUpdateManyAndReturnArgs} args - Arguments to update many XeroBills.
     * @example
     * // Update many XeroBills
     * const xeroBill = await prisma.xeroBill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XeroBills and only return the `id`
     * const xeroBillWithIdOnly = await prisma.xeroBill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XeroBillUpdateManyAndReturnArgs>(args: SelectSubset<T, XeroBillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XeroBill.
     * @param {XeroBillUpsertArgs} args - Arguments to update or create a XeroBill.
     * @example
     * // Update or create a XeroBill
     * const xeroBill = await prisma.xeroBill.upsert({
     *   create: {
     *     // ... data to create a XeroBill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XeroBill we want to update
     *   }
     * })
     */
    upsert<T extends XeroBillUpsertArgs>(args: SelectSubset<T, XeroBillUpsertArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XeroBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBillCountArgs} args - Arguments to filter XeroBills to count.
     * @example
     * // Count the number of XeroBills
     * const count = await prisma.xeroBill.count({
     *   where: {
     *     // ... the filter for the XeroBills we want to count
     *   }
     * })
    **/
    count<T extends XeroBillCountArgs>(
      args?: Subset<T, XeroBillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XeroBillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XeroBill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XeroBillAggregateArgs>(args: Subset<T, XeroBillAggregateArgs>): Prisma.PrismaPromise<GetXeroBillAggregateType<T>>

    /**
     * Group by XeroBill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XeroBillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XeroBillGroupByArgs['orderBy'] }
        : { orderBy?: XeroBillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XeroBillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXeroBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XeroBill model
   */
  readonly fields: XeroBillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XeroBill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XeroBillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends XeroContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, XeroContactDefaultArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends XeroBill$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, XeroBill$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XeroBill model
   */
  interface XeroBillFieldRefs {
    readonly id: FieldRef<"XeroBill", 'String'>
    readonly xeroId: FieldRef<"XeroBill", 'String'>
    readonly billNumber: FieldRef<"XeroBill", 'String'>
    readonly reference: FieldRef<"XeroBill", 'String'>
    readonly type: FieldRef<"XeroBill", 'String'>
    readonly contactId: FieldRef<"XeroBill", 'String'>
    readonly date: FieldRef<"XeroBill", 'DateTime'>
    readonly dueDate: FieldRef<"XeroBill", 'DateTime'>
    readonly status: FieldRef<"XeroBill", 'String'>
    readonly lineAmountTypes: FieldRef<"XeroBill", 'String'>
    readonly subTotal: FieldRef<"XeroBill", 'Float'>
    readonly totalTax: FieldRef<"XeroBill", 'Float'>
    readonly total: FieldRef<"XeroBill", 'Float'>
    readonly amountDue: FieldRef<"XeroBill", 'Float'>
    readonly amountPaid: FieldRef<"XeroBill", 'Float'>
    readonly amountCredited: FieldRef<"XeroBill", 'Float'>
    readonly currencyCode: FieldRef<"XeroBill", 'String'>
    readonly fullyPaidOnDate: FieldRef<"XeroBill", 'DateTime'>
    readonly createdAt: FieldRef<"XeroBill", 'DateTime'>
    readonly updatedAt: FieldRef<"XeroBill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XeroBill findUnique
   */
  export type XeroBillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * Filter, which XeroBill to fetch.
     */
    where: XeroBillWhereUniqueInput
  }

  /**
   * XeroBill findUniqueOrThrow
   */
  export type XeroBillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * Filter, which XeroBill to fetch.
     */
    where: XeroBillWhereUniqueInput
  }

  /**
   * XeroBill findFirst
   */
  export type XeroBillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * Filter, which XeroBill to fetch.
     */
    where?: XeroBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroBills to fetch.
     */
    orderBy?: XeroBillOrderByWithRelationInput | XeroBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroBills.
     */
    cursor?: XeroBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroBills.
     */
    distinct?: XeroBillScalarFieldEnum | XeroBillScalarFieldEnum[]
  }

  /**
   * XeroBill findFirstOrThrow
   */
  export type XeroBillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * Filter, which XeroBill to fetch.
     */
    where?: XeroBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroBills to fetch.
     */
    orderBy?: XeroBillOrderByWithRelationInput | XeroBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroBills.
     */
    cursor?: XeroBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroBills.
     */
    distinct?: XeroBillScalarFieldEnum | XeroBillScalarFieldEnum[]
  }

  /**
   * XeroBill findMany
   */
  export type XeroBillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * Filter, which XeroBills to fetch.
     */
    where?: XeroBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroBills to fetch.
     */
    orderBy?: XeroBillOrderByWithRelationInput | XeroBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XeroBills.
     */
    cursor?: XeroBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroBills.
     */
    skip?: number
    distinct?: XeroBillScalarFieldEnum | XeroBillScalarFieldEnum[]
  }

  /**
   * XeroBill create
   */
  export type XeroBillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * The data needed to create a XeroBill.
     */
    data: XOR<XeroBillCreateInput, XeroBillUncheckedCreateInput>
  }

  /**
   * XeroBill createMany
   */
  export type XeroBillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XeroBills.
     */
    data: XeroBillCreateManyInput | XeroBillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroBill createManyAndReturn
   */
  export type XeroBillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * The data used to create many XeroBills.
     */
    data: XeroBillCreateManyInput | XeroBillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XeroBill update
   */
  export type XeroBillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * The data needed to update a XeroBill.
     */
    data: XOR<XeroBillUpdateInput, XeroBillUncheckedUpdateInput>
    /**
     * Choose, which XeroBill to update.
     */
    where: XeroBillWhereUniqueInput
  }

  /**
   * XeroBill updateMany
   */
  export type XeroBillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XeroBills.
     */
    data: XOR<XeroBillUpdateManyMutationInput, XeroBillUncheckedUpdateManyInput>
    /**
     * Filter which XeroBills to update
     */
    where?: XeroBillWhereInput
    /**
     * Limit how many XeroBills to update.
     */
    limit?: number
  }

  /**
   * XeroBill updateManyAndReturn
   */
  export type XeroBillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * The data used to update XeroBills.
     */
    data: XOR<XeroBillUpdateManyMutationInput, XeroBillUncheckedUpdateManyInput>
    /**
     * Filter which XeroBills to update
     */
    where?: XeroBillWhereInput
    /**
     * Limit how many XeroBills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * XeroBill upsert
   */
  export type XeroBillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * The filter to search for the XeroBill to update in case it exists.
     */
    where: XeroBillWhereUniqueInput
    /**
     * In case the XeroBill found by the `where` argument doesn't exist, create a new XeroBill with this data.
     */
    create: XOR<XeroBillCreateInput, XeroBillUncheckedCreateInput>
    /**
     * In case the XeroBill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XeroBillUpdateInput, XeroBillUncheckedUpdateInput>
  }

  /**
   * XeroBill delete
   */
  export type XeroBillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    /**
     * Filter which XeroBill to delete.
     */
    where: XeroBillWhereUniqueInput
  }

  /**
   * XeroBill deleteMany
   */
  export type XeroBillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroBills to delete
     */
    where?: XeroBillWhereInput
    /**
     * Limit how many XeroBills to delete.
     */
    limit?: number
  }

  /**
   * XeroBill.payments
   */
  export type XeroBill$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    where?: XeroPaymentWhereInput
    orderBy?: XeroPaymentOrderByWithRelationInput | XeroPaymentOrderByWithRelationInput[]
    cursor?: XeroPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: XeroPaymentScalarFieldEnum | XeroPaymentScalarFieldEnum[]
  }

  /**
   * XeroBill without action
   */
  export type XeroBillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
  }


  /**
   * Model XeroPayment
   */

  export type AggregateXeroPayment = {
    _count: XeroPaymentCountAggregateOutputType | null
    _avg: XeroPaymentAvgAggregateOutputType | null
    _sum: XeroPaymentSumAggregateOutputType | null
    _min: XeroPaymentMinAggregateOutputType | null
    _max: XeroPaymentMaxAggregateOutputType | null
  }

  export type XeroPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type XeroPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type XeroPaymentMinAggregateOutputType = {
    id: string | null
    xeroId: string | null
    date: Date | null
    amount: number | null
    currencyCode: string | null
    paymentType: string | null
    status: string | null
    isReconciled: boolean | null
    reference: string | null
    batchPaymentId: string | null
    contactId: string | null
    invoiceId: string | null
    billId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroPaymentMaxAggregateOutputType = {
    id: string | null
    xeroId: string | null
    date: Date | null
    amount: number | null
    currencyCode: string | null
    paymentType: string | null
    status: string | null
    isReconciled: boolean | null
    reference: string | null
    batchPaymentId: string | null
    contactId: string | null
    invoiceId: string | null
    billId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroPaymentCountAggregateOutputType = {
    id: number
    xeroId: number
    date: number
    amount: number
    currencyCode: number
    paymentType: number
    status: number
    isReconciled: number
    reference: number
    batchPaymentId: number
    contactId: number
    invoiceId: number
    billId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XeroPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type XeroPaymentSumAggregateInputType = {
    amount?: true
  }

  export type XeroPaymentMinAggregateInputType = {
    id?: true
    xeroId?: true
    date?: true
    amount?: true
    currencyCode?: true
    paymentType?: true
    status?: true
    isReconciled?: true
    reference?: true
    batchPaymentId?: true
    contactId?: true
    invoiceId?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroPaymentMaxAggregateInputType = {
    id?: true
    xeroId?: true
    date?: true
    amount?: true
    currencyCode?: true
    paymentType?: true
    status?: true
    isReconciled?: true
    reference?: true
    batchPaymentId?: true
    contactId?: true
    invoiceId?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroPaymentCountAggregateInputType = {
    id?: true
    xeroId?: true
    date?: true
    amount?: true
    currencyCode?: true
    paymentType?: true
    status?: true
    isReconciled?: true
    reference?: true
    batchPaymentId?: true
    contactId?: true
    invoiceId?: true
    billId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XeroPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroPayment to aggregate.
     */
    where?: XeroPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroPayments to fetch.
     */
    orderBy?: XeroPaymentOrderByWithRelationInput | XeroPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XeroPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XeroPayments
    **/
    _count?: true | XeroPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XeroPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XeroPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XeroPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XeroPaymentMaxAggregateInputType
  }

  export type GetXeroPaymentAggregateType<T extends XeroPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateXeroPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXeroPayment[P]>
      : GetScalarType<T[P], AggregateXeroPayment[P]>
  }




  export type XeroPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroPaymentWhereInput
    orderBy?: XeroPaymentOrderByWithAggregationInput | XeroPaymentOrderByWithAggregationInput[]
    by: XeroPaymentScalarFieldEnum[] | XeroPaymentScalarFieldEnum
    having?: XeroPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XeroPaymentCountAggregateInputType | true
    _avg?: XeroPaymentAvgAggregateInputType
    _sum?: XeroPaymentSumAggregateInputType
    _min?: XeroPaymentMinAggregateInputType
    _max?: XeroPaymentMaxAggregateInputType
  }

  export type XeroPaymentGroupByOutputType = {
    id: string
    xeroId: string
    date: Date | null
    amount: number | null
    currencyCode: string
    paymentType: string | null
    status: string | null
    isReconciled: boolean
    reference: string | null
    batchPaymentId: string | null
    contactId: string | null
    invoiceId: string | null
    billId: string | null
    createdAt: Date
    updatedAt: Date
    _count: XeroPaymentCountAggregateOutputType | null
    _avg: XeroPaymentAvgAggregateOutputType | null
    _sum: XeroPaymentSumAggregateOutputType | null
    _min: XeroPaymentMinAggregateOutputType | null
    _max: XeroPaymentMaxAggregateOutputType | null
  }

  type GetXeroPaymentGroupByPayload<T extends XeroPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XeroPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XeroPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XeroPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], XeroPaymentGroupByOutputType[P]>
        }
      >
    >


  export type XeroPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    date?: boolean
    amount?: boolean
    currencyCode?: boolean
    paymentType?: boolean
    status?: boolean
    isReconciled?: boolean
    reference?: boolean
    batchPaymentId?: boolean
    contactId?: boolean
    invoiceId?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroPayment$contactArgs<ExtArgs>
    invoice?: boolean | XeroPayment$invoiceArgs<ExtArgs>
    bill?: boolean | XeroPayment$billArgs<ExtArgs>
  }, ExtArgs["result"]["xeroPayment"]>

  export type XeroPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    date?: boolean
    amount?: boolean
    currencyCode?: boolean
    paymentType?: boolean
    status?: boolean
    isReconciled?: boolean
    reference?: boolean
    batchPaymentId?: boolean
    contactId?: boolean
    invoiceId?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroPayment$contactArgs<ExtArgs>
    invoice?: boolean | XeroPayment$invoiceArgs<ExtArgs>
    bill?: boolean | XeroPayment$billArgs<ExtArgs>
  }, ExtArgs["result"]["xeroPayment"]>

  export type XeroPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    date?: boolean
    amount?: boolean
    currencyCode?: boolean
    paymentType?: boolean
    status?: boolean
    isReconciled?: boolean
    reference?: boolean
    batchPaymentId?: boolean
    contactId?: boolean
    invoiceId?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | XeroPayment$contactArgs<ExtArgs>
    invoice?: boolean | XeroPayment$invoiceArgs<ExtArgs>
    bill?: boolean | XeroPayment$billArgs<ExtArgs>
  }, ExtArgs["result"]["xeroPayment"]>

  export type XeroPaymentSelectScalar = {
    id?: boolean
    xeroId?: boolean
    date?: boolean
    amount?: boolean
    currencyCode?: boolean
    paymentType?: boolean
    status?: boolean
    isReconciled?: boolean
    reference?: boolean
    batchPaymentId?: boolean
    contactId?: boolean
    invoiceId?: boolean
    billId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XeroPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xeroId" | "date" | "amount" | "currencyCode" | "paymentType" | "status" | "isReconciled" | "reference" | "batchPaymentId" | "contactId" | "invoiceId" | "billId" | "createdAt" | "updatedAt", ExtArgs["result"]["xeroPayment"]>
  export type XeroPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroPayment$contactArgs<ExtArgs>
    invoice?: boolean | XeroPayment$invoiceArgs<ExtArgs>
    bill?: boolean | XeroPayment$billArgs<ExtArgs>
  }
  export type XeroPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroPayment$contactArgs<ExtArgs>
    invoice?: boolean | XeroPayment$invoiceArgs<ExtArgs>
    bill?: boolean | XeroPayment$billArgs<ExtArgs>
  }
  export type XeroPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | XeroPayment$contactArgs<ExtArgs>
    invoice?: boolean | XeroPayment$invoiceArgs<ExtArgs>
    bill?: boolean | XeroPayment$billArgs<ExtArgs>
  }

  export type $XeroPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XeroPayment"
    objects: {
      contact: Prisma.$XeroContactPayload<ExtArgs> | null
      invoice: Prisma.$XeroInvoicePayload<ExtArgs> | null
      bill: Prisma.$XeroBillPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      xeroId: string
      date: Date | null
      amount: number | null
      currencyCode: string
      paymentType: string | null
      status: string | null
      isReconciled: boolean
      reference: string | null
      batchPaymentId: string | null
      contactId: string | null
      invoiceId: string | null
      billId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xeroPayment"]>
    composites: {}
  }

  type XeroPaymentGetPayload<S extends boolean | null | undefined | XeroPaymentDefaultArgs> = $Result.GetResult<Prisma.$XeroPaymentPayload, S>

  type XeroPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XeroPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XeroPaymentCountAggregateInputType | true
    }

  export interface XeroPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XeroPayment'], meta: { name: 'XeroPayment' } }
    /**
     * Find zero or one XeroPayment that matches the filter.
     * @param {XeroPaymentFindUniqueArgs} args - Arguments to find a XeroPayment
     * @example
     * // Get one XeroPayment
     * const xeroPayment = await prisma.xeroPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XeroPaymentFindUniqueArgs>(args: SelectSubset<T, XeroPaymentFindUniqueArgs<ExtArgs>>): Prisma__XeroPaymentClient<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XeroPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XeroPaymentFindUniqueOrThrowArgs} args - Arguments to find a XeroPayment
     * @example
     * // Get one XeroPayment
     * const xeroPayment = await prisma.xeroPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XeroPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, XeroPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XeroPaymentClient<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroPaymentFindFirstArgs} args - Arguments to find a XeroPayment
     * @example
     * // Get one XeroPayment
     * const xeroPayment = await prisma.xeroPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XeroPaymentFindFirstArgs>(args?: SelectSubset<T, XeroPaymentFindFirstArgs<ExtArgs>>): Prisma__XeroPaymentClient<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroPaymentFindFirstOrThrowArgs} args - Arguments to find a XeroPayment
     * @example
     * // Get one XeroPayment
     * const xeroPayment = await prisma.xeroPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XeroPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, XeroPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__XeroPaymentClient<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XeroPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XeroPayments
     * const xeroPayments = await prisma.xeroPayment.findMany()
     * 
     * // Get first 10 XeroPayments
     * const xeroPayments = await prisma.xeroPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xeroPaymentWithIdOnly = await prisma.xeroPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XeroPaymentFindManyArgs>(args?: SelectSubset<T, XeroPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XeroPayment.
     * @param {XeroPaymentCreateArgs} args - Arguments to create a XeroPayment.
     * @example
     * // Create one XeroPayment
     * const XeroPayment = await prisma.xeroPayment.create({
     *   data: {
     *     // ... data to create a XeroPayment
     *   }
     * })
     * 
     */
    create<T extends XeroPaymentCreateArgs>(args: SelectSubset<T, XeroPaymentCreateArgs<ExtArgs>>): Prisma__XeroPaymentClient<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XeroPayments.
     * @param {XeroPaymentCreateManyArgs} args - Arguments to create many XeroPayments.
     * @example
     * // Create many XeroPayments
     * const xeroPayment = await prisma.xeroPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XeroPaymentCreateManyArgs>(args?: SelectSubset<T, XeroPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XeroPayments and returns the data saved in the database.
     * @param {XeroPaymentCreateManyAndReturnArgs} args - Arguments to create many XeroPayments.
     * @example
     * // Create many XeroPayments
     * const xeroPayment = await prisma.xeroPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XeroPayments and only return the `id`
     * const xeroPaymentWithIdOnly = await prisma.xeroPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XeroPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, XeroPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XeroPayment.
     * @param {XeroPaymentDeleteArgs} args - Arguments to delete one XeroPayment.
     * @example
     * // Delete one XeroPayment
     * const XeroPayment = await prisma.xeroPayment.delete({
     *   where: {
     *     // ... filter to delete one XeroPayment
     *   }
     * })
     * 
     */
    delete<T extends XeroPaymentDeleteArgs>(args: SelectSubset<T, XeroPaymentDeleteArgs<ExtArgs>>): Prisma__XeroPaymentClient<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XeroPayment.
     * @param {XeroPaymentUpdateArgs} args - Arguments to update one XeroPayment.
     * @example
     * // Update one XeroPayment
     * const xeroPayment = await prisma.xeroPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XeroPaymentUpdateArgs>(args: SelectSubset<T, XeroPaymentUpdateArgs<ExtArgs>>): Prisma__XeroPaymentClient<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XeroPayments.
     * @param {XeroPaymentDeleteManyArgs} args - Arguments to filter XeroPayments to delete.
     * @example
     * // Delete a few XeroPayments
     * const { count } = await prisma.xeroPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XeroPaymentDeleteManyArgs>(args?: SelectSubset<T, XeroPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XeroPayments
     * const xeroPayment = await prisma.xeroPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XeroPaymentUpdateManyArgs>(args: SelectSubset<T, XeroPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroPayments and returns the data updated in the database.
     * @param {XeroPaymentUpdateManyAndReturnArgs} args - Arguments to update many XeroPayments.
     * @example
     * // Update many XeroPayments
     * const xeroPayment = await prisma.xeroPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XeroPayments and only return the `id`
     * const xeroPaymentWithIdOnly = await prisma.xeroPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XeroPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, XeroPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XeroPayment.
     * @param {XeroPaymentUpsertArgs} args - Arguments to update or create a XeroPayment.
     * @example
     * // Update or create a XeroPayment
     * const xeroPayment = await prisma.xeroPayment.upsert({
     *   create: {
     *     // ... data to create a XeroPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XeroPayment we want to update
     *   }
     * })
     */
    upsert<T extends XeroPaymentUpsertArgs>(args: SelectSubset<T, XeroPaymentUpsertArgs<ExtArgs>>): Prisma__XeroPaymentClient<$Result.GetResult<Prisma.$XeroPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XeroPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroPaymentCountArgs} args - Arguments to filter XeroPayments to count.
     * @example
     * // Count the number of XeroPayments
     * const count = await prisma.xeroPayment.count({
     *   where: {
     *     // ... the filter for the XeroPayments we want to count
     *   }
     * })
    **/
    count<T extends XeroPaymentCountArgs>(
      args?: Subset<T, XeroPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XeroPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XeroPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XeroPaymentAggregateArgs>(args: Subset<T, XeroPaymentAggregateArgs>): Prisma.PrismaPromise<GetXeroPaymentAggregateType<T>>

    /**
     * Group by XeroPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XeroPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XeroPaymentGroupByArgs['orderBy'] }
        : { orderBy?: XeroPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XeroPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXeroPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XeroPayment model
   */
  readonly fields: XeroPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XeroPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XeroPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends XeroPayment$contactArgs<ExtArgs> = {}>(args?: Subset<T, XeroPayment$contactArgs<ExtArgs>>): Prisma__XeroContactClient<$Result.GetResult<Prisma.$XeroContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoice<T extends XeroPayment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, XeroPayment$invoiceArgs<ExtArgs>>): Prisma__XeroInvoiceClient<$Result.GetResult<Prisma.$XeroInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bill<T extends XeroPayment$billArgs<ExtArgs> = {}>(args?: Subset<T, XeroPayment$billArgs<ExtArgs>>): Prisma__XeroBillClient<$Result.GetResult<Prisma.$XeroBillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XeroPayment model
   */
  interface XeroPaymentFieldRefs {
    readonly id: FieldRef<"XeroPayment", 'String'>
    readonly xeroId: FieldRef<"XeroPayment", 'String'>
    readonly date: FieldRef<"XeroPayment", 'DateTime'>
    readonly amount: FieldRef<"XeroPayment", 'Float'>
    readonly currencyCode: FieldRef<"XeroPayment", 'String'>
    readonly paymentType: FieldRef<"XeroPayment", 'String'>
    readonly status: FieldRef<"XeroPayment", 'String'>
    readonly isReconciled: FieldRef<"XeroPayment", 'Boolean'>
    readonly reference: FieldRef<"XeroPayment", 'String'>
    readonly batchPaymentId: FieldRef<"XeroPayment", 'String'>
    readonly contactId: FieldRef<"XeroPayment", 'String'>
    readonly invoiceId: FieldRef<"XeroPayment", 'String'>
    readonly billId: FieldRef<"XeroPayment", 'String'>
    readonly createdAt: FieldRef<"XeroPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"XeroPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XeroPayment findUnique
   */
  export type XeroPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * Filter, which XeroPayment to fetch.
     */
    where: XeroPaymentWhereUniqueInput
  }

  /**
   * XeroPayment findUniqueOrThrow
   */
  export type XeroPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * Filter, which XeroPayment to fetch.
     */
    where: XeroPaymentWhereUniqueInput
  }

  /**
   * XeroPayment findFirst
   */
  export type XeroPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * Filter, which XeroPayment to fetch.
     */
    where?: XeroPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroPayments to fetch.
     */
    orderBy?: XeroPaymentOrderByWithRelationInput | XeroPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroPayments.
     */
    cursor?: XeroPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroPayments.
     */
    distinct?: XeroPaymentScalarFieldEnum | XeroPaymentScalarFieldEnum[]
  }

  /**
   * XeroPayment findFirstOrThrow
   */
  export type XeroPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * Filter, which XeroPayment to fetch.
     */
    where?: XeroPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroPayments to fetch.
     */
    orderBy?: XeroPaymentOrderByWithRelationInput | XeroPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroPayments.
     */
    cursor?: XeroPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroPayments.
     */
    distinct?: XeroPaymentScalarFieldEnum | XeroPaymentScalarFieldEnum[]
  }

  /**
   * XeroPayment findMany
   */
  export type XeroPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * Filter, which XeroPayments to fetch.
     */
    where?: XeroPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroPayments to fetch.
     */
    orderBy?: XeroPaymentOrderByWithRelationInput | XeroPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XeroPayments.
     */
    cursor?: XeroPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroPayments.
     */
    skip?: number
    distinct?: XeroPaymentScalarFieldEnum | XeroPaymentScalarFieldEnum[]
  }

  /**
   * XeroPayment create
   */
  export type XeroPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a XeroPayment.
     */
    data: XOR<XeroPaymentCreateInput, XeroPaymentUncheckedCreateInput>
  }

  /**
   * XeroPayment createMany
   */
  export type XeroPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XeroPayments.
     */
    data: XeroPaymentCreateManyInput | XeroPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroPayment createManyAndReturn
   */
  export type XeroPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many XeroPayments.
     */
    data: XeroPaymentCreateManyInput | XeroPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * XeroPayment update
   */
  export type XeroPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a XeroPayment.
     */
    data: XOR<XeroPaymentUpdateInput, XeroPaymentUncheckedUpdateInput>
    /**
     * Choose, which XeroPayment to update.
     */
    where: XeroPaymentWhereUniqueInput
  }

  /**
   * XeroPayment updateMany
   */
  export type XeroPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XeroPayments.
     */
    data: XOR<XeroPaymentUpdateManyMutationInput, XeroPaymentUncheckedUpdateManyInput>
    /**
     * Filter which XeroPayments to update
     */
    where?: XeroPaymentWhereInput
    /**
     * Limit how many XeroPayments to update.
     */
    limit?: number
  }

  /**
   * XeroPayment updateManyAndReturn
   */
  export type XeroPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * The data used to update XeroPayments.
     */
    data: XOR<XeroPaymentUpdateManyMutationInput, XeroPaymentUncheckedUpdateManyInput>
    /**
     * Filter which XeroPayments to update
     */
    where?: XeroPaymentWhereInput
    /**
     * Limit how many XeroPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * XeroPayment upsert
   */
  export type XeroPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the XeroPayment to update in case it exists.
     */
    where: XeroPaymentWhereUniqueInput
    /**
     * In case the XeroPayment found by the `where` argument doesn't exist, create a new XeroPayment with this data.
     */
    create: XOR<XeroPaymentCreateInput, XeroPaymentUncheckedCreateInput>
    /**
     * In case the XeroPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XeroPaymentUpdateInput, XeroPaymentUncheckedUpdateInput>
  }

  /**
   * XeroPayment delete
   */
  export type XeroPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
    /**
     * Filter which XeroPayment to delete.
     */
    where: XeroPaymentWhereUniqueInput
  }

  /**
   * XeroPayment deleteMany
   */
  export type XeroPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroPayments to delete
     */
    where?: XeroPaymentWhereInput
    /**
     * Limit how many XeroPayments to delete.
     */
    limit?: number
  }

  /**
   * XeroPayment.contact
   */
  export type XeroPayment$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroContact
     */
    select?: XeroContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroContact
     */
    omit?: XeroContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroContactInclude<ExtArgs> | null
    where?: XeroContactWhereInput
  }

  /**
   * XeroPayment.invoice
   */
  export type XeroPayment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroInvoice
     */
    select?: XeroInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroInvoice
     */
    omit?: XeroInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroInvoiceInclude<ExtArgs> | null
    where?: XeroInvoiceWhereInput
  }

  /**
   * XeroPayment.bill
   */
  export type XeroPayment$billArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBill
     */
    select?: XeroBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBill
     */
    omit?: XeroBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroBillInclude<ExtArgs> | null
    where?: XeroBillWhereInput
  }

  /**
   * XeroPayment without action
   */
  export type XeroPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroPayment
     */
    select?: XeroPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroPayment
     */
    omit?: XeroPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XeroPaymentInclude<ExtArgs> | null
  }


  /**
   * Model XeroBankTransaction
   */

  export type AggregateXeroBankTransaction = {
    _count: XeroBankTransactionCountAggregateOutputType | null
    _avg: XeroBankTransactionAvgAggregateOutputType | null
    _sum: XeroBankTransactionSumAggregateOutputType | null
    _min: XeroBankTransactionMinAggregateOutputType | null
    _max: XeroBankTransactionMaxAggregateOutputType | null
  }

  export type XeroBankTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type XeroBankTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type XeroBankTransactionMinAggregateOutputType = {
    id: string | null
    xeroId: string | null
    bankAccountId: string | null
    type: string | null
    date: Date | null
    reference: string | null
    amount: number | null
    currencyCode: string | null
    status: string | null
    isReconciled: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroBankTransactionMaxAggregateOutputType = {
    id: string | null
    xeroId: string | null
    bankAccountId: string | null
    type: string | null
    date: Date | null
    reference: string | null
    amount: number | null
    currencyCode: string | null
    status: string | null
    isReconciled: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroBankTransactionCountAggregateOutputType = {
    id: number
    xeroId: number
    bankAccountId: number
    type: number
    date: number
    reference: number
    amount: number
    currencyCode: number
    status: number
    isReconciled: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XeroBankTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type XeroBankTransactionSumAggregateInputType = {
    amount?: true
  }

  export type XeroBankTransactionMinAggregateInputType = {
    id?: true
    xeroId?: true
    bankAccountId?: true
    type?: true
    date?: true
    reference?: true
    amount?: true
    currencyCode?: true
    status?: true
    isReconciled?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroBankTransactionMaxAggregateInputType = {
    id?: true
    xeroId?: true
    bankAccountId?: true
    type?: true
    date?: true
    reference?: true
    amount?: true
    currencyCode?: true
    status?: true
    isReconciled?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroBankTransactionCountAggregateInputType = {
    id?: true
    xeroId?: true
    bankAccountId?: true
    type?: true
    date?: true
    reference?: true
    amount?: true
    currencyCode?: true
    status?: true
    isReconciled?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XeroBankTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroBankTransaction to aggregate.
     */
    where?: XeroBankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroBankTransactions to fetch.
     */
    orderBy?: XeroBankTransactionOrderByWithRelationInput | XeroBankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XeroBankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroBankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroBankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XeroBankTransactions
    **/
    _count?: true | XeroBankTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: XeroBankTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: XeroBankTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XeroBankTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XeroBankTransactionMaxAggregateInputType
  }

  export type GetXeroBankTransactionAggregateType<T extends XeroBankTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateXeroBankTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXeroBankTransaction[P]>
      : GetScalarType<T[P], AggregateXeroBankTransaction[P]>
  }




  export type XeroBankTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroBankTransactionWhereInput
    orderBy?: XeroBankTransactionOrderByWithAggregationInput | XeroBankTransactionOrderByWithAggregationInput[]
    by: XeroBankTransactionScalarFieldEnum[] | XeroBankTransactionScalarFieldEnum
    having?: XeroBankTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XeroBankTransactionCountAggregateInputType | true
    _avg?: XeroBankTransactionAvgAggregateInputType
    _sum?: XeroBankTransactionSumAggregateInputType
    _min?: XeroBankTransactionMinAggregateInputType
    _max?: XeroBankTransactionMaxAggregateInputType
  }

  export type XeroBankTransactionGroupByOutputType = {
    id: string
    xeroId: string
    bankAccountId: string | null
    type: string
    date: Date | null
    reference: string | null
    amount: number | null
    currencyCode: string
    status: string | null
    isReconciled: boolean
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: XeroBankTransactionCountAggregateOutputType | null
    _avg: XeroBankTransactionAvgAggregateOutputType | null
    _sum: XeroBankTransactionSumAggregateOutputType | null
    _min: XeroBankTransactionMinAggregateOutputType | null
    _max: XeroBankTransactionMaxAggregateOutputType | null
  }

  type GetXeroBankTransactionGroupByPayload<T extends XeroBankTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XeroBankTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XeroBankTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XeroBankTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], XeroBankTransactionGroupByOutputType[P]>
        }
      >
    >


  export type XeroBankTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    bankAccountId?: boolean
    type?: boolean
    date?: boolean
    reference?: boolean
    amount?: boolean
    currencyCode?: boolean
    status?: boolean
    isReconciled?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroBankTransaction"]>

  export type XeroBankTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    bankAccountId?: boolean
    type?: boolean
    date?: boolean
    reference?: boolean
    amount?: boolean
    currencyCode?: boolean
    status?: boolean
    isReconciled?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroBankTransaction"]>

  export type XeroBankTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    bankAccountId?: boolean
    type?: boolean
    date?: boolean
    reference?: boolean
    amount?: boolean
    currencyCode?: boolean
    status?: boolean
    isReconciled?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroBankTransaction"]>

  export type XeroBankTransactionSelectScalar = {
    id?: boolean
    xeroId?: boolean
    bankAccountId?: boolean
    type?: boolean
    date?: boolean
    reference?: boolean
    amount?: boolean
    currencyCode?: boolean
    status?: boolean
    isReconciled?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XeroBankTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xeroId" | "bankAccountId" | "type" | "date" | "reference" | "amount" | "currencyCode" | "status" | "isReconciled" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["xeroBankTransaction"]>

  export type $XeroBankTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XeroBankTransaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      xeroId: string
      bankAccountId: string | null
      type: string
      date: Date | null
      reference: string | null
      amount: number | null
      currencyCode: string
      status: string | null
      isReconciled: boolean
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xeroBankTransaction"]>
    composites: {}
  }

  type XeroBankTransactionGetPayload<S extends boolean | null | undefined | XeroBankTransactionDefaultArgs> = $Result.GetResult<Prisma.$XeroBankTransactionPayload, S>

  type XeroBankTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XeroBankTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XeroBankTransactionCountAggregateInputType | true
    }

  export interface XeroBankTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XeroBankTransaction'], meta: { name: 'XeroBankTransaction' } }
    /**
     * Find zero or one XeroBankTransaction that matches the filter.
     * @param {XeroBankTransactionFindUniqueArgs} args - Arguments to find a XeroBankTransaction
     * @example
     * // Get one XeroBankTransaction
     * const xeroBankTransaction = await prisma.xeroBankTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XeroBankTransactionFindUniqueArgs>(args: SelectSubset<T, XeroBankTransactionFindUniqueArgs<ExtArgs>>): Prisma__XeroBankTransactionClient<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XeroBankTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XeroBankTransactionFindUniqueOrThrowArgs} args - Arguments to find a XeroBankTransaction
     * @example
     * // Get one XeroBankTransaction
     * const xeroBankTransaction = await prisma.xeroBankTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XeroBankTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, XeroBankTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XeroBankTransactionClient<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroBankTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBankTransactionFindFirstArgs} args - Arguments to find a XeroBankTransaction
     * @example
     * // Get one XeroBankTransaction
     * const xeroBankTransaction = await prisma.xeroBankTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XeroBankTransactionFindFirstArgs>(args?: SelectSubset<T, XeroBankTransactionFindFirstArgs<ExtArgs>>): Prisma__XeroBankTransactionClient<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroBankTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBankTransactionFindFirstOrThrowArgs} args - Arguments to find a XeroBankTransaction
     * @example
     * // Get one XeroBankTransaction
     * const xeroBankTransaction = await prisma.xeroBankTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XeroBankTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, XeroBankTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__XeroBankTransactionClient<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XeroBankTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBankTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XeroBankTransactions
     * const xeroBankTransactions = await prisma.xeroBankTransaction.findMany()
     * 
     * // Get first 10 XeroBankTransactions
     * const xeroBankTransactions = await prisma.xeroBankTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xeroBankTransactionWithIdOnly = await prisma.xeroBankTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XeroBankTransactionFindManyArgs>(args?: SelectSubset<T, XeroBankTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XeroBankTransaction.
     * @param {XeroBankTransactionCreateArgs} args - Arguments to create a XeroBankTransaction.
     * @example
     * // Create one XeroBankTransaction
     * const XeroBankTransaction = await prisma.xeroBankTransaction.create({
     *   data: {
     *     // ... data to create a XeroBankTransaction
     *   }
     * })
     * 
     */
    create<T extends XeroBankTransactionCreateArgs>(args: SelectSubset<T, XeroBankTransactionCreateArgs<ExtArgs>>): Prisma__XeroBankTransactionClient<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XeroBankTransactions.
     * @param {XeroBankTransactionCreateManyArgs} args - Arguments to create many XeroBankTransactions.
     * @example
     * // Create many XeroBankTransactions
     * const xeroBankTransaction = await prisma.xeroBankTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XeroBankTransactionCreateManyArgs>(args?: SelectSubset<T, XeroBankTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XeroBankTransactions and returns the data saved in the database.
     * @param {XeroBankTransactionCreateManyAndReturnArgs} args - Arguments to create many XeroBankTransactions.
     * @example
     * // Create many XeroBankTransactions
     * const xeroBankTransaction = await prisma.xeroBankTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XeroBankTransactions and only return the `id`
     * const xeroBankTransactionWithIdOnly = await prisma.xeroBankTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XeroBankTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, XeroBankTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XeroBankTransaction.
     * @param {XeroBankTransactionDeleteArgs} args - Arguments to delete one XeroBankTransaction.
     * @example
     * // Delete one XeroBankTransaction
     * const XeroBankTransaction = await prisma.xeroBankTransaction.delete({
     *   where: {
     *     // ... filter to delete one XeroBankTransaction
     *   }
     * })
     * 
     */
    delete<T extends XeroBankTransactionDeleteArgs>(args: SelectSubset<T, XeroBankTransactionDeleteArgs<ExtArgs>>): Prisma__XeroBankTransactionClient<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XeroBankTransaction.
     * @param {XeroBankTransactionUpdateArgs} args - Arguments to update one XeroBankTransaction.
     * @example
     * // Update one XeroBankTransaction
     * const xeroBankTransaction = await prisma.xeroBankTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XeroBankTransactionUpdateArgs>(args: SelectSubset<T, XeroBankTransactionUpdateArgs<ExtArgs>>): Prisma__XeroBankTransactionClient<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XeroBankTransactions.
     * @param {XeroBankTransactionDeleteManyArgs} args - Arguments to filter XeroBankTransactions to delete.
     * @example
     * // Delete a few XeroBankTransactions
     * const { count } = await prisma.xeroBankTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XeroBankTransactionDeleteManyArgs>(args?: SelectSubset<T, XeroBankTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroBankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBankTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XeroBankTransactions
     * const xeroBankTransaction = await prisma.xeroBankTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XeroBankTransactionUpdateManyArgs>(args: SelectSubset<T, XeroBankTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroBankTransactions and returns the data updated in the database.
     * @param {XeroBankTransactionUpdateManyAndReturnArgs} args - Arguments to update many XeroBankTransactions.
     * @example
     * // Update many XeroBankTransactions
     * const xeroBankTransaction = await prisma.xeroBankTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XeroBankTransactions and only return the `id`
     * const xeroBankTransactionWithIdOnly = await prisma.xeroBankTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XeroBankTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, XeroBankTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XeroBankTransaction.
     * @param {XeroBankTransactionUpsertArgs} args - Arguments to update or create a XeroBankTransaction.
     * @example
     * // Update or create a XeroBankTransaction
     * const xeroBankTransaction = await prisma.xeroBankTransaction.upsert({
     *   create: {
     *     // ... data to create a XeroBankTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XeroBankTransaction we want to update
     *   }
     * })
     */
    upsert<T extends XeroBankTransactionUpsertArgs>(args: SelectSubset<T, XeroBankTransactionUpsertArgs<ExtArgs>>): Prisma__XeroBankTransactionClient<$Result.GetResult<Prisma.$XeroBankTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XeroBankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBankTransactionCountArgs} args - Arguments to filter XeroBankTransactions to count.
     * @example
     * // Count the number of XeroBankTransactions
     * const count = await prisma.xeroBankTransaction.count({
     *   where: {
     *     // ... the filter for the XeroBankTransactions we want to count
     *   }
     * })
    **/
    count<T extends XeroBankTransactionCountArgs>(
      args?: Subset<T, XeroBankTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XeroBankTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XeroBankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBankTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XeroBankTransactionAggregateArgs>(args: Subset<T, XeroBankTransactionAggregateArgs>): Prisma.PrismaPromise<GetXeroBankTransactionAggregateType<T>>

    /**
     * Group by XeroBankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroBankTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XeroBankTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XeroBankTransactionGroupByArgs['orderBy'] }
        : { orderBy?: XeroBankTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XeroBankTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXeroBankTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XeroBankTransaction model
   */
  readonly fields: XeroBankTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XeroBankTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XeroBankTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XeroBankTransaction model
   */
  interface XeroBankTransactionFieldRefs {
    readonly id: FieldRef<"XeroBankTransaction", 'String'>
    readonly xeroId: FieldRef<"XeroBankTransaction", 'String'>
    readonly bankAccountId: FieldRef<"XeroBankTransaction", 'String'>
    readonly type: FieldRef<"XeroBankTransaction", 'String'>
    readonly date: FieldRef<"XeroBankTransaction", 'DateTime'>
    readonly reference: FieldRef<"XeroBankTransaction", 'String'>
    readonly amount: FieldRef<"XeroBankTransaction", 'Float'>
    readonly currencyCode: FieldRef<"XeroBankTransaction", 'String'>
    readonly status: FieldRef<"XeroBankTransaction", 'String'>
    readonly isReconciled: FieldRef<"XeroBankTransaction", 'Boolean'>
    readonly description: FieldRef<"XeroBankTransaction", 'String'>
    readonly createdAt: FieldRef<"XeroBankTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"XeroBankTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XeroBankTransaction findUnique
   */
  export type XeroBankTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * Filter, which XeroBankTransaction to fetch.
     */
    where: XeroBankTransactionWhereUniqueInput
  }

  /**
   * XeroBankTransaction findUniqueOrThrow
   */
  export type XeroBankTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * Filter, which XeroBankTransaction to fetch.
     */
    where: XeroBankTransactionWhereUniqueInput
  }

  /**
   * XeroBankTransaction findFirst
   */
  export type XeroBankTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * Filter, which XeroBankTransaction to fetch.
     */
    where?: XeroBankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroBankTransactions to fetch.
     */
    orderBy?: XeroBankTransactionOrderByWithRelationInput | XeroBankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroBankTransactions.
     */
    cursor?: XeroBankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroBankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroBankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroBankTransactions.
     */
    distinct?: XeroBankTransactionScalarFieldEnum | XeroBankTransactionScalarFieldEnum[]
  }

  /**
   * XeroBankTransaction findFirstOrThrow
   */
  export type XeroBankTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * Filter, which XeroBankTransaction to fetch.
     */
    where?: XeroBankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroBankTransactions to fetch.
     */
    orderBy?: XeroBankTransactionOrderByWithRelationInput | XeroBankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroBankTransactions.
     */
    cursor?: XeroBankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroBankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroBankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroBankTransactions.
     */
    distinct?: XeroBankTransactionScalarFieldEnum | XeroBankTransactionScalarFieldEnum[]
  }

  /**
   * XeroBankTransaction findMany
   */
  export type XeroBankTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * Filter, which XeroBankTransactions to fetch.
     */
    where?: XeroBankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroBankTransactions to fetch.
     */
    orderBy?: XeroBankTransactionOrderByWithRelationInput | XeroBankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XeroBankTransactions.
     */
    cursor?: XeroBankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroBankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroBankTransactions.
     */
    skip?: number
    distinct?: XeroBankTransactionScalarFieldEnum | XeroBankTransactionScalarFieldEnum[]
  }

  /**
   * XeroBankTransaction create
   */
  export type XeroBankTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * The data needed to create a XeroBankTransaction.
     */
    data: XOR<XeroBankTransactionCreateInput, XeroBankTransactionUncheckedCreateInput>
  }

  /**
   * XeroBankTransaction createMany
   */
  export type XeroBankTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XeroBankTransactions.
     */
    data: XeroBankTransactionCreateManyInput | XeroBankTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroBankTransaction createManyAndReturn
   */
  export type XeroBankTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many XeroBankTransactions.
     */
    data: XeroBankTransactionCreateManyInput | XeroBankTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroBankTransaction update
   */
  export type XeroBankTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * The data needed to update a XeroBankTransaction.
     */
    data: XOR<XeroBankTransactionUpdateInput, XeroBankTransactionUncheckedUpdateInput>
    /**
     * Choose, which XeroBankTransaction to update.
     */
    where: XeroBankTransactionWhereUniqueInput
  }

  /**
   * XeroBankTransaction updateMany
   */
  export type XeroBankTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XeroBankTransactions.
     */
    data: XOR<XeroBankTransactionUpdateManyMutationInput, XeroBankTransactionUncheckedUpdateManyInput>
    /**
     * Filter which XeroBankTransactions to update
     */
    where?: XeroBankTransactionWhereInput
    /**
     * Limit how many XeroBankTransactions to update.
     */
    limit?: number
  }

  /**
   * XeroBankTransaction updateManyAndReturn
   */
  export type XeroBankTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * The data used to update XeroBankTransactions.
     */
    data: XOR<XeroBankTransactionUpdateManyMutationInput, XeroBankTransactionUncheckedUpdateManyInput>
    /**
     * Filter which XeroBankTransactions to update
     */
    where?: XeroBankTransactionWhereInput
    /**
     * Limit how many XeroBankTransactions to update.
     */
    limit?: number
  }

  /**
   * XeroBankTransaction upsert
   */
  export type XeroBankTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * The filter to search for the XeroBankTransaction to update in case it exists.
     */
    where: XeroBankTransactionWhereUniqueInput
    /**
     * In case the XeroBankTransaction found by the `where` argument doesn't exist, create a new XeroBankTransaction with this data.
     */
    create: XOR<XeroBankTransactionCreateInput, XeroBankTransactionUncheckedCreateInput>
    /**
     * In case the XeroBankTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XeroBankTransactionUpdateInput, XeroBankTransactionUncheckedUpdateInput>
  }

  /**
   * XeroBankTransaction delete
   */
  export type XeroBankTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
    /**
     * Filter which XeroBankTransaction to delete.
     */
    where: XeroBankTransactionWhereUniqueInput
  }

  /**
   * XeroBankTransaction deleteMany
   */
  export type XeroBankTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroBankTransactions to delete
     */
    where?: XeroBankTransactionWhereInput
    /**
     * Limit how many XeroBankTransactions to delete.
     */
    limit?: number
  }

  /**
   * XeroBankTransaction without action
   */
  export type XeroBankTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroBankTransaction
     */
    select?: XeroBankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroBankTransaction
     */
    omit?: XeroBankTransactionOmit<ExtArgs> | null
  }


  /**
   * Model XeroItem
   */

  export type AggregateXeroItem = {
    _count: XeroItemCountAggregateOutputType | null
    _min: XeroItemMinAggregateOutputType | null
    _max: XeroItemMaxAggregateOutputType | null
  }

  export type XeroItemMinAggregateOutputType = {
    id: string | null
    xeroId: string | null
    code: string | null
    name: string | null
    description: string | null
    isTrackedAsInventory: boolean | null
    isSold: boolean | null
    isPurchased: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroItemMaxAggregateOutputType = {
    id: string | null
    xeroId: string | null
    code: string | null
    name: string | null
    description: string | null
    isTrackedAsInventory: boolean | null
    isSold: boolean | null
    isPurchased: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type XeroItemCountAggregateOutputType = {
    id: number
    xeroId: number
    code: number
    name: number
    description: number
    salesDetails: number
    purchaseDetails: number
    isTrackedAsInventory: number
    isSold: number
    isPurchased: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type XeroItemMinAggregateInputType = {
    id?: true
    xeroId?: true
    code?: true
    name?: true
    description?: true
    isTrackedAsInventory?: true
    isSold?: true
    isPurchased?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroItemMaxAggregateInputType = {
    id?: true
    xeroId?: true
    code?: true
    name?: true
    description?: true
    isTrackedAsInventory?: true
    isSold?: true
    isPurchased?: true
    createdAt?: true
    updatedAt?: true
  }

  export type XeroItemCountAggregateInputType = {
    id?: true
    xeroId?: true
    code?: true
    name?: true
    description?: true
    salesDetails?: true
    purchaseDetails?: true
    isTrackedAsInventory?: true
    isSold?: true
    isPurchased?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type XeroItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroItem to aggregate.
     */
    where?: XeroItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroItems to fetch.
     */
    orderBy?: XeroItemOrderByWithRelationInput | XeroItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: XeroItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned XeroItems
    **/
    _count?: true | XeroItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: XeroItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: XeroItemMaxAggregateInputType
  }

  export type GetXeroItemAggregateType<T extends XeroItemAggregateArgs> = {
        [P in keyof T & keyof AggregateXeroItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXeroItem[P]>
      : GetScalarType<T[P], AggregateXeroItem[P]>
  }




  export type XeroItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: XeroItemWhereInput
    orderBy?: XeroItemOrderByWithAggregationInput | XeroItemOrderByWithAggregationInput[]
    by: XeroItemScalarFieldEnum[] | XeroItemScalarFieldEnum
    having?: XeroItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: XeroItemCountAggregateInputType | true
    _min?: XeroItemMinAggregateInputType
    _max?: XeroItemMaxAggregateInputType
  }

  export type XeroItemGroupByOutputType = {
    id: string
    xeroId: string
    code: string | null
    name: string
    description: string | null
    salesDetails: JsonValue | null
    purchaseDetails: JsonValue | null
    isTrackedAsInventory: boolean
    isSold: boolean
    isPurchased: boolean
    createdAt: Date
    updatedAt: Date
    _count: XeroItemCountAggregateOutputType | null
    _min: XeroItemMinAggregateOutputType | null
    _max: XeroItemMaxAggregateOutputType | null
  }

  type GetXeroItemGroupByPayload<T extends XeroItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XeroItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof XeroItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], XeroItemGroupByOutputType[P]>
            : GetScalarType<T[P], XeroItemGroupByOutputType[P]>
        }
      >
    >


  export type XeroItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    salesDetails?: boolean
    purchaseDetails?: boolean
    isTrackedAsInventory?: boolean
    isSold?: boolean
    isPurchased?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroItem"]>

  export type XeroItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    salesDetails?: boolean
    purchaseDetails?: boolean
    isTrackedAsInventory?: boolean
    isSold?: boolean
    isPurchased?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroItem"]>

  export type XeroItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    xeroId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    salesDetails?: boolean
    purchaseDetails?: boolean
    isTrackedAsInventory?: boolean
    isSold?: boolean
    isPurchased?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["xeroItem"]>

  export type XeroItemSelectScalar = {
    id?: boolean
    xeroId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    salesDetails?: boolean
    purchaseDetails?: boolean
    isTrackedAsInventory?: boolean
    isSold?: boolean
    isPurchased?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type XeroItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "xeroId" | "code" | "name" | "description" | "salesDetails" | "purchaseDetails" | "isTrackedAsInventory" | "isSold" | "isPurchased" | "createdAt" | "updatedAt", ExtArgs["result"]["xeroItem"]>

  export type $XeroItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "XeroItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      xeroId: string
      code: string | null
      name: string
      description: string | null
      salesDetails: Prisma.JsonValue | null
      purchaseDetails: Prisma.JsonValue | null
      isTrackedAsInventory: boolean
      isSold: boolean
      isPurchased: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["xeroItem"]>
    composites: {}
  }

  type XeroItemGetPayload<S extends boolean | null | undefined | XeroItemDefaultArgs> = $Result.GetResult<Prisma.$XeroItemPayload, S>

  type XeroItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<XeroItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: XeroItemCountAggregateInputType | true
    }

  export interface XeroItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XeroItem'], meta: { name: 'XeroItem' } }
    /**
     * Find zero or one XeroItem that matches the filter.
     * @param {XeroItemFindUniqueArgs} args - Arguments to find a XeroItem
     * @example
     * // Get one XeroItem
     * const xeroItem = await prisma.xeroItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XeroItemFindUniqueArgs>(args: SelectSubset<T, XeroItemFindUniqueArgs<ExtArgs>>): Prisma__XeroItemClient<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one XeroItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XeroItemFindUniqueOrThrowArgs} args - Arguments to find a XeroItem
     * @example
     * // Get one XeroItem
     * const xeroItem = await prisma.xeroItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XeroItemFindUniqueOrThrowArgs>(args: SelectSubset<T, XeroItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__XeroItemClient<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroItemFindFirstArgs} args - Arguments to find a XeroItem
     * @example
     * // Get one XeroItem
     * const xeroItem = await prisma.xeroItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XeroItemFindFirstArgs>(args?: SelectSubset<T, XeroItemFindFirstArgs<ExtArgs>>): Prisma__XeroItemClient<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first XeroItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroItemFindFirstOrThrowArgs} args - Arguments to find a XeroItem
     * @example
     * // Get one XeroItem
     * const xeroItem = await prisma.xeroItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XeroItemFindFirstOrThrowArgs>(args?: SelectSubset<T, XeroItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__XeroItemClient<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more XeroItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XeroItems
     * const xeroItems = await prisma.xeroItem.findMany()
     * 
     * // Get first 10 XeroItems
     * const xeroItems = await prisma.xeroItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const xeroItemWithIdOnly = await prisma.xeroItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends XeroItemFindManyArgs>(args?: SelectSubset<T, XeroItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a XeroItem.
     * @param {XeroItemCreateArgs} args - Arguments to create a XeroItem.
     * @example
     * // Create one XeroItem
     * const XeroItem = await prisma.xeroItem.create({
     *   data: {
     *     // ... data to create a XeroItem
     *   }
     * })
     * 
     */
    create<T extends XeroItemCreateArgs>(args: SelectSubset<T, XeroItemCreateArgs<ExtArgs>>): Prisma__XeroItemClient<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many XeroItems.
     * @param {XeroItemCreateManyArgs} args - Arguments to create many XeroItems.
     * @example
     * // Create many XeroItems
     * const xeroItem = await prisma.xeroItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends XeroItemCreateManyArgs>(args?: SelectSubset<T, XeroItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many XeroItems and returns the data saved in the database.
     * @param {XeroItemCreateManyAndReturnArgs} args - Arguments to create many XeroItems.
     * @example
     * // Create many XeroItems
     * const xeroItem = await prisma.xeroItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many XeroItems and only return the `id`
     * const xeroItemWithIdOnly = await prisma.xeroItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends XeroItemCreateManyAndReturnArgs>(args?: SelectSubset<T, XeroItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a XeroItem.
     * @param {XeroItemDeleteArgs} args - Arguments to delete one XeroItem.
     * @example
     * // Delete one XeroItem
     * const XeroItem = await prisma.xeroItem.delete({
     *   where: {
     *     // ... filter to delete one XeroItem
     *   }
     * })
     * 
     */
    delete<T extends XeroItemDeleteArgs>(args: SelectSubset<T, XeroItemDeleteArgs<ExtArgs>>): Prisma__XeroItemClient<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one XeroItem.
     * @param {XeroItemUpdateArgs} args - Arguments to update one XeroItem.
     * @example
     * // Update one XeroItem
     * const xeroItem = await prisma.xeroItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends XeroItemUpdateArgs>(args: SelectSubset<T, XeroItemUpdateArgs<ExtArgs>>): Prisma__XeroItemClient<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more XeroItems.
     * @param {XeroItemDeleteManyArgs} args - Arguments to filter XeroItems to delete.
     * @example
     * // Delete a few XeroItems
     * const { count } = await prisma.xeroItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends XeroItemDeleteManyArgs>(args?: SelectSubset<T, XeroItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XeroItems
     * const xeroItem = await prisma.xeroItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends XeroItemUpdateManyArgs>(args: SelectSubset<T, XeroItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more XeroItems and returns the data updated in the database.
     * @param {XeroItemUpdateManyAndReturnArgs} args - Arguments to update many XeroItems.
     * @example
     * // Update many XeroItems
     * const xeroItem = await prisma.xeroItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more XeroItems and only return the `id`
     * const xeroItemWithIdOnly = await prisma.xeroItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends XeroItemUpdateManyAndReturnArgs>(args: SelectSubset<T, XeroItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one XeroItem.
     * @param {XeroItemUpsertArgs} args - Arguments to update or create a XeroItem.
     * @example
     * // Update or create a XeroItem
     * const xeroItem = await prisma.xeroItem.upsert({
     *   create: {
     *     // ... data to create a XeroItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XeroItem we want to update
     *   }
     * })
     */
    upsert<T extends XeroItemUpsertArgs>(args: SelectSubset<T, XeroItemUpsertArgs<ExtArgs>>): Prisma__XeroItemClient<$Result.GetResult<Prisma.$XeroItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of XeroItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroItemCountArgs} args - Arguments to filter XeroItems to count.
     * @example
     * // Count the number of XeroItems
     * const count = await prisma.xeroItem.count({
     *   where: {
     *     // ... the filter for the XeroItems we want to count
     *   }
     * })
    **/
    count<T extends XeroItemCountArgs>(
      args?: Subset<T, XeroItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XeroItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a XeroItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends XeroItemAggregateArgs>(args: Subset<T, XeroItemAggregateArgs>): Prisma.PrismaPromise<GetXeroItemAggregateType<T>>

    /**
     * Group by XeroItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XeroItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends XeroItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XeroItemGroupByArgs['orderBy'] }
        : { orderBy?: XeroItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, XeroItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXeroItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the XeroItem model
   */
  readonly fields: XeroItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XeroItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XeroItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the XeroItem model
   */
  interface XeroItemFieldRefs {
    readonly id: FieldRef<"XeroItem", 'String'>
    readonly xeroId: FieldRef<"XeroItem", 'String'>
    readonly code: FieldRef<"XeroItem", 'String'>
    readonly name: FieldRef<"XeroItem", 'String'>
    readonly description: FieldRef<"XeroItem", 'String'>
    readonly salesDetails: FieldRef<"XeroItem", 'Json'>
    readonly purchaseDetails: FieldRef<"XeroItem", 'Json'>
    readonly isTrackedAsInventory: FieldRef<"XeroItem", 'Boolean'>
    readonly isSold: FieldRef<"XeroItem", 'Boolean'>
    readonly isPurchased: FieldRef<"XeroItem", 'Boolean'>
    readonly createdAt: FieldRef<"XeroItem", 'DateTime'>
    readonly updatedAt: FieldRef<"XeroItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * XeroItem findUnique
   */
  export type XeroItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * Filter, which XeroItem to fetch.
     */
    where: XeroItemWhereUniqueInput
  }

  /**
   * XeroItem findUniqueOrThrow
   */
  export type XeroItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * Filter, which XeroItem to fetch.
     */
    where: XeroItemWhereUniqueInput
  }

  /**
   * XeroItem findFirst
   */
  export type XeroItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * Filter, which XeroItem to fetch.
     */
    where?: XeroItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroItems to fetch.
     */
    orderBy?: XeroItemOrderByWithRelationInput | XeroItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroItems.
     */
    cursor?: XeroItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroItems.
     */
    distinct?: XeroItemScalarFieldEnum | XeroItemScalarFieldEnum[]
  }

  /**
   * XeroItem findFirstOrThrow
   */
  export type XeroItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * Filter, which XeroItem to fetch.
     */
    where?: XeroItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroItems to fetch.
     */
    orderBy?: XeroItemOrderByWithRelationInput | XeroItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for XeroItems.
     */
    cursor?: XeroItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of XeroItems.
     */
    distinct?: XeroItemScalarFieldEnum | XeroItemScalarFieldEnum[]
  }

  /**
   * XeroItem findMany
   */
  export type XeroItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * Filter, which XeroItems to fetch.
     */
    where?: XeroItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of XeroItems to fetch.
     */
    orderBy?: XeroItemOrderByWithRelationInput | XeroItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing XeroItems.
     */
    cursor?: XeroItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` XeroItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` XeroItems.
     */
    skip?: number
    distinct?: XeroItemScalarFieldEnum | XeroItemScalarFieldEnum[]
  }

  /**
   * XeroItem create
   */
  export type XeroItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * The data needed to create a XeroItem.
     */
    data: XOR<XeroItemCreateInput, XeroItemUncheckedCreateInput>
  }

  /**
   * XeroItem createMany
   */
  export type XeroItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many XeroItems.
     */
    data: XeroItemCreateManyInput | XeroItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroItem createManyAndReturn
   */
  export type XeroItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * The data used to create many XeroItems.
     */
    data: XeroItemCreateManyInput | XeroItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * XeroItem update
   */
  export type XeroItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * The data needed to update a XeroItem.
     */
    data: XOR<XeroItemUpdateInput, XeroItemUncheckedUpdateInput>
    /**
     * Choose, which XeroItem to update.
     */
    where: XeroItemWhereUniqueInput
  }

  /**
   * XeroItem updateMany
   */
  export type XeroItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update XeroItems.
     */
    data: XOR<XeroItemUpdateManyMutationInput, XeroItemUncheckedUpdateManyInput>
    /**
     * Filter which XeroItems to update
     */
    where?: XeroItemWhereInput
    /**
     * Limit how many XeroItems to update.
     */
    limit?: number
  }

  /**
   * XeroItem updateManyAndReturn
   */
  export type XeroItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * The data used to update XeroItems.
     */
    data: XOR<XeroItemUpdateManyMutationInput, XeroItemUncheckedUpdateManyInput>
    /**
     * Filter which XeroItems to update
     */
    where?: XeroItemWhereInput
    /**
     * Limit how many XeroItems to update.
     */
    limit?: number
  }

  /**
   * XeroItem upsert
   */
  export type XeroItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * The filter to search for the XeroItem to update in case it exists.
     */
    where: XeroItemWhereUniqueInput
    /**
     * In case the XeroItem found by the `where` argument doesn't exist, create a new XeroItem with this data.
     */
    create: XOR<XeroItemCreateInput, XeroItemUncheckedCreateInput>
    /**
     * In case the XeroItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XeroItemUpdateInput, XeroItemUncheckedUpdateInput>
  }

  /**
   * XeroItem delete
   */
  export type XeroItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
    /**
     * Filter which XeroItem to delete.
     */
    where: XeroItemWhereUniqueInput
  }

  /**
   * XeroItem deleteMany
   */
  export type XeroItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which XeroItems to delete
     */
    where?: XeroItemWhereInput
    /**
     * Limit how many XeroItems to delete.
     */
    limit?: number
  }

  /**
   * XeroItem without action
   */
  export type XeroItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the XeroItem
     */
    select?: XeroItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the XeroItem
     */
    omit?: XeroItemOmit<ExtArgs> | null
  }


  /**
   * Model AmazonOrder
   */

  export type AggregateAmazonOrder = {
    _count: AmazonOrderCountAggregateOutputType | null
    _avg: AmazonOrderAvgAggregateOutputType | null
    _sum: AmazonOrderSumAggregateOutputType | null
    _min: AmazonOrderMinAggregateOutputType | null
    _max: AmazonOrderMaxAggregateOutputType | null
  }

  export type AmazonOrderAvgAggregateOutputType = {
    orderTotal: number | null
    numberOfItemsShipped: number | null
    numberOfItemsUnshipped: number | null
  }

  export type AmazonOrderSumAggregateOutputType = {
    orderTotal: number | null
    numberOfItemsShipped: number | null
    numberOfItemsUnshipped: number | null
  }

  export type AmazonOrderMinAggregateOutputType = {
    id: string | null
    amazonOrderId: string | null
    marketplace: string | null
    orderStatus: string | null
    fulfillmentChannel: string | null
    salesChannel: string | null
    orderType: string | null
    purchaseDate: Date | null
    lastUpdateDate: Date | null
    orderTotal: number | null
    currency: string | null
    numberOfItemsShipped: number | null
    numberOfItemsUnshipped: number | null
    buyerEmail: string | null
    isBusinessOrder: boolean | null
    isPrime: boolean | null
    isGlobalExpressEnabled: boolean | null
    isReplacementOrder: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmazonOrderMaxAggregateOutputType = {
    id: string | null
    amazonOrderId: string | null
    marketplace: string | null
    orderStatus: string | null
    fulfillmentChannel: string | null
    salesChannel: string | null
    orderType: string | null
    purchaseDate: Date | null
    lastUpdateDate: Date | null
    orderTotal: number | null
    currency: string | null
    numberOfItemsShipped: number | null
    numberOfItemsUnshipped: number | null
    buyerEmail: string | null
    isBusinessOrder: boolean | null
    isPrime: boolean | null
    isGlobalExpressEnabled: boolean | null
    isReplacementOrder: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmazonOrderCountAggregateOutputType = {
    id: number
    amazonOrderId: number
    marketplace: number
    orderStatus: number
    fulfillmentChannel: number
    salesChannel: number
    orderType: number
    purchaseDate: number
    lastUpdateDate: number
    orderTotal: number
    currency: number
    numberOfItemsShipped: number
    numberOfItemsUnshipped: number
    buyerEmail: number
    isBusinessOrder: number
    isPrime: number
    isGlobalExpressEnabled: number
    isReplacementOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmazonOrderAvgAggregateInputType = {
    orderTotal?: true
    numberOfItemsShipped?: true
    numberOfItemsUnshipped?: true
  }

  export type AmazonOrderSumAggregateInputType = {
    orderTotal?: true
    numberOfItemsShipped?: true
    numberOfItemsUnshipped?: true
  }

  export type AmazonOrderMinAggregateInputType = {
    id?: true
    amazonOrderId?: true
    marketplace?: true
    orderStatus?: true
    fulfillmentChannel?: true
    salesChannel?: true
    orderType?: true
    purchaseDate?: true
    lastUpdateDate?: true
    orderTotal?: true
    currency?: true
    numberOfItemsShipped?: true
    numberOfItemsUnshipped?: true
    buyerEmail?: true
    isBusinessOrder?: true
    isPrime?: true
    isGlobalExpressEnabled?: true
    isReplacementOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmazonOrderMaxAggregateInputType = {
    id?: true
    amazonOrderId?: true
    marketplace?: true
    orderStatus?: true
    fulfillmentChannel?: true
    salesChannel?: true
    orderType?: true
    purchaseDate?: true
    lastUpdateDate?: true
    orderTotal?: true
    currency?: true
    numberOfItemsShipped?: true
    numberOfItemsUnshipped?: true
    buyerEmail?: true
    isBusinessOrder?: true
    isPrime?: true
    isGlobalExpressEnabled?: true
    isReplacementOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmazonOrderCountAggregateInputType = {
    id?: true
    amazonOrderId?: true
    marketplace?: true
    orderStatus?: true
    fulfillmentChannel?: true
    salesChannel?: true
    orderType?: true
    purchaseDate?: true
    lastUpdateDate?: true
    orderTotal?: true
    currency?: true
    numberOfItemsShipped?: true
    numberOfItemsUnshipped?: true
    buyerEmail?: true
    isBusinessOrder?: true
    isPrime?: true
    isGlobalExpressEnabled?: true
    isReplacementOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmazonOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmazonOrder to aggregate.
     */
    where?: AmazonOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonOrders to fetch.
     */
    orderBy?: AmazonOrderOrderByWithRelationInput | AmazonOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmazonOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmazonOrders
    **/
    _count?: true | AmazonOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmazonOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmazonOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmazonOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmazonOrderMaxAggregateInputType
  }

  export type GetAmazonOrderAggregateType<T extends AmazonOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateAmazonOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmazonOrder[P]>
      : GetScalarType<T[P], AggregateAmazonOrder[P]>
  }




  export type AmazonOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmazonOrderWhereInput
    orderBy?: AmazonOrderOrderByWithAggregationInput | AmazonOrderOrderByWithAggregationInput[]
    by: AmazonOrderScalarFieldEnum[] | AmazonOrderScalarFieldEnum
    having?: AmazonOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmazonOrderCountAggregateInputType | true
    _avg?: AmazonOrderAvgAggregateInputType
    _sum?: AmazonOrderSumAggregateInputType
    _min?: AmazonOrderMinAggregateInputType
    _max?: AmazonOrderMaxAggregateInputType
  }

  export type AmazonOrderGroupByOutputType = {
    id: string
    amazonOrderId: string
    marketplace: string
    orderStatus: string
    fulfillmentChannel: string | null
    salesChannel: string | null
    orderType: string | null
    purchaseDate: Date | null
    lastUpdateDate: Date | null
    orderTotal: number | null
    currency: string
    numberOfItemsShipped: number
    numberOfItemsUnshipped: number
    buyerEmail: string | null
    isBusinessOrder: boolean
    isPrime: boolean
    isGlobalExpressEnabled: boolean
    isReplacementOrder: boolean
    createdAt: Date
    updatedAt: Date
    _count: AmazonOrderCountAggregateOutputType | null
    _avg: AmazonOrderAvgAggregateOutputType | null
    _sum: AmazonOrderSumAggregateOutputType | null
    _min: AmazonOrderMinAggregateOutputType | null
    _max: AmazonOrderMaxAggregateOutputType | null
  }

  type GetAmazonOrderGroupByPayload<T extends AmazonOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmazonOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmazonOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmazonOrderGroupByOutputType[P]>
            : GetScalarType<T[P], AmazonOrderGroupByOutputType[P]>
        }
      >
    >


  export type AmazonOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amazonOrderId?: boolean
    marketplace?: boolean
    orderStatus?: boolean
    fulfillmentChannel?: boolean
    salesChannel?: boolean
    orderType?: boolean
    purchaseDate?: boolean
    lastUpdateDate?: boolean
    orderTotal?: boolean
    currency?: boolean
    numberOfItemsShipped?: boolean
    numberOfItemsUnshipped?: boolean
    buyerEmail?: boolean
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItems?: boolean | AmazonOrder$orderItemsArgs<ExtArgs>
    _count?: boolean | AmazonOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amazonOrder"]>

  export type AmazonOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amazonOrderId?: boolean
    marketplace?: boolean
    orderStatus?: boolean
    fulfillmentChannel?: boolean
    salesChannel?: boolean
    orderType?: boolean
    purchaseDate?: boolean
    lastUpdateDate?: boolean
    orderTotal?: boolean
    currency?: boolean
    numberOfItemsShipped?: boolean
    numberOfItemsUnshipped?: boolean
    buyerEmail?: boolean
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amazonOrder"]>

  export type AmazonOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amazonOrderId?: boolean
    marketplace?: boolean
    orderStatus?: boolean
    fulfillmentChannel?: boolean
    salesChannel?: boolean
    orderType?: boolean
    purchaseDate?: boolean
    lastUpdateDate?: boolean
    orderTotal?: boolean
    currency?: boolean
    numberOfItemsShipped?: boolean
    numberOfItemsUnshipped?: boolean
    buyerEmail?: boolean
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amazonOrder"]>

  export type AmazonOrderSelectScalar = {
    id?: boolean
    amazonOrderId?: boolean
    marketplace?: boolean
    orderStatus?: boolean
    fulfillmentChannel?: boolean
    salesChannel?: boolean
    orderType?: boolean
    purchaseDate?: boolean
    lastUpdateDate?: boolean
    orderTotal?: boolean
    currency?: boolean
    numberOfItemsShipped?: boolean
    numberOfItemsUnshipped?: boolean
    buyerEmail?: boolean
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmazonOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amazonOrderId" | "marketplace" | "orderStatus" | "fulfillmentChannel" | "salesChannel" | "orderType" | "purchaseDate" | "lastUpdateDate" | "orderTotal" | "currency" | "numberOfItemsShipped" | "numberOfItemsUnshipped" | "buyerEmail" | "isBusinessOrder" | "isPrime" | "isGlobalExpressEnabled" | "isReplacementOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["amazonOrder"]>
  export type AmazonOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | AmazonOrder$orderItemsArgs<ExtArgs>
    _count?: boolean | AmazonOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmazonOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmazonOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmazonOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmazonOrder"
    objects: {
      orderItems: Prisma.$AmazonOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amazonOrderId: string
      marketplace: string
      orderStatus: string
      fulfillmentChannel: string | null
      salesChannel: string | null
      orderType: string | null
      purchaseDate: Date | null
      lastUpdateDate: Date | null
      orderTotal: number | null
      currency: string
      numberOfItemsShipped: number
      numberOfItemsUnshipped: number
      buyerEmail: string | null
      isBusinessOrder: boolean
      isPrime: boolean
      isGlobalExpressEnabled: boolean
      isReplacementOrder: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amazonOrder"]>
    composites: {}
  }

  type AmazonOrderGetPayload<S extends boolean | null | undefined | AmazonOrderDefaultArgs> = $Result.GetResult<Prisma.$AmazonOrderPayload, S>

  type AmazonOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmazonOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmazonOrderCountAggregateInputType | true
    }

  export interface AmazonOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmazonOrder'], meta: { name: 'AmazonOrder' } }
    /**
     * Find zero or one AmazonOrder that matches the filter.
     * @param {AmazonOrderFindUniqueArgs} args - Arguments to find a AmazonOrder
     * @example
     * // Get one AmazonOrder
     * const amazonOrder = await prisma.amazonOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmazonOrderFindUniqueArgs>(args: SelectSubset<T, AmazonOrderFindUniqueArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmazonOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmazonOrderFindUniqueOrThrowArgs} args - Arguments to find a AmazonOrder
     * @example
     * // Get one AmazonOrder
     * const amazonOrder = await prisma.amazonOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmazonOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, AmazonOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmazonOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderFindFirstArgs} args - Arguments to find a AmazonOrder
     * @example
     * // Get one AmazonOrder
     * const amazonOrder = await prisma.amazonOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmazonOrderFindFirstArgs>(args?: SelectSubset<T, AmazonOrderFindFirstArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmazonOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderFindFirstOrThrowArgs} args - Arguments to find a AmazonOrder
     * @example
     * // Get one AmazonOrder
     * const amazonOrder = await prisma.amazonOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmazonOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, AmazonOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmazonOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmazonOrders
     * const amazonOrders = await prisma.amazonOrder.findMany()
     * 
     * // Get first 10 AmazonOrders
     * const amazonOrders = await prisma.amazonOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amazonOrderWithIdOnly = await prisma.amazonOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmazonOrderFindManyArgs>(args?: SelectSubset<T, AmazonOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmazonOrder.
     * @param {AmazonOrderCreateArgs} args - Arguments to create a AmazonOrder.
     * @example
     * // Create one AmazonOrder
     * const AmazonOrder = await prisma.amazonOrder.create({
     *   data: {
     *     // ... data to create a AmazonOrder
     *   }
     * })
     * 
     */
    create<T extends AmazonOrderCreateArgs>(args: SelectSubset<T, AmazonOrderCreateArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmazonOrders.
     * @param {AmazonOrderCreateManyArgs} args - Arguments to create many AmazonOrders.
     * @example
     * // Create many AmazonOrders
     * const amazonOrder = await prisma.amazonOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmazonOrderCreateManyArgs>(args?: SelectSubset<T, AmazonOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AmazonOrders and returns the data saved in the database.
     * @param {AmazonOrderCreateManyAndReturnArgs} args - Arguments to create many AmazonOrders.
     * @example
     * // Create many AmazonOrders
     * const amazonOrder = await prisma.amazonOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AmazonOrders and only return the `id`
     * const amazonOrderWithIdOnly = await prisma.amazonOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmazonOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, AmazonOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AmazonOrder.
     * @param {AmazonOrderDeleteArgs} args - Arguments to delete one AmazonOrder.
     * @example
     * // Delete one AmazonOrder
     * const AmazonOrder = await prisma.amazonOrder.delete({
     *   where: {
     *     // ... filter to delete one AmazonOrder
     *   }
     * })
     * 
     */
    delete<T extends AmazonOrderDeleteArgs>(args: SelectSubset<T, AmazonOrderDeleteArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmazonOrder.
     * @param {AmazonOrderUpdateArgs} args - Arguments to update one AmazonOrder.
     * @example
     * // Update one AmazonOrder
     * const amazonOrder = await prisma.amazonOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmazonOrderUpdateArgs>(args: SelectSubset<T, AmazonOrderUpdateArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmazonOrders.
     * @param {AmazonOrderDeleteManyArgs} args - Arguments to filter AmazonOrders to delete.
     * @example
     * // Delete a few AmazonOrders
     * const { count } = await prisma.amazonOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmazonOrderDeleteManyArgs>(args?: SelectSubset<T, AmazonOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmazonOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmazonOrders
     * const amazonOrder = await prisma.amazonOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmazonOrderUpdateManyArgs>(args: SelectSubset<T, AmazonOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmazonOrders and returns the data updated in the database.
     * @param {AmazonOrderUpdateManyAndReturnArgs} args - Arguments to update many AmazonOrders.
     * @example
     * // Update many AmazonOrders
     * const amazonOrder = await prisma.amazonOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AmazonOrders and only return the `id`
     * const amazonOrderWithIdOnly = await prisma.amazonOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmazonOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, AmazonOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AmazonOrder.
     * @param {AmazonOrderUpsertArgs} args - Arguments to update or create a AmazonOrder.
     * @example
     * // Update or create a AmazonOrder
     * const amazonOrder = await prisma.amazonOrder.upsert({
     *   create: {
     *     // ... data to create a AmazonOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmazonOrder we want to update
     *   }
     * })
     */
    upsert<T extends AmazonOrderUpsertArgs>(args: SelectSubset<T, AmazonOrderUpsertArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmazonOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderCountArgs} args - Arguments to filter AmazonOrders to count.
     * @example
     * // Count the number of AmazonOrders
     * const count = await prisma.amazonOrder.count({
     *   where: {
     *     // ... the filter for the AmazonOrders we want to count
     *   }
     * })
    **/
    count<T extends AmazonOrderCountArgs>(
      args?: Subset<T, AmazonOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmazonOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmazonOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmazonOrderAggregateArgs>(args: Subset<T, AmazonOrderAggregateArgs>): Prisma.PrismaPromise<GetAmazonOrderAggregateType<T>>

    /**
     * Group by AmazonOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmazonOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmazonOrderGroupByArgs['orderBy'] }
        : { orderBy?: AmazonOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmazonOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmazonOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmazonOrder model
   */
  readonly fields: AmazonOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmazonOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmazonOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends AmazonOrder$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, AmazonOrder$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmazonOrder model
   */
  interface AmazonOrderFieldRefs {
    readonly id: FieldRef<"AmazonOrder", 'String'>
    readonly amazonOrderId: FieldRef<"AmazonOrder", 'String'>
    readonly marketplace: FieldRef<"AmazonOrder", 'String'>
    readonly orderStatus: FieldRef<"AmazonOrder", 'String'>
    readonly fulfillmentChannel: FieldRef<"AmazonOrder", 'String'>
    readonly salesChannel: FieldRef<"AmazonOrder", 'String'>
    readonly orderType: FieldRef<"AmazonOrder", 'String'>
    readonly purchaseDate: FieldRef<"AmazonOrder", 'DateTime'>
    readonly lastUpdateDate: FieldRef<"AmazonOrder", 'DateTime'>
    readonly orderTotal: FieldRef<"AmazonOrder", 'Float'>
    readonly currency: FieldRef<"AmazonOrder", 'String'>
    readonly numberOfItemsShipped: FieldRef<"AmazonOrder", 'Int'>
    readonly numberOfItemsUnshipped: FieldRef<"AmazonOrder", 'Int'>
    readonly buyerEmail: FieldRef<"AmazonOrder", 'String'>
    readonly isBusinessOrder: FieldRef<"AmazonOrder", 'Boolean'>
    readonly isPrime: FieldRef<"AmazonOrder", 'Boolean'>
    readonly isGlobalExpressEnabled: FieldRef<"AmazonOrder", 'Boolean'>
    readonly isReplacementOrder: FieldRef<"AmazonOrder", 'Boolean'>
    readonly createdAt: FieldRef<"AmazonOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"AmazonOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AmazonOrder findUnique
   */
  export type AmazonOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrder to fetch.
     */
    where: AmazonOrderWhereUniqueInput
  }

  /**
   * AmazonOrder findUniqueOrThrow
   */
  export type AmazonOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrder to fetch.
     */
    where: AmazonOrderWhereUniqueInput
  }

  /**
   * AmazonOrder findFirst
   */
  export type AmazonOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrder to fetch.
     */
    where?: AmazonOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonOrders to fetch.
     */
    orderBy?: AmazonOrderOrderByWithRelationInput | AmazonOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmazonOrders.
     */
    cursor?: AmazonOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmazonOrders.
     */
    distinct?: AmazonOrderScalarFieldEnum | AmazonOrderScalarFieldEnum[]
  }

  /**
   * AmazonOrder findFirstOrThrow
   */
  export type AmazonOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrder to fetch.
     */
    where?: AmazonOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonOrders to fetch.
     */
    orderBy?: AmazonOrderOrderByWithRelationInput | AmazonOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmazonOrders.
     */
    cursor?: AmazonOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmazonOrders.
     */
    distinct?: AmazonOrderScalarFieldEnum | AmazonOrderScalarFieldEnum[]
  }

  /**
   * AmazonOrder findMany
   */
  export type AmazonOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrders to fetch.
     */
    where?: AmazonOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonOrders to fetch.
     */
    orderBy?: AmazonOrderOrderByWithRelationInput | AmazonOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmazonOrders.
     */
    cursor?: AmazonOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonOrders.
     */
    skip?: number
    distinct?: AmazonOrderScalarFieldEnum | AmazonOrderScalarFieldEnum[]
  }

  /**
   * AmazonOrder create
   */
  export type AmazonOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a AmazonOrder.
     */
    data: XOR<AmazonOrderCreateInput, AmazonOrderUncheckedCreateInput>
  }

  /**
   * AmazonOrder createMany
   */
  export type AmazonOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmazonOrders.
     */
    data: AmazonOrderCreateManyInput | AmazonOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmazonOrder createManyAndReturn
   */
  export type AmazonOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * The data used to create many AmazonOrders.
     */
    data: AmazonOrderCreateManyInput | AmazonOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmazonOrder update
   */
  export type AmazonOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a AmazonOrder.
     */
    data: XOR<AmazonOrderUpdateInput, AmazonOrderUncheckedUpdateInput>
    /**
     * Choose, which AmazonOrder to update.
     */
    where: AmazonOrderWhereUniqueInput
  }

  /**
   * AmazonOrder updateMany
   */
  export type AmazonOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmazonOrders.
     */
    data: XOR<AmazonOrderUpdateManyMutationInput, AmazonOrderUncheckedUpdateManyInput>
    /**
     * Filter which AmazonOrders to update
     */
    where?: AmazonOrderWhereInput
    /**
     * Limit how many AmazonOrders to update.
     */
    limit?: number
  }

  /**
   * AmazonOrder updateManyAndReturn
   */
  export type AmazonOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * The data used to update AmazonOrders.
     */
    data: XOR<AmazonOrderUpdateManyMutationInput, AmazonOrderUncheckedUpdateManyInput>
    /**
     * Filter which AmazonOrders to update
     */
    where?: AmazonOrderWhereInput
    /**
     * Limit how many AmazonOrders to update.
     */
    limit?: number
  }

  /**
   * AmazonOrder upsert
   */
  export type AmazonOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the AmazonOrder to update in case it exists.
     */
    where: AmazonOrderWhereUniqueInput
    /**
     * In case the AmazonOrder found by the `where` argument doesn't exist, create a new AmazonOrder with this data.
     */
    create: XOR<AmazonOrderCreateInput, AmazonOrderUncheckedCreateInput>
    /**
     * In case the AmazonOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmazonOrderUpdateInput, AmazonOrderUncheckedUpdateInput>
  }

  /**
   * AmazonOrder delete
   */
  export type AmazonOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
    /**
     * Filter which AmazonOrder to delete.
     */
    where: AmazonOrderWhereUniqueInput
  }

  /**
   * AmazonOrder deleteMany
   */
  export type AmazonOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmazonOrders to delete
     */
    where?: AmazonOrderWhereInput
    /**
     * Limit how many AmazonOrders to delete.
     */
    limit?: number
  }

  /**
   * AmazonOrder.orderItems
   */
  export type AmazonOrder$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    where?: AmazonOrderItemWhereInput
    orderBy?: AmazonOrderItemOrderByWithRelationInput | AmazonOrderItemOrderByWithRelationInput[]
    cursor?: AmazonOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmazonOrderItemScalarFieldEnum | AmazonOrderItemScalarFieldEnum[]
  }

  /**
   * AmazonOrder without action
   */
  export type AmazonOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrder
     */
    select?: AmazonOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrder
     */
    omit?: AmazonOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderInclude<ExtArgs> | null
  }


  /**
   * Model AmazonOrderItem
   */

  export type AggregateAmazonOrderItem = {
    _count: AmazonOrderItemCountAggregateOutputType | null
    _avg: AmazonOrderItemAvgAggregateOutputType | null
    _sum: AmazonOrderItemSumAggregateOutputType | null
    _min: AmazonOrderItemMinAggregateOutputType | null
    _max: AmazonOrderItemMaxAggregateOutputType | null
  }

  export type AmazonOrderItemAvgAggregateOutputType = {
    quantityOrdered: number | null
    quantityShipped: number | null
    itemPrice: number | null
    itemTax: number | null
    shippingPrice: number | null
    shippingTax: number | null
    giftWrapPrice: number | null
    giftWrapTax: number | null
    itemPromotionDiscount: number | null
    shipPromotionDiscount: number | null
  }

  export type AmazonOrderItemSumAggregateOutputType = {
    quantityOrdered: number | null
    quantityShipped: number | null
    itemPrice: number | null
    itemTax: number | null
    shippingPrice: number | null
    shippingTax: number | null
    giftWrapPrice: number | null
    giftWrapTax: number | null
    itemPromotionDiscount: number | null
    shipPromotionDiscount: number | null
  }

  export type AmazonOrderItemMinAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    amazonOrderId: string | null
    asin: string | null
    sellerSKU: string | null
    title: string | null
    quantityOrdered: number | null
    quantityShipped: number | null
    itemPrice: number | null
    itemTax: number | null
    shippingPrice: number | null
    shippingTax: number | null
    giftWrapPrice: number | null
    giftWrapTax: number | null
    itemPromotionDiscount: number | null
    shipPromotionDiscount: number | null
    currency: string | null
    conditionNote: string | null
    conditionId: string | null
    conditionSubtypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmazonOrderItemMaxAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    amazonOrderId: string | null
    asin: string | null
    sellerSKU: string | null
    title: string | null
    quantityOrdered: number | null
    quantityShipped: number | null
    itemPrice: number | null
    itemTax: number | null
    shippingPrice: number | null
    shippingTax: number | null
    giftWrapPrice: number | null
    giftWrapTax: number | null
    itemPromotionDiscount: number | null
    shipPromotionDiscount: number | null
    currency: string | null
    conditionNote: string | null
    conditionId: string | null
    conditionSubtypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmazonOrderItemCountAggregateOutputType = {
    id: number
    orderItemId: number
    amazonOrderId: number
    asin: number
    sellerSKU: number
    title: number
    quantityOrdered: number
    quantityShipped: number
    itemPrice: number
    itemTax: number
    shippingPrice: number
    shippingTax: number
    giftWrapPrice: number
    giftWrapTax: number
    itemPromotionDiscount: number
    shipPromotionDiscount: number
    currency: number
    conditionNote: number
    conditionId: number
    conditionSubtypeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmazonOrderItemAvgAggregateInputType = {
    quantityOrdered?: true
    quantityShipped?: true
    itemPrice?: true
    itemTax?: true
    shippingPrice?: true
    shippingTax?: true
    giftWrapPrice?: true
    giftWrapTax?: true
    itemPromotionDiscount?: true
    shipPromotionDiscount?: true
  }

  export type AmazonOrderItemSumAggregateInputType = {
    quantityOrdered?: true
    quantityShipped?: true
    itemPrice?: true
    itemTax?: true
    shippingPrice?: true
    shippingTax?: true
    giftWrapPrice?: true
    giftWrapTax?: true
    itemPromotionDiscount?: true
    shipPromotionDiscount?: true
  }

  export type AmazonOrderItemMinAggregateInputType = {
    id?: true
    orderItemId?: true
    amazonOrderId?: true
    asin?: true
    sellerSKU?: true
    title?: true
    quantityOrdered?: true
    quantityShipped?: true
    itemPrice?: true
    itemTax?: true
    shippingPrice?: true
    shippingTax?: true
    giftWrapPrice?: true
    giftWrapTax?: true
    itemPromotionDiscount?: true
    shipPromotionDiscount?: true
    currency?: true
    conditionNote?: true
    conditionId?: true
    conditionSubtypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmazonOrderItemMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    amazonOrderId?: true
    asin?: true
    sellerSKU?: true
    title?: true
    quantityOrdered?: true
    quantityShipped?: true
    itemPrice?: true
    itemTax?: true
    shippingPrice?: true
    shippingTax?: true
    giftWrapPrice?: true
    giftWrapTax?: true
    itemPromotionDiscount?: true
    shipPromotionDiscount?: true
    currency?: true
    conditionNote?: true
    conditionId?: true
    conditionSubtypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmazonOrderItemCountAggregateInputType = {
    id?: true
    orderItemId?: true
    amazonOrderId?: true
    asin?: true
    sellerSKU?: true
    title?: true
    quantityOrdered?: true
    quantityShipped?: true
    itemPrice?: true
    itemTax?: true
    shippingPrice?: true
    shippingTax?: true
    giftWrapPrice?: true
    giftWrapTax?: true
    itemPromotionDiscount?: true
    shipPromotionDiscount?: true
    currency?: true
    conditionNote?: true
    conditionId?: true
    conditionSubtypeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmazonOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmazonOrderItem to aggregate.
     */
    where?: AmazonOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonOrderItems to fetch.
     */
    orderBy?: AmazonOrderItemOrderByWithRelationInput | AmazonOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmazonOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmazonOrderItems
    **/
    _count?: true | AmazonOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmazonOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmazonOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmazonOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmazonOrderItemMaxAggregateInputType
  }

  export type GetAmazonOrderItemAggregateType<T extends AmazonOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAmazonOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmazonOrderItem[P]>
      : GetScalarType<T[P], AggregateAmazonOrderItem[P]>
  }




  export type AmazonOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmazonOrderItemWhereInput
    orderBy?: AmazonOrderItemOrderByWithAggregationInput | AmazonOrderItemOrderByWithAggregationInput[]
    by: AmazonOrderItemScalarFieldEnum[] | AmazonOrderItemScalarFieldEnum
    having?: AmazonOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmazonOrderItemCountAggregateInputType | true
    _avg?: AmazonOrderItemAvgAggregateInputType
    _sum?: AmazonOrderItemSumAggregateInputType
    _min?: AmazonOrderItemMinAggregateInputType
    _max?: AmazonOrderItemMaxAggregateInputType
  }

  export type AmazonOrderItemGroupByOutputType = {
    id: string
    orderItemId: string
    amazonOrderId: string
    asin: string
    sellerSKU: string | null
    title: string | null
    quantityOrdered: number
    quantityShipped: number
    itemPrice: number | null
    itemTax: number | null
    shippingPrice: number | null
    shippingTax: number | null
    giftWrapPrice: number | null
    giftWrapTax: number | null
    itemPromotionDiscount: number | null
    shipPromotionDiscount: number | null
    currency: string
    conditionNote: string | null
    conditionId: string | null
    conditionSubtypeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AmazonOrderItemCountAggregateOutputType | null
    _avg: AmazonOrderItemAvgAggregateOutputType | null
    _sum: AmazonOrderItemSumAggregateOutputType | null
    _min: AmazonOrderItemMinAggregateOutputType | null
    _max: AmazonOrderItemMaxAggregateOutputType | null
  }

  type GetAmazonOrderItemGroupByPayload<T extends AmazonOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmazonOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmazonOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmazonOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], AmazonOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type AmazonOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    amazonOrderId?: boolean
    asin?: boolean
    sellerSKU?: boolean
    title?: boolean
    quantityOrdered?: boolean
    quantityShipped?: boolean
    itemPrice?: boolean
    itemTax?: boolean
    shippingPrice?: boolean
    shippingTax?: boolean
    giftWrapPrice?: boolean
    giftWrapTax?: boolean
    itemPromotionDiscount?: boolean
    shipPromotionDiscount?: boolean
    currency?: boolean
    conditionNote?: boolean
    conditionId?: boolean
    conditionSubtypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AmazonOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amazonOrderItem"]>

  export type AmazonOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    amazonOrderId?: boolean
    asin?: boolean
    sellerSKU?: boolean
    title?: boolean
    quantityOrdered?: boolean
    quantityShipped?: boolean
    itemPrice?: boolean
    itemTax?: boolean
    shippingPrice?: boolean
    shippingTax?: boolean
    giftWrapPrice?: boolean
    giftWrapTax?: boolean
    itemPromotionDiscount?: boolean
    shipPromotionDiscount?: boolean
    currency?: boolean
    conditionNote?: boolean
    conditionId?: boolean
    conditionSubtypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AmazonOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amazonOrderItem"]>

  export type AmazonOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    amazonOrderId?: boolean
    asin?: boolean
    sellerSKU?: boolean
    title?: boolean
    quantityOrdered?: boolean
    quantityShipped?: boolean
    itemPrice?: boolean
    itemTax?: boolean
    shippingPrice?: boolean
    shippingTax?: boolean
    giftWrapPrice?: boolean
    giftWrapTax?: boolean
    itemPromotionDiscount?: boolean
    shipPromotionDiscount?: boolean
    currency?: boolean
    conditionNote?: boolean
    conditionId?: boolean
    conditionSubtypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | AmazonOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amazonOrderItem"]>

  export type AmazonOrderItemSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    amazonOrderId?: boolean
    asin?: boolean
    sellerSKU?: boolean
    title?: boolean
    quantityOrdered?: boolean
    quantityShipped?: boolean
    itemPrice?: boolean
    itemTax?: boolean
    shippingPrice?: boolean
    shippingTax?: boolean
    giftWrapPrice?: boolean
    giftWrapTax?: boolean
    itemPromotionDiscount?: boolean
    shipPromotionDiscount?: boolean
    currency?: boolean
    conditionNote?: boolean
    conditionId?: boolean
    conditionSubtypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmazonOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderItemId" | "amazonOrderId" | "asin" | "sellerSKU" | "title" | "quantityOrdered" | "quantityShipped" | "itemPrice" | "itemTax" | "shippingPrice" | "shippingTax" | "giftWrapPrice" | "giftWrapTax" | "itemPromotionDiscount" | "shipPromotionDiscount" | "currency" | "conditionNote" | "conditionId" | "conditionSubtypeId" | "createdAt" | "updatedAt", ExtArgs["result"]["amazonOrderItem"]>
  export type AmazonOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AmazonOrderDefaultArgs<ExtArgs>
  }
  export type AmazonOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AmazonOrderDefaultArgs<ExtArgs>
  }
  export type AmazonOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | AmazonOrderDefaultArgs<ExtArgs>
  }

  export type $AmazonOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmazonOrderItem"
    objects: {
      order: Prisma.$AmazonOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderItemId: string
      amazonOrderId: string
      asin: string
      sellerSKU: string | null
      title: string | null
      quantityOrdered: number
      quantityShipped: number
      itemPrice: number | null
      itemTax: number | null
      shippingPrice: number | null
      shippingTax: number | null
      giftWrapPrice: number | null
      giftWrapTax: number | null
      itemPromotionDiscount: number | null
      shipPromotionDiscount: number | null
      currency: string
      conditionNote: string | null
      conditionId: string | null
      conditionSubtypeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amazonOrderItem"]>
    composites: {}
  }

  type AmazonOrderItemGetPayload<S extends boolean | null | undefined | AmazonOrderItemDefaultArgs> = $Result.GetResult<Prisma.$AmazonOrderItemPayload, S>

  type AmazonOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmazonOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmazonOrderItemCountAggregateInputType | true
    }

  export interface AmazonOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmazonOrderItem'], meta: { name: 'AmazonOrderItem' } }
    /**
     * Find zero or one AmazonOrderItem that matches the filter.
     * @param {AmazonOrderItemFindUniqueArgs} args - Arguments to find a AmazonOrderItem
     * @example
     * // Get one AmazonOrderItem
     * const amazonOrderItem = await prisma.amazonOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmazonOrderItemFindUniqueArgs>(args: SelectSubset<T, AmazonOrderItemFindUniqueArgs<ExtArgs>>): Prisma__AmazonOrderItemClient<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmazonOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmazonOrderItemFindUniqueOrThrowArgs} args - Arguments to find a AmazonOrderItem
     * @example
     * // Get one AmazonOrderItem
     * const amazonOrderItem = await prisma.amazonOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmazonOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AmazonOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmazonOrderItemClient<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmazonOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderItemFindFirstArgs} args - Arguments to find a AmazonOrderItem
     * @example
     * // Get one AmazonOrderItem
     * const amazonOrderItem = await prisma.amazonOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmazonOrderItemFindFirstArgs>(args?: SelectSubset<T, AmazonOrderItemFindFirstArgs<ExtArgs>>): Prisma__AmazonOrderItemClient<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmazonOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderItemFindFirstOrThrowArgs} args - Arguments to find a AmazonOrderItem
     * @example
     * // Get one AmazonOrderItem
     * const amazonOrderItem = await prisma.amazonOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmazonOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AmazonOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmazonOrderItemClient<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmazonOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmazonOrderItems
     * const amazonOrderItems = await prisma.amazonOrderItem.findMany()
     * 
     * // Get first 10 AmazonOrderItems
     * const amazonOrderItems = await prisma.amazonOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amazonOrderItemWithIdOnly = await prisma.amazonOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmazonOrderItemFindManyArgs>(args?: SelectSubset<T, AmazonOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmazonOrderItem.
     * @param {AmazonOrderItemCreateArgs} args - Arguments to create a AmazonOrderItem.
     * @example
     * // Create one AmazonOrderItem
     * const AmazonOrderItem = await prisma.amazonOrderItem.create({
     *   data: {
     *     // ... data to create a AmazonOrderItem
     *   }
     * })
     * 
     */
    create<T extends AmazonOrderItemCreateArgs>(args: SelectSubset<T, AmazonOrderItemCreateArgs<ExtArgs>>): Prisma__AmazonOrderItemClient<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmazonOrderItems.
     * @param {AmazonOrderItemCreateManyArgs} args - Arguments to create many AmazonOrderItems.
     * @example
     * // Create many AmazonOrderItems
     * const amazonOrderItem = await prisma.amazonOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmazonOrderItemCreateManyArgs>(args?: SelectSubset<T, AmazonOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AmazonOrderItems and returns the data saved in the database.
     * @param {AmazonOrderItemCreateManyAndReturnArgs} args - Arguments to create many AmazonOrderItems.
     * @example
     * // Create many AmazonOrderItems
     * const amazonOrderItem = await prisma.amazonOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AmazonOrderItems and only return the `id`
     * const amazonOrderItemWithIdOnly = await prisma.amazonOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmazonOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AmazonOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AmazonOrderItem.
     * @param {AmazonOrderItemDeleteArgs} args - Arguments to delete one AmazonOrderItem.
     * @example
     * // Delete one AmazonOrderItem
     * const AmazonOrderItem = await prisma.amazonOrderItem.delete({
     *   where: {
     *     // ... filter to delete one AmazonOrderItem
     *   }
     * })
     * 
     */
    delete<T extends AmazonOrderItemDeleteArgs>(args: SelectSubset<T, AmazonOrderItemDeleteArgs<ExtArgs>>): Prisma__AmazonOrderItemClient<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmazonOrderItem.
     * @param {AmazonOrderItemUpdateArgs} args - Arguments to update one AmazonOrderItem.
     * @example
     * // Update one AmazonOrderItem
     * const amazonOrderItem = await prisma.amazonOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmazonOrderItemUpdateArgs>(args: SelectSubset<T, AmazonOrderItemUpdateArgs<ExtArgs>>): Prisma__AmazonOrderItemClient<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmazonOrderItems.
     * @param {AmazonOrderItemDeleteManyArgs} args - Arguments to filter AmazonOrderItems to delete.
     * @example
     * // Delete a few AmazonOrderItems
     * const { count } = await prisma.amazonOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmazonOrderItemDeleteManyArgs>(args?: SelectSubset<T, AmazonOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmazonOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmazonOrderItems
     * const amazonOrderItem = await prisma.amazonOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmazonOrderItemUpdateManyArgs>(args: SelectSubset<T, AmazonOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmazonOrderItems and returns the data updated in the database.
     * @param {AmazonOrderItemUpdateManyAndReturnArgs} args - Arguments to update many AmazonOrderItems.
     * @example
     * // Update many AmazonOrderItems
     * const amazonOrderItem = await prisma.amazonOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AmazonOrderItems and only return the `id`
     * const amazonOrderItemWithIdOnly = await prisma.amazonOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmazonOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, AmazonOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AmazonOrderItem.
     * @param {AmazonOrderItemUpsertArgs} args - Arguments to update or create a AmazonOrderItem.
     * @example
     * // Update or create a AmazonOrderItem
     * const amazonOrderItem = await prisma.amazonOrderItem.upsert({
     *   create: {
     *     // ... data to create a AmazonOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmazonOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends AmazonOrderItemUpsertArgs>(args: SelectSubset<T, AmazonOrderItemUpsertArgs<ExtArgs>>): Prisma__AmazonOrderItemClient<$Result.GetResult<Prisma.$AmazonOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmazonOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderItemCountArgs} args - Arguments to filter AmazonOrderItems to count.
     * @example
     * // Count the number of AmazonOrderItems
     * const count = await prisma.amazonOrderItem.count({
     *   where: {
     *     // ... the filter for the AmazonOrderItems we want to count
     *   }
     * })
    **/
    count<T extends AmazonOrderItemCountArgs>(
      args?: Subset<T, AmazonOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmazonOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmazonOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmazonOrderItemAggregateArgs>(args: Subset<T, AmazonOrderItemAggregateArgs>): Prisma.PrismaPromise<GetAmazonOrderItemAggregateType<T>>

    /**
     * Group by AmazonOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmazonOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmazonOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: AmazonOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmazonOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmazonOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmazonOrderItem model
   */
  readonly fields: AmazonOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmazonOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmazonOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends AmazonOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmazonOrderDefaultArgs<ExtArgs>>): Prisma__AmazonOrderClient<$Result.GetResult<Prisma.$AmazonOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmazonOrderItem model
   */
  interface AmazonOrderItemFieldRefs {
    readonly id: FieldRef<"AmazonOrderItem", 'String'>
    readonly orderItemId: FieldRef<"AmazonOrderItem", 'String'>
    readonly amazonOrderId: FieldRef<"AmazonOrderItem", 'String'>
    readonly asin: FieldRef<"AmazonOrderItem", 'String'>
    readonly sellerSKU: FieldRef<"AmazonOrderItem", 'String'>
    readonly title: FieldRef<"AmazonOrderItem", 'String'>
    readonly quantityOrdered: FieldRef<"AmazonOrderItem", 'Int'>
    readonly quantityShipped: FieldRef<"AmazonOrderItem", 'Int'>
    readonly itemPrice: FieldRef<"AmazonOrderItem", 'Float'>
    readonly itemTax: FieldRef<"AmazonOrderItem", 'Float'>
    readonly shippingPrice: FieldRef<"AmazonOrderItem", 'Float'>
    readonly shippingTax: FieldRef<"AmazonOrderItem", 'Float'>
    readonly giftWrapPrice: FieldRef<"AmazonOrderItem", 'Float'>
    readonly giftWrapTax: FieldRef<"AmazonOrderItem", 'Float'>
    readonly itemPromotionDiscount: FieldRef<"AmazonOrderItem", 'Float'>
    readonly shipPromotionDiscount: FieldRef<"AmazonOrderItem", 'Float'>
    readonly currency: FieldRef<"AmazonOrderItem", 'String'>
    readonly conditionNote: FieldRef<"AmazonOrderItem", 'String'>
    readonly conditionId: FieldRef<"AmazonOrderItem", 'String'>
    readonly conditionSubtypeId: FieldRef<"AmazonOrderItem", 'String'>
    readonly createdAt: FieldRef<"AmazonOrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"AmazonOrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AmazonOrderItem findUnique
   */
  export type AmazonOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrderItem to fetch.
     */
    where: AmazonOrderItemWhereUniqueInput
  }

  /**
   * AmazonOrderItem findUniqueOrThrow
   */
  export type AmazonOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrderItem to fetch.
     */
    where: AmazonOrderItemWhereUniqueInput
  }

  /**
   * AmazonOrderItem findFirst
   */
  export type AmazonOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrderItem to fetch.
     */
    where?: AmazonOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonOrderItems to fetch.
     */
    orderBy?: AmazonOrderItemOrderByWithRelationInput | AmazonOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmazonOrderItems.
     */
    cursor?: AmazonOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmazonOrderItems.
     */
    distinct?: AmazonOrderItemScalarFieldEnum | AmazonOrderItemScalarFieldEnum[]
  }

  /**
   * AmazonOrderItem findFirstOrThrow
   */
  export type AmazonOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrderItem to fetch.
     */
    where?: AmazonOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonOrderItems to fetch.
     */
    orderBy?: AmazonOrderItemOrderByWithRelationInput | AmazonOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmazonOrderItems.
     */
    cursor?: AmazonOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmazonOrderItems.
     */
    distinct?: AmazonOrderItemScalarFieldEnum | AmazonOrderItemScalarFieldEnum[]
  }

  /**
   * AmazonOrderItem findMany
   */
  export type AmazonOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which AmazonOrderItems to fetch.
     */
    where?: AmazonOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonOrderItems to fetch.
     */
    orderBy?: AmazonOrderItemOrderByWithRelationInput | AmazonOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmazonOrderItems.
     */
    cursor?: AmazonOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonOrderItems.
     */
    skip?: number
    distinct?: AmazonOrderItemScalarFieldEnum | AmazonOrderItemScalarFieldEnum[]
  }

  /**
   * AmazonOrderItem create
   */
  export type AmazonOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AmazonOrderItem.
     */
    data: XOR<AmazonOrderItemCreateInput, AmazonOrderItemUncheckedCreateInput>
  }

  /**
   * AmazonOrderItem createMany
   */
  export type AmazonOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmazonOrderItems.
     */
    data: AmazonOrderItemCreateManyInput | AmazonOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmazonOrderItem createManyAndReturn
   */
  export type AmazonOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many AmazonOrderItems.
     */
    data: AmazonOrderItemCreateManyInput | AmazonOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AmazonOrderItem update
   */
  export type AmazonOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AmazonOrderItem.
     */
    data: XOR<AmazonOrderItemUpdateInput, AmazonOrderItemUncheckedUpdateInput>
    /**
     * Choose, which AmazonOrderItem to update.
     */
    where: AmazonOrderItemWhereUniqueInput
  }

  /**
   * AmazonOrderItem updateMany
   */
  export type AmazonOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmazonOrderItems.
     */
    data: XOR<AmazonOrderItemUpdateManyMutationInput, AmazonOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which AmazonOrderItems to update
     */
    where?: AmazonOrderItemWhereInput
    /**
     * Limit how many AmazonOrderItems to update.
     */
    limit?: number
  }

  /**
   * AmazonOrderItem updateManyAndReturn
   */
  export type AmazonOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update AmazonOrderItems.
     */
    data: XOR<AmazonOrderItemUpdateManyMutationInput, AmazonOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which AmazonOrderItems to update
     */
    where?: AmazonOrderItemWhereInput
    /**
     * Limit how many AmazonOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AmazonOrderItem upsert
   */
  export type AmazonOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AmazonOrderItem to update in case it exists.
     */
    where: AmazonOrderItemWhereUniqueInput
    /**
     * In case the AmazonOrderItem found by the `where` argument doesn't exist, create a new AmazonOrderItem with this data.
     */
    create: XOR<AmazonOrderItemCreateInput, AmazonOrderItemUncheckedCreateInput>
    /**
     * In case the AmazonOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmazonOrderItemUpdateInput, AmazonOrderItemUncheckedUpdateInput>
  }

  /**
   * AmazonOrderItem delete
   */
  export type AmazonOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
    /**
     * Filter which AmazonOrderItem to delete.
     */
    where: AmazonOrderItemWhereUniqueInput
  }

  /**
   * AmazonOrderItem deleteMany
   */
  export type AmazonOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmazonOrderItems to delete
     */
    where?: AmazonOrderItemWhereInput
    /**
     * Limit how many AmazonOrderItems to delete.
     */
    limit?: number
  }

  /**
   * AmazonOrderItem without action
   */
  export type AmazonOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonOrderItem
     */
    select?: AmazonOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonOrderItem
     */
    omit?: AmazonOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmazonOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model AmazonInventory
   */

  export type AggregateAmazonInventory = {
    _count: AmazonInventoryCountAggregateOutputType | null
    _avg: AmazonInventoryAvgAggregateOutputType | null
    _sum: AmazonInventorySumAggregateOutputType | null
    _min: AmazonInventoryMinAggregateOutputType | null
    _max: AmazonInventoryMaxAggregateOutputType | null
  }

  export type AmazonInventoryAvgAggregateOutputType = {
    totalQuantity: number | null
    inStockQuantity: number | null
    availableQuantity: number | null
    fulfillableQuantity: number | null
    inboundWorkingQuantity: number | null
    inboundShippedQuantity: number | null
    inboundReceivingQuantity: number | null
    reservedQuantity: number | null
    unfulfillableQuantity: number | null
  }

  export type AmazonInventorySumAggregateOutputType = {
    totalQuantity: number | null
    inStockQuantity: number | null
    availableQuantity: number | null
    fulfillableQuantity: number | null
    inboundWorkingQuantity: number | null
    inboundShippedQuantity: number | null
    inboundReceivingQuantity: number | null
    reservedQuantity: number | null
    unfulfillableQuantity: number | null
  }

  export type AmazonInventoryMinAggregateOutputType = {
    id: string | null
    sellerSKU: string | null
    asin: string | null
    fnSKU: string | null
    productName: string | null
    condition: string | null
    totalQuantity: number | null
    inStockQuantity: number | null
    availableQuantity: number | null
    fulfillableQuantity: number | null
    inboundWorkingQuantity: number | null
    inboundShippedQuantity: number | null
    inboundReceivingQuantity: number | null
    reservedQuantity: number | null
    unfulfillableQuantity: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmazonInventoryMaxAggregateOutputType = {
    id: string | null
    sellerSKU: string | null
    asin: string | null
    fnSKU: string | null
    productName: string | null
    condition: string | null
    totalQuantity: number | null
    inStockQuantity: number | null
    availableQuantity: number | null
    fulfillableQuantity: number | null
    inboundWorkingQuantity: number | null
    inboundShippedQuantity: number | null
    inboundReceivingQuantity: number | null
    reservedQuantity: number | null
    unfulfillableQuantity: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmazonInventoryCountAggregateOutputType = {
    id: number
    sellerSKU: number
    asin: number
    fnSKU: number
    productName: number
    condition: number
    totalQuantity: number
    inStockQuantity: number
    availableQuantity: number
    fulfillableQuantity: number
    inboundWorkingQuantity: number
    inboundShippedQuantity: number
    inboundReceivingQuantity: number
    reservedQuantity: number
    unfulfillableQuantity: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmazonInventoryAvgAggregateInputType = {
    totalQuantity?: true
    inStockQuantity?: true
    availableQuantity?: true
    fulfillableQuantity?: true
    inboundWorkingQuantity?: true
    inboundShippedQuantity?: true
    inboundReceivingQuantity?: true
    reservedQuantity?: true
    unfulfillableQuantity?: true
  }

  export type AmazonInventorySumAggregateInputType = {
    totalQuantity?: true
    inStockQuantity?: true
    availableQuantity?: true
    fulfillableQuantity?: true
    inboundWorkingQuantity?: true
    inboundShippedQuantity?: true
    inboundReceivingQuantity?: true
    reservedQuantity?: true
    unfulfillableQuantity?: true
  }

  export type AmazonInventoryMinAggregateInputType = {
    id?: true
    sellerSKU?: true
    asin?: true
    fnSKU?: true
    productName?: true
    condition?: true
    totalQuantity?: true
    inStockQuantity?: true
    availableQuantity?: true
    fulfillableQuantity?: true
    inboundWorkingQuantity?: true
    inboundShippedQuantity?: true
    inboundReceivingQuantity?: true
    reservedQuantity?: true
    unfulfillableQuantity?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmazonInventoryMaxAggregateInputType = {
    id?: true
    sellerSKU?: true
    asin?: true
    fnSKU?: true
    productName?: true
    condition?: true
    totalQuantity?: true
    inStockQuantity?: true
    availableQuantity?: true
    fulfillableQuantity?: true
    inboundWorkingQuantity?: true
    inboundShippedQuantity?: true
    inboundReceivingQuantity?: true
    reservedQuantity?: true
    unfulfillableQuantity?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmazonInventoryCountAggregateInputType = {
    id?: true
    sellerSKU?: true
    asin?: true
    fnSKU?: true
    productName?: true
    condition?: true
    totalQuantity?: true
    inStockQuantity?: true
    availableQuantity?: true
    fulfillableQuantity?: true
    inboundWorkingQuantity?: true
    inboundShippedQuantity?: true
    inboundReceivingQuantity?: true
    reservedQuantity?: true
    unfulfillableQuantity?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmazonInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmazonInventory to aggregate.
     */
    where?: AmazonInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonInventories to fetch.
     */
    orderBy?: AmazonInventoryOrderByWithRelationInput | AmazonInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmazonInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmazonInventories
    **/
    _count?: true | AmazonInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmazonInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmazonInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmazonInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmazonInventoryMaxAggregateInputType
  }

  export type GetAmazonInventoryAggregateType<T extends AmazonInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAmazonInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmazonInventory[P]>
      : GetScalarType<T[P], AggregateAmazonInventory[P]>
  }




  export type AmazonInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmazonInventoryWhereInput
    orderBy?: AmazonInventoryOrderByWithAggregationInput | AmazonInventoryOrderByWithAggregationInput[]
    by: AmazonInventoryScalarFieldEnum[] | AmazonInventoryScalarFieldEnum
    having?: AmazonInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmazonInventoryCountAggregateInputType | true
    _avg?: AmazonInventoryAvgAggregateInputType
    _sum?: AmazonInventorySumAggregateInputType
    _min?: AmazonInventoryMinAggregateInputType
    _max?: AmazonInventoryMaxAggregateInputType
  }

  export type AmazonInventoryGroupByOutputType = {
    id: string
    sellerSKU: string
    asin: string | null
    fnSKU: string | null
    productName: string | null
    condition: string | null
    totalQuantity: number
    inStockQuantity: number
    availableQuantity: number
    fulfillableQuantity: number
    inboundWorkingQuantity: number
    inboundShippedQuantity: number
    inboundReceivingQuantity: number
    reservedQuantity: number
    unfulfillableQuantity: number
    lastUpdated: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AmazonInventoryCountAggregateOutputType | null
    _avg: AmazonInventoryAvgAggregateOutputType | null
    _sum: AmazonInventorySumAggregateOutputType | null
    _min: AmazonInventoryMinAggregateOutputType | null
    _max: AmazonInventoryMaxAggregateOutputType | null
  }

  type GetAmazonInventoryGroupByPayload<T extends AmazonInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmazonInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmazonInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmazonInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], AmazonInventoryGroupByOutputType[P]>
        }
      >
    >


  export type AmazonInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerSKU?: boolean
    asin?: boolean
    fnSKU?: boolean
    productName?: boolean
    condition?: boolean
    totalQuantity?: boolean
    inStockQuantity?: boolean
    availableQuantity?: boolean
    fulfillableQuantity?: boolean
    inboundWorkingQuantity?: boolean
    inboundShippedQuantity?: boolean
    inboundReceivingQuantity?: boolean
    reservedQuantity?: boolean
    unfulfillableQuantity?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amazonInventory"]>

  export type AmazonInventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerSKU?: boolean
    asin?: boolean
    fnSKU?: boolean
    productName?: boolean
    condition?: boolean
    totalQuantity?: boolean
    inStockQuantity?: boolean
    availableQuantity?: boolean
    fulfillableQuantity?: boolean
    inboundWorkingQuantity?: boolean
    inboundShippedQuantity?: boolean
    inboundReceivingQuantity?: boolean
    reservedQuantity?: boolean
    unfulfillableQuantity?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amazonInventory"]>

  export type AmazonInventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerSKU?: boolean
    asin?: boolean
    fnSKU?: boolean
    productName?: boolean
    condition?: boolean
    totalQuantity?: boolean
    inStockQuantity?: boolean
    availableQuantity?: boolean
    fulfillableQuantity?: boolean
    inboundWorkingQuantity?: boolean
    inboundShippedQuantity?: boolean
    inboundReceivingQuantity?: boolean
    reservedQuantity?: boolean
    unfulfillableQuantity?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amazonInventory"]>

  export type AmazonInventorySelectScalar = {
    id?: boolean
    sellerSKU?: boolean
    asin?: boolean
    fnSKU?: boolean
    productName?: boolean
    condition?: boolean
    totalQuantity?: boolean
    inStockQuantity?: boolean
    availableQuantity?: boolean
    fulfillableQuantity?: boolean
    inboundWorkingQuantity?: boolean
    inboundShippedQuantity?: boolean
    inboundReceivingQuantity?: boolean
    reservedQuantity?: boolean
    unfulfillableQuantity?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmazonInventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerSKU" | "asin" | "fnSKU" | "productName" | "condition" | "totalQuantity" | "inStockQuantity" | "availableQuantity" | "fulfillableQuantity" | "inboundWorkingQuantity" | "inboundShippedQuantity" | "inboundReceivingQuantity" | "reservedQuantity" | "unfulfillableQuantity" | "lastUpdated" | "createdAt" | "updatedAt", ExtArgs["result"]["amazonInventory"]>

  export type $AmazonInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmazonInventory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellerSKU: string
      asin: string | null
      fnSKU: string | null
      productName: string | null
      condition: string | null
      totalQuantity: number
      inStockQuantity: number
      availableQuantity: number
      fulfillableQuantity: number
      inboundWorkingQuantity: number
      inboundShippedQuantity: number
      inboundReceivingQuantity: number
      reservedQuantity: number
      unfulfillableQuantity: number
      lastUpdated: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amazonInventory"]>
    composites: {}
  }

  type AmazonInventoryGetPayload<S extends boolean | null | undefined | AmazonInventoryDefaultArgs> = $Result.GetResult<Prisma.$AmazonInventoryPayload, S>

  type AmazonInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmazonInventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmazonInventoryCountAggregateInputType | true
    }

  export interface AmazonInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmazonInventory'], meta: { name: 'AmazonInventory' } }
    /**
     * Find zero or one AmazonInventory that matches the filter.
     * @param {AmazonInventoryFindUniqueArgs} args - Arguments to find a AmazonInventory
     * @example
     * // Get one AmazonInventory
     * const amazonInventory = await prisma.amazonInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmazonInventoryFindUniqueArgs>(args: SelectSubset<T, AmazonInventoryFindUniqueArgs<ExtArgs>>): Prisma__AmazonInventoryClient<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AmazonInventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmazonInventoryFindUniqueOrThrowArgs} args - Arguments to find a AmazonInventory
     * @example
     * // Get one AmazonInventory
     * const amazonInventory = await prisma.amazonInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmazonInventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AmazonInventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmazonInventoryClient<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmazonInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonInventoryFindFirstArgs} args - Arguments to find a AmazonInventory
     * @example
     * // Get one AmazonInventory
     * const amazonInventory = await prisma.amazonInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmazonInventoryFindFirstArgs>(args?: SelectSubset<T, AmazonInventoryFindFirstArgs<ExtArgs>>): Prisma__AmazonInventoryClient<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AmazonInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonInventoryFindFirstOrThrowArgs} args - Arguments to find a AmazonInventory
     * @example
     * // Get one AmazonInventory
     * const amazonInventory = await prisma.amazonInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmazonInventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AmazonInventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmazonInventoryClient<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AmazonInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonInventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmazonInventories
     * const amazonInventories = await prisma.amazonInventory.findMany()
     * 
     * // Get first 10 AmazonInventories
     * const amazonInventories = await prisma.amazonInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amazonInventoryWithIdOnly = await prisma.amazonInventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmazonInventoryFindManyArgs>(args?: SelectSubset<T, AmazonInventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AmazonInventory.
     * @param {AmazonInventoryCreateArgs} args - Arguments to create a AmazonInventory.
     * @example
     * // Create one AmazonInventory
     * const AmazonInventory = await prisma.amazonInventory.create({
     *   data: {
     *     // ... data to create a AmazonInventory
     *   }
     * })
     * 
     */
    create<T extends AmazonInventoryCreateArgs>(args: SelectSubset<T, AmazonInventoryCreateArgs<ExtArgs>>): Prisma__AmazonInventoryClient<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AmazonInventories.
     * @param {AmazonInventoryCreateManyArgs} args - Arguments to create many AmazonInventories.
     * @example
     * // Create many AmazonInventories
     * const amazonInventory = await prisma.amazonInventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmazonInventoryCreateManyArgs>(args?: SelectSubset<T, AmazonInventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AmazonInventories and returns the data saved in the database.
     * @param {AmazonInventoryCreateManyAndReturnArgs} args - Arguments to create many AmazonInventories.
     * @example
     * // Create many AmazonInventories
     * const amazonInventory = await prisma.amazonInventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AmazonInventories and only return the `id`
     * const amazonInventoryWithIdOnly = await prisma.amazonInventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmazonInventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AmazonInventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AmazonInventory.
     * @param {AmazonInventoryDeleteArgs} args - Arguments to delete one AmazonInventory.
     * @example
     * // Delete one AmazonInventory
     * const AmazonInventory = await prisma.amazonInventory.delete({
     *   where: {
     *     // ... filter to delete one AmazonInventory
     *   }
     * })
     * 
     */
    delete<T extends AmazonInventoryDeleteArgs>(args: SelectSubset<T, AmazonInventoryDeleteArgs<ExtArgs>>): Prisma__AmazonInventoryClient<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AmazonInventory.
     * @param {AmazonInventoryUpdateArgs} args - Arguments to update one AmazonInventory.
     * @example
     * // Update one AmazonInventory
     * const amazonInventory = await prisma.amazonInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmazonInventoryUpdateArgs>(args: SelectSubset<T, AmazonInventoryUpdateArgs<ExtArgs>>): Prisma__AmazonInventoryClient<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AmazonInventories.
     * @param {AmazonInventoryDeleteManyArgs} args - Arguments to filter AmazonInventories to delete.
     * @example
     * // Delete a few AmazonInventories
     * const { count } = await prisma.amazonInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmazonInventoryDeleteManyArgs>(args?: SelectSubset<T, AmazonInventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmazonInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmazonInventories
     * const amazonInventory = await prisma.amazonInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmazonInventoryUpdateManyArgs>(args: SelectSubset<T, AmazonInventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmazonInventories and returns the data updated in the database.
     * @param {AmazonInventoryUpdateManyAndReturnArgs} args - Arguments to update many AmazonInventories.
     * @example
     * // Update many AmazonInventories
     * const amazonInventory = await prisma.amazonInventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AmazonInventories and only return the `id`
     * const amazonInventoryWithIdOnly = await prisma.amazonInventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmazonInventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, AmazonInventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AmazonInventory.
     * @param {AmazonInventoryUpsertArgs} args - Arguments to update or create a AmazonInventory.
     * @example
     * // Update or create a AmazonInventory
     * const amazonInventory = await prisma.amazonInventory.upsert({
     *   create: {
     *     // ... data to create a AmazonInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmazonInventory we want to update
     *   }
     * })
     */
    upsert<T extends AmazonInventoryUpsertArgs>(args: SelectSubset<T, AmazonInventoryUpsertArgs<ExtArgs>>): Prisma__AmazonInventoryClient<$Result.GetResult<Prisma.$AmazonInventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AmazonInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonInventoryCountArgs} args - Arguments to filter AmazonInventories to count.
     * @example
     * // Count the number of AmazonInventories
     * const count = await prisma.amazonInventory.count({
     *   where: {
     *     // ... the filter for the AmazonInventories we want to count
     *   }
     * })
    **/
    count<T extends AmazonInventoryCountArgs>(
      args?: Subset<T, AmazonInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmazonInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmazonInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmazonInventoryAggregateArgs>(args: Subset<T, AmazonInventoryAggregateArgs>): Prisma.PrismaPromise<GetAmazonInventoryAggregateType<T>>

    /**
     * Group by AmazonInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmazonInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmazonInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmazonInventoryGroupByArgs['orderBy'] }
        : { orderBy?: AmazonInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmazonInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmazonInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmazonInventory model
   */
  readonly fields: AmazonInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmazonInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmazonInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmazonInventory model
   */
  interface AmazonInventoryFieldRefs {
    readonly id: FieldRef<"AmazonInventory", 'String'>
    readonly sellerSKU: FieldRef<"AmazonInventory", 'String'>
    readonly asin: FieldRef<"AmazonInventory", 'String'>
    readonly fnSKU: FieldRef<"AmazonInventory", 'String'>
    readonly productName: FieldRef<"AmazonInventory", 'String'>
    readonly condition: FieldRef<"AmazonInventory", 'String'>
    readonly totalQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly inStockQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly availableQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly fulfillableQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly inboundWorkingQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly inboundShippedQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly inboundReceivingQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly reservedQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly unfulfillableQuantity: FieldRef<"AmazonInventory", 'Int'>
    readonly lastUpdated: FieldRef<"AmazonInventory", 'DateTime'>
    readonly createdAt: FieldRef<"AmazonInventory", 'DateTime'>
    readonly updatedAt: FieldRef<"AmazonInventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AmazonInventory findUnique
   */
  export type AmazonInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * Filter, which AmazonInventory to fetch.
     */
    where: AmazonInventoryWhereUniqueInput
  }

  /**
   * AmazonInventory findUniqueOrThrow
   */
  export type AmazonInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * Filter, which AmazonInventory to fetch.
     */
    where: AmazonInventoryWhereUniqueInput
  }

  /**
   * AmazonInventory findFirst
   */
  export type AmazonInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * Filter, which AmazonInventory to fetch.
     */
    where?: AmazonInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonInventories to fetch.
     */
    orderBy?: AmazonInventoryOrderByWithRelationInput | AmazonInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmazonInventories.
     */
    cursor?: AmazonInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmazonInventories.
     */
    distinct?: AmazonInventoryScalarFieldEnum | AmazonInventoryScalarFieldEnum[]
  }

  /**
   * AmazonInventory findFirstOrThrow
   */
  export type AmazonInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * Filter, which AmazonInventory to fetch.
     */
    where?: AmazonInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonInventories to fetch.
     */
    orderBy?: AmazonInventoryOrderByWithRelationInput | AmazonInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmazonInventories.
     */
    cursor?: AmazonInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmazonInventories.
     */
    distinct?: AmazonInventoryScalarFieldEnum | AmazonInventoryScalarFieldEnum[]
  }

  /**
   * AmazonInventory findMany
   */
  export type AmazonInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * Filter, which AmazonInventories to fetch.
     */
    where?: AmazonInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmazonInventories to fetch.
     */
    orderBy?: AmazonInventoryOrderByWithRelationInput | AmazonInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmazonInventories.
     */
    cursor?: AmazonInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmazonInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmazonInventories.
     */
    skip?: number
    distinct?: AmazonInventoryScalarFieldEnum | AmazonInventoryScalarFieldEnum[]
  }

  /**
   * AmazonInventory create
   */
  export type AmazonInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * The data needed to create a AmazonInventory.
     */
    data: XOR<AmazonInventoryCreateInput, AmazonInventoryUncheckedCreateInput>
  }

  /**
   * AmazonInventory createMany
   */
  export type AmazonInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmazonInventories.
     */
    data: AmazonInventoryCreateManyInput | AmazonInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmazonInventory createManyAndReturn
   */
  export type AmazonInventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * The data used to create many AmazonInventories.
     */
    data: AmazonInventoryCreateManyInput | AmazonInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmazonInventory update
   */
  export type AmazonInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * The data needed to update a AmazonInventory.
     */
    data: XOR<AmazonInventoryUpdateInput, AmazonInventoryUncheckedUpdateInput>
    /**
     * Choose, which AmazonInventory to update.
     */
    where: AmazonInventoryWhereUniqueInput
  }

  /**
   * AmazonInventory updateMany
   */
  export type AmazonInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmazonInventories.
     */
    data: XOR<AmazonInventoryUpdateManyMutationInput, AmazonInventoryUncheckedUpdateManyInput>
    /**
     * Filter which AmazonInventories to update
     */
    where?: AmazonInventoryWhereInput
    /**
     * Limit how many AmazonInventories to update.
     */
    limit?: number
  }

  /**
   * AmazonInventory updateManyAndReturn
   */
  export type AmazonInventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * The data used to update AmazonInventories.
     */
    data: XOR<AmazonInventoryUpdateManyMutationInput, AmazonInventoryUncheckedUpdateManyInput>
    /**
     * Filter which AmazonInventories to update
     */
    where?: AmazonInventoryWhereInput
    /**
     * Limit how many AmazonInventories to update.
     */
    limit?: number
  }

  /**
   * AmazonInventory upsert
   */
  export type AmazonInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * The filter to search for the AmazonInventory to update in case it exists.
     */
    where: AmazonInventoryWhereUniqueInput
    /**
     * In case the AmazonInventory found by the `where` argument doesn't exist, create a new AmazonInventory with this data.
     */
    create: XOR<AmazonInventoryCreateInput, AmazonInventoryUncheckedCreateInput>
    /**
     * In case the AmazonInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmazonInventoryUpdateInput, AmazonInventoryUncheckedUpdateInput>
  }

  /**
   * AmazonInventory delete
   */
  export type AmazonInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
    /**
     * Filter which AmazonInventory to delete.
     */
    where: AmazonInventoryWhereUniqueInput
  }

  /**
   * AmazonInventory deleteMany
   */
  export type AmazonInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmazonInventories to delete
     */
    where?: AmazonInventoryWhereInput
    /**
     * Limit how many AmazonInventories to delete.
     */
    limit?: number
  }

  /**
   * AmazonInventory without action
   */
  export type AmazonInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmazonInventory
     */
    select?: AmazonInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmazonInventory
     */
    omit?: AmazonInventoryOmit<ExtArgs> | null
  }


  /**
   * Model ShopifyOrder
   */

  export type AggregateShopifyOrder = {
    _count: ShopifyOrderCountAggregateOutputType | null
    _avg: ShopifyOrderAvgAggregateOutputType | null
    _sum: ShopifyOrderSumAggregateOutputType | null
    _min: ShopifyOrderMinAggregateOutputType | null
    _max: ShopifyOrderMaxAggregateOutputType | null
  }

  export type ShopifyOrderAvgAggregateOutputType = {
    totalPrice: number | null
    totalTax: number | null
    totalDiscounts: number | null
    totalWeight: number | null
  }

  export type ShopifyOrderSumAggregateOutputType = {
    totalPrice: number | null
    totalTax: number | null
    totalDiscounts: number | null
    totalWeight: number | null
  }

  export type ShopifyOrderMinAggregateOutputType = {
    id: string | null
    shopifyOrderId: string | null
    orderNumber: string | null
    email: string | null
    phone: string | null
    name: string | null
    financialStatus: string | null
    fulfillmentStatus: string | null
    tags: string | null
    totalPrice: number | null
    totalTax: number | null
    totalDiscounts: number | null
    totalWeight: number | null
    currency: string | null
    processedAt: Date | null
    closedAt: Date | null
    cancelledAt: Date | null
    test: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopifyOrderMaxAggregateOutputType = {
    id: string | null
    shopifyOrderId: string | null
    orderNumber: string | null
    email: string | null
    phone: string | null
    name: string | null
    financialStatus: string | null
    fulfillmentStatus: string | null
    tags: string | null
    totalPrice: number | null
    totalTax: number | null
    totalDiscounts: number | null
    totalWeight: number | null
    currency: string | null
    processedAt: Date | null
    closedAt: Date | null
    cancelledAt: Date | null
    test: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopifyOrderCountAggregateOutputType = {
    id: number
    shopifyOrderId: number
    orderNumber: number
    email: number
    phone: number
    name: number
    financialStatus: number
    fulfillmentStatus: number
    tags: number
    totalPrice: number
    totalTax: number
    totalDiscounts: number
    totalWeight: number
    currency: number
    processedAt: number
    closedAt: number
    cancelledAt: number
    test: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopifyOrderAvgAggregateInputType = {
    totalPrice?: true
    totalTax?: true
    totalDiscounts?: true
    totalWeight?: true
  }

  export type ShopifyOrderSumAggregateInputType = {
    totalPrice?: true
    totalTax?: true
    totalDiscounts?: true
    totalWeight?: true
  }

  export type ShopifyOrderMinAggregateInputType = {
    id?: true
    shopifyOrderId?: true
    orderNumber?: true
    email?: true
    phone?: true
    name?: true
    financialStatus?: true
    fulfillmentStatus?: true
    tags?: true
    totalPrice?: true
    totalTax?: true
    totalDiscounts?: true
    totalWeight?: true
    currency?: true
    processedAt?: true
    closedAt?: true
    cancelledAt?: true
    test?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopifyOrderMaxAggregateInputType = {
    id?: true
    shopifyOrderId?: true
    orderNumber?: true
    email?: true
    phone?: true
    name?: true
    financialStatus?: true
    fulfillmentStatus?: true
    tags?: true
    totalPrice?: true
    totalTax?: true
    totalDiscounts?: true
    totalWeight?: true
    currency?: true
    processedAt?: true
    closedAt?: true
    cancelledAt?: true
    test?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopifyOrderCountAggregateInputType = {
    id?: true
    shopifyOrderId?: true
    orderNumber?: true
    email?: true
    phone?: true
    name?: true
    financialStatus?: true
    fulfillmentStatus?: true
    tags?: true
    totalPrice?: true
    totalTax?: true
    totalDiscounts?: true
    totalWeight?: true
    currency?: true
    processedAt?: true
    closedAt?: true
    cancelledAt?: true
    test?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopifyOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopifyOrder to aggregate.
     */
    where?: ShopifyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyOrders to fetch.
     */
    orderBy?: ShopifyOrderOrderByWithRelationInput | ShopifyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopifyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopifyOrders
    **/
    _count?: true | ShopifyOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopifyOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopifyOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopifyOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopifyOrderMaxAggregateInputType
  }

  export type GetShopifyOrderAggregateType<T extends ShopifyOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateShopifyOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopifyOrder[P]>
      : GetScalarType<T[P], AggregateShopifyOrder[P]>
  }




  export type ShopifyOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopifyOrderWhereInput
    orderBy?: ShopifyOrderOrderByWithAggregationInput | ShopifyOrderOrderByWithAggregationInput[]
    by: ShopifyOrderScalarFieldEnum[] | ShopifyOrderScalarFieldEnum
    having?: ShopifyOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopifyOrderCountAggregateInputType | true
    _avg?: ShopifyOrderAvgAggregateInputType
    _sum?: ShopifyOrderSumAggregateInputType
    _min?: ShopifyOrderMinAggregateInputType
    _max?: ShopifyOrderMaxAggregateInputType
  }

  export type ShopifyOrderGroupByOutputType = {
    id: string
    shopifyOrderId: string
    orderNumber: string | null
    email: string | null
    phone: string | null
    name: string | null
    financialStatus: string | null
    fulfillmentStatus: string | null
    tags: string | null
    totalPrice: number | null
    totalTax: number | null
    totalDiscounts: number | null
    totalWeight: number | null
    currency: string
    processedAt: Date | null
    closedAt: Date | null
    cancelledAt: Date | null
    test: boolean
    createdAt: Date
    updatedAt: Date
    _count: ShopifyOrderCountAggregateOutputType | null
    _avg: ShopifyOrderAvgAggregateOutputType | null
    _sum: ShopifyOrderSumAggregateOutputType | null
    _min: ShopifyOrderMinAggregateOutputType | null
    _max: ShopifyOrderMaxAggregateOutputType | null
  }

  type GetShopifyOrderGroupByPayload<T extends ShopifyOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopifyOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopifyOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopifyOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ShopifyOrderGroupByOutputType[P]>
        }
      >
    >


  export type ShopifyOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyOrderId?: boolean
    orderNumber?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    financialStatus?: boolean
    fulfillmentStatus?: boolean
    tags?: boolean
    totalPrice?: boolean
    totalTax?: boolean
    totalDiscounts?: boolean
    totalWeight?: boolean
    currency?: boolean
    processedAt?: boolean
    closedAt?: boolean
    cancelledAt?: boolean
    test?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lineItems?: boolean | ShopifyOrder$lineItemsArgs<ExtArgs>
    _count?: boolean | ShopifyOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopifyOrder"]>

  export type ShopifyOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyOrderId?: boolean
    orderNumber?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    financialStatus?: boolean
    fulfillmentStatus?: boolean
    tags?: boolean
    totalPrice?: boolean
    totalTax?: boolean
    totalDiscounts?: boolean
    totalWeight?: boolean
    currency?: boolean
    processedAt?: boolean
    closedAt?: boolean
    cancelledAt?: boolean
    test?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shopifyOrder"]>

  export type ShopifyOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyOrderId?: boolean
    orderNumber?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    financialStatus?: boolean
    fulfillmentStatus?: boolean
    tags?: boolean
    totalPrice?: boolean
    totalTax?: boolean
    totalDiscounts?: boolean
    totalWeight?: boolean
    currency?: boolean
    processedAt?: boolean
    closedAt?: boolean
    cancelledAt?: boolean
    test?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shopifyOrder"]>

  export type ShopifyOrderSelectScalar = {
    id?: boolean
    shopifyOrderId?: boolean
    orderNumber?: boolean
    email?: boolean
    phone?: boolean
    name?: boolean
    financialStatus?: boolean
    fulfillmentStatus?: boolean
    tags?: boolean
    totalPrice?: boolean
    totalTax?: boolean
    totalDiscounts?: boolean
    totalWeight?: boolean
    currency?: boolean
    processedAt?: boolean
    closedAt?: boolean
    cancelledAt?: boolean
    test?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopifyOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyOrderId" | "orderNumber" | "email" | "phone" | "name" | "financialStatus" | "fulfillmentStatus" | "tags" | "totalPrice" | "totalTax" | "totalDiscounts" | "totalWeight" | "currency" | "processedAt" | "closedAt" | "cancelledAt" | "test" | "createdAt" | "updatedAt", ExtArgs["result"]["shopifyOrder"]>
  export type ShopifyOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | ShopifyOrder$lineItemsArgs<ExtArgs>
    _count?: boolean | ShopifyOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopifyOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ShopifyOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ShopifyOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopifyOrder"
    objects: {
      lineItems: Prisma.$ShopifyLineItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyOrderId: string
      orderNumber: string | null
      email: string | null
      phone: string | null
      name: string | null
      financialStatus: string | null
      fulfillmentStatus: string | null
      tags: string | null
      totalPrice: number | null
      totalTax: number | null
      totalDiscounts: number | null
      totalWeight: number | null
      currency: string
      processedAt: Date | null
      closedAt: Date | null
      cancelledAt: Date | null
      test: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopifyOrder"]>
    composites: {}
  }

  type ShopifyOrderGetPayload<S extends boolean | null | undefined | ShopifyOrderDefaultArgs> = $Result.GetResult<Prisma.$ShopifyOrderPayload, S>

  type ShopifyOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopifyOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopifyOrderCountAggregateInputType | true
    }

  export interface ShopifyOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopifyOrder'], meta: { name: 'ShopifyOrder' } }
    /**
     * Find zero or one ShopifyOrder that matches the filter.
     * @param {ShopifyOrderFindUniqueArgs} args - Arguments to find a ShopifyOrder
     * @example
     * // Get one ShopifyOrder
     * const shopifyOrder = await prisma.shopifyOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopifyOrderFindUniqueArgs>(args: SelectSubset<T, ShopifyOrderFindUniqueArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopifyOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopifyOrderFindUniqueOrThrowArgs} args - Arguments to find a ShopifyOrder
     * @example
     * // Get one ShopifyOrder
     * const shopifyOrder = await prisma.shopifyOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopifyOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopifyOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopifyOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyOrderFindFirstArgs} args - Arguments to find a ShopifyOrder
     * @example
     * // Get one ShopifyOrder
     * const shopifyOrder = await prisma.shopifyOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopifyOrderFindFirstArgs>(args?: SelectSubset<T, ShopifyOrderFindFirstArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopifyOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyOrderFindFirstOrThrowArgs} args - Arguments to find a ShopifyOrder
     * @example
     * // Get one ShopifyOrder
     * const shopifyOrder = await prisma.shopifyOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopifyOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopifyOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopifyOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopifyOrders
     * const shopifyOrders = await prisma.shopifyOrder.findMany()
     * 
     * // Get first 10 ShopifyOrders
     * const shopifyOrders = await prisma.shopifyOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopifyOrderWithIdOnly = await prisma.shopifyOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopifyOrderFindManyArgs>(args?: SelectSubset<T, ShopifyOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopifyOrder.
     * @param {ShopifyOrderCreateArgs} args - Arguments to create a ShopifyOrder.
     * @example
     * // Create one ShopifyOrder
     * const ShopifyOrder = await prisma.shopifyOrder.create({
     *   data: {
     *     // ... data to create a ShopifyOrder
     *   }
     * })
     * 
     */
    create<T extends ShopifyOrderCreateArgs>(args: SelectSubset<T, ShopifyOrderCreateArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopifyOrders.
     * @param {ShopifyOrderCreateManyArgs} args - Arguments to create many ShopifyOrders.
     * @example
     * // Create many ShopifyOrders
     * const shopifyOrder = await prisma.shopifyOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopifyOrderCreateManyArgs>(args?: SelectSubset<T, ShopifyOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopifyOrders and returns the data saved in the database.
     * @param {ShopifyOrderCreateManyAndReturnArgs} args - Arguments to create many ShopifyOrders.
     * @example
     * // Create many ShopifyOrders
     * const shopifyOrder = await prisma.shopifyOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopifyOrders and only return the `id`
     * const shopifyOrderWithIdOnly = await prisma.shopifyOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopifyOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopifyOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShopifyOrder.
     * @param {ShopifyOrderDeleteArgs} args - Arguments to delete one ShopifyOrder.
     * @example
     * // Delete one ShopifyOrder
     * const ShopifyOrder = await prisma.shopifyOrder.delete({
     *   where: {
     *     // ... filter to delete one ShopifyOrder
     *   }
     * })
     * 
     */
    delete<T extends ShopifyOrderDeleteArgs>(args: SelectSubset<T, ShopifyOrderDeleteArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopifyOrder.
     * @param {ShopifyOrderUpdateArgs} args - Arguments to update one ShopifyOrder.
     * @example
     * // Update one ShopifyOrder
     * const shopifyOrder = await prisma.shopifyOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopifyOrderUpdateArgs>(args: SelectSubset<T, ShopifyOrderUpdateArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopifyOrders.
     * @param {ShopifyOrderDeleteManyArgs} args - Arguments to filter ShopifyOrders to delete.
     * @example
     * // Delete a few ShopifyOrders
     * const { count } = await prisma.shopifyOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopifyOrderDeleteManyArgs>(args?: SelectSubset<T, ShopifyOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopifyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopifyOrders
     * const shopifyOrder = await prisma.shopifyOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopifyOrderUpdateManyArgs>(args: SelectSubset<T, ShopifyOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopifyOrders and returns the data updated in the database.
     * @param {ShopifyOrderUpdateManyAndReturnArgs} args - Arguments to update many ShopifyOrders.
     * @example
     * // Update many ShopifyOrders
     * const shopifyOrder = await prisma.shopifyOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShopifyOrders and only return the `id`
     * const shopifyOrderWithIdOnly = await prisma.shopifyOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopifyOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopifyOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShopifyOrder.
     * @param {ShopifyOrderUpsertArgs} args - Arguments to update or create a ShopifyOrder.
     * @example
     * // Update or create a ShopifyOrder
     * const shopifyOrder = await prisma.shopifyOrder.upsert({
     *   create: {
     *     // ... data to create a ShopifyOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopifyOrder we want to update
     *   }
     * })
     */
    upsert<T extends ShopifyOrderUpsertArgs>(args: SelectSubset<T, ShopifyOrderUpsertArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopifyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyOrderCountArgs} args - Arguments to filter ShopifyOrders to count.
     * @example
     * // Count the number of ShopifyOrders
     * const count = await prisma.shopifyOrder.count({
     *   where: {
     *     // ... the filter for the ShopifyOrders we want to count
     *   }
     * })
    **/
    count<T extends ShopifyOrderCountArgs>(
      args?: Subset<T, ShopifyOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopifyOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopifyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopifyOrderAggregateArgs>(args: Subset<T, ShopifyOrderAggregateArgs>): Prisma.PrismaPromise<GetShopifyOrderAggregateType<T>>

    /**
     * Group by ShopifyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopifyOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopifyOrderGroupByArgs['orderBy'] }
        : { orderBy?: ShopifyOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopifyOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopifyOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopifyOrder model
   */
  readonly fields: ShopifyOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopifyOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopifyOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineItems<T extends ShopifyOrder$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, ShopifyOrder$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopifyOrder model
   */
  interface ShopifyOrderFieldRefs {
    readonly id: FieldRef<"ShopifyOrder", 'String'>
    readonly shopifyOrderId: FieldRef<"ShopifyOrder", 'String'>
    readonly orderNumber: FieldRef<"ShopifyOrder", 'String'>
    readonly email: FieldRef<"ShopifyOrder", 'String'>
    readonly phone: FieldRef<"ShopifyOrder", 'String'>
    readonly name: FieldRef<"ShopifyOrder", 'String'>
    readonly financialStatus: FieldRef<"ShopifyOrder", 'String'>
    readonly fulfillmentStatus: FieldRef<"ShopifyOrder", 'String'>
    readonly tags: FieldRef<"ShopifyOrder", 'String'>
    readonly totalPrice: FieldRef<"ShopifyOrder", 'Float'>
    readonly totalTax: FieldRef<"ShopifyOrder", 'Float'>
    readonly totalDiscounts: FieldRef<"ShopifyOrder", 'Float'>
    readonly totalWeight: FieldRef<"ShopifyOrder", 'Float'>
    readonly currency: FieldRef<"ShopifyOrder", 'String'>
    readonly processedAt: FieldRef<"ShopifyOrder", 'DateTime'>
    readonly closedAt: FieldRef<"ShopifyOrder", 'DateTime'>
    readonly cancelledAt: FieldRef<"ShopifyOrder", 'DateTime'>
    readonly test: FieldRef<"ShopifyOrder", 'Boolean'>
    readonly createdAt: FieldRef<"ShopifyOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopifyOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopifyOrder findUnique
   */
  export type ShopifyOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyOrder to fetch.
     */
    where: ShopifyOrderWhereUniqueInput
  }

  /**
   * ShopifyOrder findUniqueOrThrow
   */
  export type ShopifyOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyOrder to fetch.
     */
    where: ShopifyOrderWhereUniqueInput
  }

  /**
   * ShopifyOrder findFirst
   */
  export type ShopifyOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyOrder to fetch.
     */
    where?: ShopifyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyOrders to fetch.
     */
    orderBy?: ShopifyOrderOrderByWithRelationInput | ShopifyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopifyOrders.
     */
    cursor?: ShopifyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopifyOrders.
     */
    distinct?: ShopifyOrderScalarFieldEnum | ShopifyOrderScalarFieldEnum[]
  }

  /**
   * ShopifyOrder findFirstOrThrow
   */
  export type ShopifyOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyOrder to fetch.
     */
    where?: ShopifyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyOrders to fetch.
     */
    orderBy?: ShopifyOrderOrderByWithRelationInput | ShopifyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopifyOrders.
     */
    cursor?: ShopifyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopifyOrders.
     */
    distinct?: ShopifyOrderScalarFieldEnum | ShopifyOrderScalarFieldEnum[]
  }

  /**
   * ShopifyOrder findMany
   */
  export type ShopifyOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyOrders to fetch.
     */
    where?: ShopifyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyOrders to fetch.
     */
    orderBy?: ShopifyOrderOrderByWithRelationInput | ShopifyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopifyOrders.
     */
    cursor?: ShopifyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyOrders.
     */
    skip?: number
    distinct?: ShopifyOrderScalarFieldEnum | ShopifyOrderScalarFieldEnum[]
  }

  /**
   * ShopifyOrder create
   */
  export type ShopifyOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopifyOrder.
     */
    data: XOR<ShopifyOrderCreateInput, ShopifyOrderUncheckedCreateInput>
  }

  /**
   * ShopifyOrder createMany
   */
  export type ShopifyOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopifyOrders.
     */
    data: ShopifyOrderCreateManyInput | ShopifyOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopifyOrder createManyAndReturn
   */
  export type ShopifyOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ShopifyOrders.
     */
    data: ShopifyOrderCreateManyInput | ShopifyOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopifyOrder update
   */
  export type ShopifyOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopifyOrder.
     */
    data: XOR<ShopifyOrderUpdateInput, ShopifyOrderUncheckedUpdateInput>
    /**
     * Choose, which ShopifyOrder to update.
     */
    where: ShopifyOrderWhereUniqueInput
  }

  /**
   * ShopifyOrder updateMany
   */
  export type ShopifyOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopifyOrders.
     */
    data: XOR<ShopifyOrderUpdateManyMutationInput, ShopifyOrderUncheckedUpdateManyInput>
    /**
     * Filter which ShopifyOrders to update
     */
    where?: ShopifyOrderWhereInput
    /**
     * Limit how many ShopifyOrders to update.
     */
    limit?: number
  }

  /**
   * ShopifyOrder updateManyAndReturn
   */
  export type ShopifyOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * The data used to update ShopifyOrders.
     */
    data: XOR<ShopifyOrderUpdateManyMutationInput, ShopifyOrderUncheckedUpdateManyInput>
    /**
     * Filter which ShopifyOrders to update
     */
    where?: ShopifyOrderWhereInput
    /**
     * Limit how many ShopifyOrders to update.
     */
    limit?: number
  }

  /**
   * ShopifyOrder upsert
   */
  export type ShopifyOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopifyOrder to update in case it exists.
     */
    where: ShopifyOrderWhereUniqueInput
    /**
     * In case the ShopifyOrder found by the `where` argument doesn't exist, create a new ShopifyOrder with this data.
     */
    create: XOR<ShopifyOrderCreateInput, ShopifyOrderUncheckedCreateInput>
    /**
     * In case the ShopifyOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopifyOrderUpdateInput, ShopifyOrderUncheckedUpdateInput>
  }

  /**
   * ShopifyOrder delete
   */
  export type ShopifyOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
    /**
     * Filter which ShopifyOrder to delete.
     */
    where: ShopifyOrderWhereUniqueInput
  }

  /**
   * ShopifyOrder deleteMany
   */
  export type ShopifyOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopifyOrders to delete
     */
    where?: ShopifyOrderWhereInput
    /**
     * Limit how many ShopifyOrders to delete.
     */
    limit?: number
  }

  /**
   * ShopifyOrder.lineItems
   */
  export type ShopifyOrder$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    where?: ShopifyLineItemWhereInput
    orderBy?: ShopifyLineItemOrderByWithRelationInput | ShopifyLineItemOrderByWithRelationInput[]
    cursor?: ShopifyLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopifyLineItemScalarFieldEnum | ShopifyLineItemScalarFieldEnum[]
  }

  /**
   * ShopifyOrder without action
   */
  export type ShopifyOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyOrder
     */
    select?: ShopifyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyOrder
     */
    omit?: ShopifyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyOrderInclude<ExtArgs> | null
  }


  /**
   * Model ShopifyLineItem
   */

  export type AggregateShopifyLineItem = {
    _count: ShopifyLineItemCountAggregateOutputType | null
    _avg: ShopifyLineItemAvgAggregateOutputType | null
    _sum: ShopifyLineItemSumAggregateOutputType | null
    _min: ShopifyLineItemMinAggregateOutputType | null
    _max: ShopifyLineItemMaxAggregateOutputType | null
  }

  export type ShopifyLineItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
    totalDiscount: number | null
    grams: number | null
  }

  export type ShopifyLineItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
    totalDiscount: number | null
    grams: number | null
  }

  export type ShopifyLineItemMinAggregateOutputType = {
    id: string | null
    lineItemId: string | null
    shopifyOrderId: string | null
    productId: string | null
    variantId: string | null
    title: string | null
    variantTitle: string | null
    sku: string | null
    vendor: string | null
    quantity: number | null
    price: number | null
    totalDiscount: number | null
    grams: number | null
    requiresShipping: boolean | null
    taxable: boolean | null
    fulfillmentService: string | null
    fulfillmentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopifyLineItemMaxAggregateOutputType = {
    id: string | null
    lineItemId: string | null
    shopifyOrderId: string | null
    productId: string | null
    variantId: string | null
    title: string | null
    variantTitle: string | null
    sku: string | null
    vendor: string | null
    quantity: number | null
    price: number | null
    totalDiscount: number | null
    grams: number | null
    requiresShipping: boolean | null
    taxable: boolean | null
    fulfillmentService: string | null
    fulfillmentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopifyLineItemCountAggregateOutputType = {
    id: number
    lineItemId: number
    shopifyOrderId: number
    productId: number
    variantId: number
    title: number
    variantTitle: number
    sku: number
    vendor: number
    quantity: number
    price: number
    totalDiscount: number
    grams: number
    requiresShipping: number
    taxable: number
    fulfillmentService: number
    fulfillmentStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopifyLineItemAvgAggregateInputType = {
    quantity?: true
    price?: true
    totalDiscount?: true
    grams?: true
  }

  export type ShopifyLineItemSumAggregateInputType = {
    quantity?: true
    price?: true
    totalDiscount?: true
    grams?: true
  }

  export type ShopifyLineItemMinAggregateInputType = {
    id?: true
    lineItemId?: true
    shopifyOrderId?: true
    productId?: true
    variantId?: true
    title?: true
    variantTitle?: true
    sku?: true
    vendor?: true
    quantity?: true
    price?: true
    totalDiscount?: true
    grams?: true
    requiresShipping?: true
    taxable?: true
    fulfillmentService?: true
    fulfillmentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopifyLineItemMaxAggregateInputType = {
    id?: true
    lineItemId?: true
    shopifyOrderId?: true
    productId?: true
    variantId?: true
    title?: true
    variantTitle?: true
    sku?: true
    vendor?: true
    quantity?: true
    price?: true
    totalDiscount?: true
    grams?: true
    requiresShipping?: true
    taxable?: true
    fulfillmentService?: true
    fulfillmentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopifyLineItemCountAggregateInputType = {
    id?: true
    lineItemId?: true
    shopifyOrderId?: true
    productId?: true
    variantId?: true
    title?: true
    variantTitle?: true
    sku?: true
    vendor?: true
    quantity?: true
    price?: true
    totalDiscount?: true
    grams?: true
    requiresShipping?: true
    taxable?: true
    fulfillmentService?: true
    fulfillmentStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopifyLineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopifyLineItem to aggregate.
     */
    where?: ShopifyLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyLineItems to fetch.
     */
    orderBy?: ShopifyLineItemOrderByWithRelationInput | ShopifyLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopifyLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopifyLineItems
    **/
    _count?: true | ShopifyLineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopifyLineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopifyLineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopifyLineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopifyLineItemMaxAggregateInputType
  }

  export type GetShopifyLineItemAggregateType<T extends ShopifyLineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateShopifyLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopifyLineItem[P]>
      : GetScalarType<T[P], AggregateShopifyLineItem[P]>
  }




  export type ShopifyLineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopifyLineItemWhereInput
    orderBy?: ShopifyLineItemOrderByWithAggregationInput | ShopifyLineItemOrderByWithAggregationInput[]
    by: ShopifyLineItemScalarFieldEnum[] | ShopifyLineItemScalarFieldEnum
    having?: ShopifyLineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopifyLineItemCountAggregateInputType | true
    _avg?: ShopifyLineItemAvgAggregateInputType
    _sum?: ShopifyLineItemSumAggregateInputType
    _min?: ShopifyLineItemMinAggregateInputType
    _max?: ShopifyLineItemMaxAggregateInputType
  }

  export type ShopifyLineItemGroupByOutputType = {
    id: string
    lineItemId: string
    shopifyOrderId: string
    productId: string | null
    variantId: string | null
    title: string | null
    variantTitle: string | null
    sku: string | null
    vendor: string | null
    quantity: number
    price: number | null
    totalDiscount: number | null
    grams: number | null
    requiresShipping: boolean
    taxable: boolean
    fulfillmentService: string | null
    fulfillmentStatus: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShopifyLineItemCountAggregateOutputType | null
    _avg: ShopifyLineItemAvgAggregateOutputType | null
    _sum: ShopifyLineItemSumAggregateOutputType | null
    _min: ShopifyLineItemMinAggregateOutputType | null
    _max: ShopifyLineItemMaxAggregateOutputType | null
  }

  type GetShopifyLineItemGroupByPayload<T extends ShopifyLineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopifyLineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopifyLineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopifyLineItemGroupByOutputType[P]>
            : GetScalarType<T[P], ShopifyLineItemGroupByOutputType[P]>
        }
      >
    >


  export type ShopifyLineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineItemId?: boolean
    shopifyOrderId?: boolean
    productId?: boolean
    variantId?: boolean
    title?: boolean
    variantTitle?: boolean
    sku?: boolean
    vendor?: boolean
    quantity?: boolean
    price?: boolean
    totalDiscount?: boolean
    grams?: boolean
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: boolean
    fulfillmentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | ShopifyOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopifyLineItem"]>

  export type ShopifyLineItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineItemId?: boolean
    shopifyOrderId?: boolean
    productId?: boolean
    variantId?: boolean
    title?: boolean
    variantTitle?: boolean
    sku?: boolean
    vendor?: boolean
    quantity?: boolean
    price?: boolean
    totalDiscount?: boolean
    grams?: boolean
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: boolean
    fulfillmentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | ShopifyOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopifyLineItem"]>

  export type ShopifyLineItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineItemId?: boolean
    shopifyOrderId?: boolean
    productId?: boolean
    variantId?: boolean
    title?: boolean
    variantTitle?: boolean
    sku?: boolean
    vendor?: boolean
    quantity?: boolean
    price?: boolean
    totalDiscount?: boolean
    grams?: boolean
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: boolean
    fulfillmentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | ShopifyOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopifyLineItem"]>

  export type ShopifyLineItemSelectScalar = {
    id?: boolean
    lineItemId?: boolean
    shopifyOrderId?: boolean
    productId?: boolean
    variantId?: boolean
    title?: boolean
    variantTitle?: boolean
    sku?: boolean
    vendor?: boolean
    quantity?: boolean
    price?: boolean
    totalDiscount?: boolean
    grams?: boolean
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: boolean
    fulfillmentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopifyLineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lineItemId" | "shopifyOrderId" | "productId" | "variantId" | "title" | "variantTitle" | "sku" | "vendor" | "quantity" | "price" | "totalDiscount" | "grams" | "requiresShipping" | "taxable" | "fulfillmentService" | "fulfillmentStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["shopifyLineItem"]>
  export type ShopifyLineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ShopifyOrderDefaultArgs<ExtArgs>
  }
  export type ShopifyLineItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ShopifyOrderDefaultArgs<ExtArgs>
  }
  export type ShopifyLineItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ShopifyOrderDefaultArgs<ExtArgs>
  }

  export type $ShopifyLineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopifyLineItem"
    objects: {
      order: Prisma.$ShopifyOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lineItemId: string
      shopifyOrderId: string
      productId: string | null
      variantId: string | null
      title: string | null
      variantTitle: string | null
      sku: string | null
      vendor: string | null
      quantity: number
      price: number | null
      totalDiscount: number | null
      grams: number | null
      requiresShipping: boolean
      taxable: boolean
      fulfillmentService: string | null
      fulfillmentStatus: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopifyLineItem"]>
    composites: {}
  }

  type ShopifyLineItemGetPayload<S extends boolean | null | undefined | ShopifyLineItemDefaultArgs> = $Result.GetResult<Prisma.$ShopifyLineItemPayload, S>

  type ShopifyLineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopifyLineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopifyLineItemCountAggregateInputType | true
    }

  export interface ShopifyLineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopifyLineItem'], meta: { name: 'ShopifyLineItem' } }
    /**
     * Find zero or one ShopifyLineItem that matches the filter.
     * @param {ShopifyLineItemFindUniqueArgs} args - Arguments to find a ShopifyLineItem
     * @example
     * // Get one ShopifyLineItem
     * const shopifyLineItem = await prisma.shopifyLineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopifyLineItemFindUniqueArgs>(args: SelectSubset<T, ShopifyLineItemFindUniqueArgs<ExtArgs>>): Prisma__ShopifyLineItemClient<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopifyLineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopifyLineItemFindUniqueOrThrowArgs} args - Arguments to find a ShopifyLineItem
     * @example
     * // Get one ShopifyLineItem
     * const shopifyLineItem = await prisma.shopifyLineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopifyLineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopifyLineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopifyLineItemClient<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopifyLineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyLineItemFindFirstArgs} args - Arguments to find a ShopifyLineItem
     * @example
     * // Get one ShopifyLineItem
     * const shopifyLineItem = await prisma.shopifyLineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopifyLineItemFindFirstArgs>(args?: SelectSubset<T, ShopifyLineItemFindFirstArgs<ExtArgs>>): Prisma__ShopifyLineItemClient<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopifyLineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyLineItemFindFirstOrThrowArgs} args - Arguments to find a ShopifyLineItem
     * @example
     * // Get one ShopifyLineItem
     * const shopifyLineItem = await prisma.shopifyLineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopifyLineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopifyLineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopifyLineItemClient<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopifyLineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyLineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopifyLineItems
     * const shopifyLineItems = await prisma.shopifyLineItem.findMany()
     * 
     * // Get first 10 ShopifyLineItems
     * const shopifyLineItems = await prisma.shopifyLineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopifyLineItemWithIdOnly = await prisma.shopifyLineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopifyLineItemFindManyArgs>(args?: SelectSubset<T, ShopifyLineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopifyLineItem.
     * @param {ShopifyLineItemCreateArgs} args - Arguments to create a ShopifyLineItem.
     * @example
     * // Create one ShopifyLineItem
     * const ShopifyLineItem = await prisma.shopifyLineItem.create({
     *   data: {
     *     // ... data to create a ShopifyLineItem
     *   }
     * })
     * 
     */
    create<T extends ShopifyLineItemCreateArgs>(args: SelectSubset<T, ShopifyLineItemCreateArgs<ExtArgs>>): Prisma__ShopifyLineItemClient<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopifyLineItems.
     * @param {ShopifyLineItemCreateManyArgs} args - Arguments to create many ShopifyLineItems.
     * @example
     * // Create many ShopifyLineItems
     * const shopifyLineItem = await prisma.shopifyLineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopifyLineItemCreateManyArgs>(args?: SelectSubset<T, ShopifyLineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopifyLineItems and returns the data saved in the database.
     * @param {ShopifyLineItemCreateManyAndReturnArgs} args - Arguments to create many ShopifyLineItems.
     * @example
     * // Create many ShopifyLineItems
     * const shopifyLineItem = await prisma.shopifyLineItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopifyLineItems and only return the `id`
     * const shopifyLineItemWithIdOnly = await prisma.shopifyLineItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopifyLineItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopifyLineItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShopifyLineItem.
     * @param {ShopifyLineItemDeleteArgs} args - Arguments to delete one ShopifyLineItem.
     * @example
     * // Delete one ShopifyLineItem
     * const ShopifyLineItem = await prisma.shopifyLineItem.delete({
     *   where: {
     *     // ... filter to delete one ShopifyLineItem
     *   }
     * })
     * 
     */
    delete<T extends ShopifyLineItemDeleteArgs>(args: SelectSubset<T, ShopifyLineItemDeleteArgs<ExtArgs>>): Prisma__ShopifyLineItemClient<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopifyLineItem.
     * @param {ShopifyLineItemUpdateArgs} args - Arguments to update one ShopifyLineItem.
     * @example
     * // Update one ShopifyLineItem
     * const shopifyLineItem = await prisma.shopifyLineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopifyLineItemUpdateArgs>(args: SelectSubset<T, ShopifyLineItemUpdateArgs<ExtArgs>>): Prisma__ShopifyLineItemClient<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopifyLineItems.
     * @param {ShopifyLineItemDeleteManyArgs} args - Arguments to filter ShopifyLineItems to delete.
     * @example
     * // Delete a few ShopifyLineItems
     * const { count } = await prisma.shopifyLineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopifyLineItemDeleteManyArgs>(args?: SelectSubset<T, ShopifyLineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopifyLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyLineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopifyLineItems
     * const shopifyLineItem = await prisma.shopifyLineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopifyLineItemUpdateManyArgs>(args: SelectSubset<T, ShopifyLineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopifyLineItems and returns the data updated in the database.
     * @param {ShopifyLineItemUpdateManyAndReturnArgs} args - Arguments to update many ShopifyLineItems.
     * @example
     * // Update many ShopifyLineItems
     * const shopifyLineItem = await prisma.shopifyLineItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShopifyLineItems and only return the `id`
     * const shopifyLineItemWithIdOnly = await prisma.shopifyLineItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopifyLineItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopifyLineItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShopifyLineItem.
     * @param {ShopifyLineItemUpsertArgs} args - Arguments to update or create a ShopifyLineItem.
     * @example
     * // Update or create a ShopifyLineItem
     * const shopifyLineItem = await prisma.shopifyLineItem.upsert({
     *   create: {
     *     // ... data to create a ShopifyLineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopifyLineItem we want to update
     *   }
     * })
     */
    upsert<T extends ShopifyLineItemUpsertArgs>(args: SelectSubset<T, ShopifyLineItemUpsertArgs<ExtArgs>>): Prisma__ShopifyLineItemClient<$Result.GetResult<Prisma.$ShopifyLineItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopifyLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyLineItemCountArgs} args - Arguments to filter ShopifyLineItems to count.
     * @example
     * // Count the number of ShopifyLineItems
     * const count = await prisma.shopifyLineItem.count({
     *   where: {
     *     // ... the filter for the ShopifyLineItems we want to count
     *   }
     * })
    **/
    count<T extends ShopifyLineItemCountArgs>(
      args?: Subset<T, ShopifyLineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopifyLineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopifyLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyLineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopifyLineItemAggregateArgs>(args: Subset<T, ShopifyLineItemAggregateArgs>): Prisma.PrismaPromise<GetShopifyLineItemAggregateType<T>>

    /**
     * Group by ShopifyLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyLineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopifyLineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopifyLineItemGroupByArgs['orderBy'] }
        : { orderBy?: ShopifyLineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopifyLineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopifyLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopifyLineItem model
   */
  readonly fields: ShopifyLineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopifyLineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopifyLineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends ShopifyOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopifyOrderDefaultArgs<ExtArgs>>): Prisma__ShopifyOrderClient<$Result.GetResult<Prisma.$ShopifyOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopifyLineItem model
   */
  interface ShopifyLineItemFieldRefs {
    readonly id: FieldRef<"ShopifyLineItem", 'String'>
    readonly lineItemId: FieldRef<"ShopifyLineItem", 'String'>
    readonly shopifyOrderId: FieldRef<"ShopifyLineItem", 'String'>
    readonly productId: FieldRef<"ShopifyLineItem", 'String'>
    readonly variantId: FieldRef<"ShopifyLineItem", 'String'>
    readonly title: FieldRef<"ShopifyLineItem", 'String'>
    readonly variantTitle: FieldRef<"ShopifyLineItem", 'String'>
    readonly sku: FieldRef<"ShopifyLineItem", 'String'>
    readonly vendor: FieldRef<"ShopifyLineItem", 'String'>
    readonly quantity: FieldRef<"ShopifyLineItem", 'Int'>
    readonly price: FieldRef<"ShopifyLineItem", 'Float'>
    readonly totalDiscount: FieldRef<"ShopifyLineItem", 'Float'>
    readonly grams: FieldRef<"ShopifyLineItem", 'Float'>
    readonly requiresShipping: FieldRef<"ShopifyLineItem", 'Boolean'>
    readonly taxable: FieldRef<"ShopifyLineItem", 'Boolean'>
    readonly fulfillmentService: FieldRef<"ShopifyLineItem", 'String'>
    readonly fulfillmentStatus: FieldRef<"ShopifyLineItem", 'String'>
    readonly createdAt: FieldRef<"ShopifyLineItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopifyLineItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopifyLineItem findUnique
   */
  export type ShopifyLineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyLineItem to fetch.
     */
    where: ShopifyLineItemWhereUniqueInput
  }

  /**
   * ShopifyLineItem findUniqueOrThrow
   */
  export type ShopifyLineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyLineItem to fetch.
     */
    where: ShopifyLineItemWhereUniqueInput
  }

  /**
   * ShopifyLineItem findFirst
   */
  export type ShopifyLineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyLineItem to fetch.
     */
    where?: ShopifyLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyLineItems to fetch.
     */
    orderBy?: ShopifyLineItemOrderByWithRelationInput | ShopifyLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopifyLineItems.
     */
    cursor?: ShopifyLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopifyLineItems.
     */
    distinct?: ShopifyLineItemScalarFieldEnum | ShopifyLineItemScalarFieldEnum[]
  }

  /**
   * ShopifyLineItem findFirstOrThrow
   */
  export type ShopifyLineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyLineItem to fetch.
     */
    where?: ShopifyLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyLineItems to fetch.
     */
    orderBy?: ShopifyLineItemOrderByWithRelationInput | ShopifyLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopifyLineItems.
     */
    cursor?: ShopifyLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopifyLineItems.
     */
    distinct?: ShopifyLineItemScalarFieldEnum | ShopifyLineItemScalarFieldEnum[]
  }

  /**
   * ShopifyLineItem findMany
   */
  export type ShopifyLineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyLineItems to fetch.
     */
    where?: ShopifyLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyLineItems to fetch.
     */
    orderBy?: ShopifyLineItemOrderByWithRelationInput | ShopifyLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopifyLineItems.
     */
    cursor?: ShopifyLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyLineItems.
     */
    skip?: number
    distinct?: ShopifyLineItemScalarFieldEnum | ShopifyLineItemScalarFieldEnum[]
  }

  /**
   * ShopifyLineItem create
   */
  export type ShopifyLineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopifyLineItem.
     */
    data: XOR<ShopifyLineItemCreateInput, ShopifyLineItemUncheckedCreateInput>
  }

  /**
   * ShopifyLineItem createMany
   */
  export type ShopifyLineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopifyLineItems.
     */
    data: ShopifyLineItemCreateManyInput | ShopifyLineItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopifyLineItem createManyAndReturn
   */
  export type ShopifyLineItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * The data used to create many ShopifyLineItems.
     */
    data: ShopifyLineItemCreateManyInput | ShopifyLineItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopifyLineItem update
   */
  export type ShopifyLineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopifyLineItem.
     */
    data: XOR<ShopifyLineItemUpdateInput, ShopifyLineItemUncheckedUpdateInput>
    /**
     * Choose, which ShopifyLineItem to update.
     */
    where: ShopifyLineItemWhereUniqueInput
  }

  /**
   * ShopifyLineItem updateMany
   */
  export type ShopifyLineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopifyLineItems.
     */
    data: XOR<ShopifyLineItemUpdateManyMutationInput, ShopifyLineItemUncheckedUpdateManyInput>
    /**
     * Filter which ShopifyLineItems to update
     */
    where?: ShopifyLineItemWhereInput
    /**
     * Limit how many ShopifyLineItems to update.
     */
    limit?: number
  }

  /**
   * ShopifyLineItem updateManyAndReturn
   */
  export type ShopifyLineItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * The data used to update ShopifyLineItems.
     */
    data: XOR<ShopifyLineItemUpdateManyMutationInput, ShopifyLineItemUncheckedUpdateManyInput>
    /**
     * Filter which ShopifyLineItems to update
     */
    where?: ShopifyLineItemWhereInput
    /**
     * Limit how many ShopifyLineItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopifyLineItem upsert
   */
  export type ShopifyLineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopifyLineItem to update in case it exists.
     */
    where: ShopifyLineItemWhereUniqueInput
    /**
     * In case the ShopifyLineItem found by the `where` argument doesn't exist, create a new ShopifyLineItem with this data.
     */
    create: XOR<ShopifyLineItemCreateInput, ShopifyLineItemUncheckedCreateInput>
    /**
     * In case the ShopifyLineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopifyLineItemUpdateInput, ShopifyLineItemUncheckedUpdateInput>
  }

  /**
   * ShopifyLineItem delete
   */
  export type ShopifyLineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
    /**
     * Filter which ShopifyLineItem to delete.
     */
    where: ShopifyLineItemWhereUniqueInput
  }

  /**
   * ShopifyLineItem deleteMany
   */
  export type ShopifyLineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopifyLineItems to delete
     */
    where?: ShopifyLineItemWhereInput
    /**
     * Limit how many ShopifyLineItems to delete.
     */
    limit?: number
  }

  /**
   * ShopifyLineItem without action
   */
  export type ShopifyLineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyLineItem
     */
    select?: ShopifyLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyLineItem
     */
    omit?: ShopifyLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyLineItemInclude<ExtArgs> | null
  }


  /**
   * Model ShopifyProduct
   */

  export type AggregateShopifyProduct = {
    _count: ShopifyProductCountAggregateOutputType | null
    _min: ShopifyProductMinAggregateOutputType | null
    _max: ShopifyProductMaxAggregateOutputType | null
  }

  export type ShopifyProductMinAggregateOutputType = {
    id: string | null
    shopifyProductId: string | null
    title: string | null
    handle: string | null
    vendor: string | null
    productType: string | null
    tags: string | null
    status: string | null
    description: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopifyProductMaxAggregateOutputType = {
    id: string | null
    shopifyProductId: string | null
    title: string | null
    handle: string | null
    vendor: string | null
    productType: string | null
    tags: string | null
    status: string | null
    description: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopifyProductCountAggregateOutputType = {
    id: number
    shopifyProductId: number
    title: number
    handle: number
    vendor: number
    productType: number
    tags: number
    status: number
    description: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopifyProductMinAggregateInputType = {
    id?: true
    shopifyProductId?: true
    title?: true
    handle?: true
    vendor?: true
    productType?: true
    tags?: true
    status?: true
    description?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopifyProductMaxAggregateInputType = {
    id?: true
    shopifyProductId?: true
    title?: true
    handle?: true
    vendor?: true
    productType?: true
    tags?: true
    status?: true
    description?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopifyProductCountAggregateInputType = {
    id?: true
    shopifyProductId?: true
    title?: true
    handle?: true
    vendor?: true
    productType?: true
    tags?: true
    status?: true
    description?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopifyProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopifyProduct to aggregate.
     */
    where?: ShopifyProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyProducts to fetch.
     */
    orderBy?: ShopifyProductOrderByWithRelationInput | ShopifyProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopifyProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopifyProducts
    **/
    _count?: true | ShopifyProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopifyProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopifyProductMaxAggregateInputType
  }

  export type GetShopifyProductAggregateType<T extends ShopifyProductAggregateArgs> = {
        [P in keyof T & keyof AggregateShopifyProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopifyProduct[P]>
      : GetScalarType<T[P], AggregateShopifyProduct[P]>
  }




  export type ShopifyProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopifyProductWhereInput
    orderBy?: ShopifyProductOrderByWithAggregationInput | ShopifyProductOrderByWithAggregationInput[]
    by: ShopifyProductScalarFieldEnum[] | ShopifyProductScalarFieldEnum
    having?: ShopifyProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopifyProductCountAggregateInputType | true
    _min?: ShopifyProductMinAggregateInputType
    _max?: ShopifyProductMaxAggregateInputType
  }

  export type ShopifyProductGroupByOutputType = {
    id: string
    shopifyProductId: string
    title: string
    handle: string | null
    vendor: string | null
    productType: string | null
    tags: string | null
    status: string | null
    description: string | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ShopifyProductCountAggregateOutputType | null
    _min: ShopifyProductMinAggregateOutputType | null
    _max: ShopifyProductMaxAggregateOutputType | null
  }

  type GetShopifyProductGroupByPayload<T extends ShopifyProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopifyProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopifyProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopifyProductGroupByOutputType[P]>
            : GetScalarType<T[P], ShopifyProductGroupByOutputType[P]>
        }
      >
    >


  export type ShopifyProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyProductId?: boolean
    title?: boolean
    handle?: boolean
    vendor?: boolean
    productType?: boolean
    tags?: boolean
    status?: boolean
    description?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variants?: boolean | ShopifyProduct$variantsArgs<ExtArgs>
    _count?: boolean | ShopifyProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopifyProduct"]>

  export type ShopifyProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyProductId?: boolean
    title?: boolean
    handle?: boolean
    vendor?: boolean
    productType?: boolean
    tags?: boolean
    status?: boolean
    description?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shopifyProduct"]>

  export type ShopifyProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyProductId?: boolean
    title?: boolean
    handle?: boolean
    vendor?: boolean
    productType?: boolean
    tags?: boolean
    status?: boolean
    description?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shopifyProduct"]>

  export type ShopifyProductSelectScalar = {
    id?: boolean
    shopifyProductId?: boolean
    title?: boolean
    handle?: boolean
    vendor?: boolean
    productType?: boolean
    tags?: boolean
    status?: boolean
    description?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopifyProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyProductId" | "title" | "handle" | "vendor" | "productType" | "tags" | "status" | "description" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["shopifyProduct"]>
  export type ShopifyProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ShopifyProduct$variantsArgs<ExtArgs>
    _count?: boolean | ShopifyProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopifyProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ShopifyProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ShopifyProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopifyProduct"
    objects: {
      variants: Prisma.$ShopifyVariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyProductId: string
      title: string
      handle: string | null
      vendor: string | null
      productType: string | null
      tags: string | null
      status: string | null
      description: string | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopifyProduct"]>
    composites: {}
  }

  type ShopifyProductGetPayload<S extends boolean | null | undefined | ShopifyProductDefaultArgs> = $Result.GetResult<Prisma.$ShopifyProductPayload, S>

  type ShopifyProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopifyProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopifyProductCountAggregateInputType | true
    }

  export interface ShopifyProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopifyProduct'], meta: { name: 'ShopifyProduct' } }
    /**
     * Find zero or one ShopifyProduct that matches the filter.
     * @param {ShopifyProductFindUniqueArgs} args - Arguments to find a ShopifyProduct
     * @example
     * // Get one ShopifyProduct
     * const shopifyProduct = await prisma.shopifyProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopifyProductFindUniqueArgs>(args: SelectSubset<T, ShopifyProductFindUniqueArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopifyProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopifyProductFindUniqueOrThrowArgs} args - Arguments to find a ShopifyProduct
     * @example
     * // Get one ShopifyProduct
     * const shopifyProduct = await prisma.shopifyProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopifyProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopifyProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopifyProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyProductFindFirstArgs} args - Arguments to find a ShopifyProduct
     * @example
     * // Get one ShopifyProduct
     * const shopifyProduct = await prisma.shopifyProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopifyProductFindFirstArgs>(args?: SelectSubset<T, ShopifyProductFindFirstArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopifyProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyProductFindFirstOrThrowArgs} args - Arguments to find a ShopifyProduct
     * @example
     * // Get one ShopifyProduct
     * const shopifyProduct = await prisma.shopifyProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopifyProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopifyProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopifyProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopifyProducts
     * const shopifyProducts = await prisma.shopifyProduct.findMany()
     * 
     * // Get first 10 ShopifyProducts
     * const shopifyProducts = await prisma.shopifyProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopifyProductWithIdOnly = await prisma.shopifyProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopifyProductFindManyArgs>(args?: SelectSubset<T, ShopifyProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopifyProduct.
     * @param {ShopifyProductCreateArgs} args - Arguments to create a ShopifyProduct.
     * @example
     * // Create one ShopifyProduct
     * const ShopifyProduct = await prisma.shopifyProduct.create({
     *   data: {
     *     // ... data to create a ShopifyProduct
     *   }
     * })
     * 
     */
    create<T extends ShopifyProductCreateArgs>(args: SelectSubset<T, ShopifyProductCreateArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopifyProducts.
     * @param {ShopifyProductCreateManyArgs} args - Arguments to create many ShopifyProducts.
     * @example
     * // Create many ShopifyProducts
     * const shopifyProduct = await prisma.shopifyProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopifyProductCreateManyArgs>(args?: SelectSubset<T, ShopifyProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopifyProducts and returns the data saved in the database.
     * @param {ShopifyProductCreateManyAndReturnArgs} args - Arguments to create many ShopifyProducts.
     * @example
     * // Create many ShopifyProducts
     * const shopifyProduct = await prisma.shopifyProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopifyProducts and only return the `id`
     * const shopifyProductWithIdOnly = await prisma.shopifyProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopifyProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopifyProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShopifyProduct.
     * @param {ShopifyProductDeleteArgs} args - Arguments to delete one ShopifyProduct.
     * @example
     * // Delete one ShopifyProduct
     * const ShopifyProduct = await prisma.shopifyProduct.delete({
     *   where: {
     *     // ... filter to delete one ShopifyProduct
     *   }
     * })
     * 
     */
    delete<T extends ShopifyProductDeleteArgs>(args: SelectSubset<T, ShopifyProductDeleteArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopifyProduct.
     * @param {ShopifyProductUpdateArgs} args - Arguments to update one ShopifyProduct.
     * @example
     * // Update one ShopifyProduct
     * const shopifyProduct = await prisma.shopifyProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopifyProductUpdateArgs>(args: SelectSubset<T, ShopifyProductUpdateArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopifyProducts.
     * @param {ShopifyProductDeleteManyArgs} args - Arguments to filter ShopifyProducts to delete.
     * @example
     * // Delete a few ShopifyProducts
     * const { count } = await prisma.shopifyProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopifyProductDeleteManyArgs>(args?: SelectSubset<T, ShopifyProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopifyProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopifyProducts
     * const shopifyProduct = await prisma.shopifyProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopifyProductUpdateManyArgs>(args: SelectSubset<T, ShopifyProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopifyProducts and returns the data updated in the database.
     * @param {ShopifyProductUpdateManyAndReturnArgs} args - Arguments to update many ShopifyProducts.
     * @example
     * // Update many ShopifyProducts
     * const shopifyProduct = await prisma.shopifyProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShopifyProducts and only return the `id`
     * const shopifyProductWithIdOnly = await prisma.shopifyProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopifyProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopifyProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShopifyProduct.
     * @param {ShopifyProductUpsertArgs} args - Arguments to update or create a ShopifyProduct.
     * @example
     * // Update or create a ShopifyProduct
     * const shopifyProduct = await prisma.shopifyProduct.upsert({
     *   create: {
     *     // ... data to create a ShopifyProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopifyProduct we want to update
     *   }
     * })
     */
    upsert<T extends ShopifyProductUpsertArgs>(args: SelectSubset<T, ShopifyProductUpsertArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopifyProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyProductCountArgs} args - Arguments to filter ShopifyProducts to count.
     * @example
     * // Count the number of ShopifyProducts
     * const count = await prisma.shopifyProduct.count({
     *   where: {
     *     // ... the filter for the ShopifyProducts we want to count
     *   }
     * })
    **/
    count<T extends ShopifyProductCountArgs>(
      args?: Subset<T, ShopifyProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopifyProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopifyProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopifyProductAggregateArgs>(args: Subset<T, ShopifyProductAggregateArgs>): Prisma.PrismaPromise<GetShopifyProductAggregateType<T>>

    /**
     * Group by ShopifyProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopifyProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopifyProductGroupByArgs['orderBy'] }
        : { orderBy?: ShopifyProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopifyProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopifyProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopifyProduct model
   */
  readonly fields: ShopifyProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopifyProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopifyProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variants<T extends ShopifyProduct$variantsArgs<ExtArgs> = {}>(args?: Subset<T, ShopifyProduct$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopifyProduct model
   */
  interface ShopifyProductFieldRefs {
    readonly id: FieldRef<"ShopifyProduct", 'String'>
    readonly shopifyProductId: FieldRef<"ShopifyProduct", 'String'>
    readonly title: FieldRef<"ShopifyProduct", 'String'>
    readonly handle: FieldRef<"ShopifyProduct", 'String'>
    readonly vendor: FieldRef<"ShopifyProduct", 'String'>
    readonly productType: FieldRef<"ShopifyProduct", 'String'>
    readonly tags: FieldRef<"ShopifyProduct", 'String'>
    readonly status: FieldRef<"ShopifyProduct", 'String'>
    readonly description: FieldRef<"ShopifyProduct", 'String'>
    readonly publishedAt: FieldRef<"ShopifyProduct", 'DateTime'>
    readonly createdAt: FieldRef<"ShopifyProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopifyProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopifyProduct findUnique
   */
  export type ShopifyProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyProduct to fetch.
     */
    where: ShopifyProductWhereUniqueInput
  }

  /**
   * ShopifyProduct findUniqueOrThrow
   */
  export type ShopifyProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyProduct to fetch.
     */
    where: ShopifyProductWhereUniqueInput
  }

  /**
   * ShopifyProduct findFirst
   */
  export type ShopifyProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyProduct to fetch.
     */
    where?: ShopifyProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyProducts to fetch.
     */
    orderBy?: ShopifyProductOrderByWithRelationInput | ShopifyProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopifyProducts.
     */
    cursor?: ShopifyProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopifyProducts.
     */
    distinct?: ShopifyProductScalarFieldEnum | ShopifyProductScalarFieldEnum[]
  }

  /**
   * ShopifyProduct findFirstOrThrow
   */
  export type ShopifyProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyProduct to fetch.
     */
    where?: ShopifyProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyProducts to fetch.
     */
    orderBy?: ShopifyProductOrderByWithRelationInput | ShopifyProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopifyProducts.
     */
    cursor?: ShopifyProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopifyProducts.
     */
    distinct?: ShopifyProductScalarFieldEnum | ShopifyProductScalarFieldEnum[]
  }

  /**
   * ShopifyProduct findMany
   */
  export type ShopifyProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyProducts to fetch.
     */
    where?: ShopifyProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyProducts to fetch.
     */
    orderBy?: ShopifyProductOrderByWithRelationInput | ShopifyProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopifyProducts.
     */
    cursor?: ShopifyProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyProducts.
     */
    skip?: number
    distinct?: ShopifyProductScalarFieldEnum | ShopifyProductScalarFieldEnum[]
  }

  /**
   * ShopifyProduct create
   */
  export type ShopifyProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopifyProduct.
     */
    data: XOR<ShopifyProductCreateInput, ShopifyProductUncheckedCreateInput>
  }

  /**
   * ShopifyProduct createMany
   */
  export type ShopifyProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopifyProducts.
     */
    data: ShopifyProductCreateManyInput | ShopifyProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopifyProduct createManyAndReturn
   */
  export type ShopifyProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * The data used to create many ShopifyProducts.
     */
    data: ShopifyProductCreateManyInput | ShopifyProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopifyProduct update
   */
  export type ShopifyProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopifyProduct.
     */
    data: XOR<ShopifyProductUpdateInput, ShopifyProductUncheckedUpdateInput>
    /**
     * Choose, which ShopifyProduct to update.
     */
    where: ShopifyProductWhereUniqueInput
  }

  /**
   * ShopifyProduct updateMany
   */
  export type ShopifyProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopifyProducts.
     */
    data: XOR<ShopifyProductUpdateManyMutationInput, ShopifyProductUncheckedUpdateManyInput>
    /**
     * Filter which ShopifyProducts to update
     */
    where?: ShopifyProductWhereInput
    /**
     * Limit how many ShopifyProducts to update.
     */
    limit?: number
  }

  /**
   * ShopifyProduct updateManyAndReturn
   */
  export type ShopifyProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * The data used to update ShopifyProducts.
     */
    data: XOR<ShopifyProductUpdateManyMutationInput, ShopifyProductUncheckedUpdateManyInput>
    /**
     * Filter which ShopifyProducts to update
     */
    where?: ShopifyProductWhereInput
    /**
     * Limit how many ShopifyProducts to update.
     */
    limit?: number
  }

  /**
   * ShopifyProduct upsert
   */
  export type ShopifyProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopifyProduct to update in case it exists.
     */
    where: ShopifyProductWhereUniqueInput
    /**
     * In case the ShopifyProduct found by the `where` argument doesn't exist, create a new ShopifyProduct with this data.
     */
    create: XOR<ShopifyProductCreateInput, ShopifyProductUncheckedCreateInput>
    /**
     * In case the ShopifyProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopifyProductUpdateInput, ShopifyProductUncheckedUpdateInput>
  }

  /**
   * ShopifyProduct delete
   */
  export type ShopifyProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
    /**
     * Filter which ShopifyProduct to delete.
     */
    where: ShopifyProductWhereUniqueInput
  }

  /**
   * ShopifyProduct deleteMany
   */
  export type ShopifyProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopifyProducts to delete
     */
    where?: ShopifyProductWhereInput
    /**
     * Limit how many ShopifyProducts to delete.
     */
    limit?: number
  }

  /**
   * ShopifyProduct.variants
   */
  export type ShopifyProduct$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    where?: ShopifyVariantWhereInput
    orderBy?: ShopifyVariantOrderByWithRelationInput | ShopifyVariantOrderByWithRelationInput[]
    cursor?: ShopifyVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopifyVariantScalarFieldEnum | ShopifyVariantScalarFieldEnum[]
  }

  /**
   * ShopifyProduct without action
   */
  export type ShopifyProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyProduct
     */
    select?: ShopifyProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyProduct
     */
    omit?: ShopifyProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyProductInclude<ExtArgs> | null
  }


  /**
   * Model ShopifyVariant
   */

  export type AggregateShopifyVariant = {
    _count: ShopifyVariantCountAggregateOutputType | null
    _avg: ShopifyVariantAvgAggregateOutputType | null
    _sum: ShopifyVariantSumAggregateOutputType | null
    _min: ShopifyVariantMinAggregateOutputType | null
    _max: ShopifyVariantMaxAggregateOutputType | null
  }

  export type ShopifyVariantAvgAggregateOutputType = {
    price: number | null
    compareAtPrice: number | null
    grams: number | null
    weight: number | null
    inventoryQuantity: number | null
    position: number | null
  }

  export type ShopifyVariantSumAggregateOutputType = {
    price: number | null
    compareAtPrice: number | null
    grams: number | null
    weight: number | null
    inventoryQuantity: number | null
    position: number | null
  }

  export type ShopifyVariantMinAggregateOutputType = {
    id: string | null
    shopifyVariantId: string | null
    shopifyProductId: string | null
    title: string | null
    price: number | null
    compareAtPrice: number | null
    sku: string | null
    barcode: string | null
    grams: number | null
    weight: number | null
    weightUnit: string | null
    inventoryQuantity: number | null
    inventoryPolicy: string | null
    inventoryTracking: string | null
    requiresShipping: boolean | null
    taxable: boolean | null
    fulfillmentService: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopifyVariantMaxAggregateOutputType = {
    id: string | null
    shopifyVariantId: string | null
    shopifyProductId: string | null
    title: string | null
    price: number | null
    compareAtPrice: number | null
    sku: string | null
    barcode: string | null
    grams: number | null
    weight: number | null
    weightUnit: string | null
    inventoryQuantity: number | null
    inventoryPolicy: string | null
    inventoryTracking: string | null
    requiresShipping: boolean | null
    taxable: boolean | null
    fulfillmentService: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopifyVariantCountAggregateOutputType = {
    id: number
    shopifyVariantId: number
    shopifyProductId: number
    title: number
    price: number
    compareAtPrice: number
    sku: number
    barcode: number
    grams: number
    weight: number
    weightUnit: number
    inventoryQuantity: number
    inventoryPolicy: number
    inventoryTracking: number
    requiresShipping: number
    taxable: number
    fulfillmentService: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopifyVariantAvgAggregateInputType = {
    price?: true
    compareAtPrice?: true
    grams?: true
    weight?: true
    inventoryQuantity?: true
    position?: true
  }

  export type ShopifyVariantSumAggregateInputType = {
    price?: true
    compareAtPrice?: true
    grams?: true
    weight?: true
    inventoryQuantity?: true
    position?: true
  }

  export type ShopifyVariantMinAggregateInputType = {
    id?: true
    shopifyVariantId?: true
    shopifyProductId?: true
    title?: true
    price?: true
    compareAtPrice?: true
    sku?: true
    barcode?: true
    grams?: true
    weight?: true
    weightUnit?: true
    inventoryQuantity?: true
    inventoryPolicy?: true
    inventoryTracking?: true
    requiresShipping?: true
    taxable?: true
    fulfillmentService?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopifyVariantMaxAggregateInputType = {
    id?: true
    shopifyVariantId?: true
    shopifyProductId?: true
    title?: true
    price?: true
    compareAtPrice?: true
    sku?: true
    barcode?: true
    grams?: true
    weight?: true
    weightUnit?: true
    inventoryQuantity?: true
    inventoryPolicy?: true
    inventoryTracking?: true
    requiresShipping?: true
    taxable?: true
    fulfillmentService?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopifyVariantCountAggregateInputType = {
    id?: true
    shopifyVariantId?: true
    shopifyProductId?: true
    title?: true
    price?: true
    compareAtPrice?: true
    sku?: true
    barcode?: true
    grams?: true
    weight?: true
    weightUnit?: true
    inventoryQuantity?: true
    inventoryPolicy?: true
    inventoryTracking?: true
    requiresShipping?: true
    taxable?: true
    fulfillmentService?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopifyVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopifyVariant to aggregate.
     */
    where?: ShopifyVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyVariants to fetch.
     */
    orderBy?: ShopifyVariantOrderByWithRelationInput | ShopifyVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopifyVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopifyVariants
    **/
    _count?: true | ShopifyVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopifyVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopifyVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopifyVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopifyVariantMaxAggregateInputType
  }

  export type GetShopifyVariantAggregateType<T extends ShopifyVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateShopifyVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopifyVariant[P]>
      : GetScalarType<T[P], AggregateShopifyVariant[P]>
  }




  export type ShopifyVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopifyVariantWhereInput
    orderBy?: ShopifyVariantOrderByWithAggregationInput | ShopifyVariantOrderByWithAggregationInput[]
    by: ShopifyVariantScalarFieldEnum[] | ShopifyVariantScalarFieldEnum
    having?: ShopifyVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopifyVariantCountAggregateInputType | true
    _avg?: ShopifyVariantAvgAggregateInputType
    _sum?: ShopifyVariantSumAggregateInputType
    _min?: ShopifyVariantMinAggregateInputType
    _max?: ShopifyVariantMaxAggregateInputType
  }

  export type ShopifyVariantGroupByOutputType = {
    id: string
    shopifyVariantId: string
    shopifyProductId: string
    title: string | null
    price: number | null
    compareAtPrice: number | null
    sku: string | null
    barcode: string | null
    grams: number | null
    weight: number | null
    weightUnit: string | null
    inventoryQuantity: number
    inventoryPolicy: string | null
    inventoryTracking: string | null
    requiresShipping: boolean
    taxable: boolean
    fulfillmentService: string | null
    position: number | null
    createdAt: Date
    updatedAt: Date
    _count: ShopifyVariantCountAggregateOutputType | null
    _avg: ShopifyVariantAvgAggregateOutputType | null
    _sum: ShopifyVariantSumAggregateOutputType | null
    _min: ShopifyVariantMinAggregateOutputType | null
    _max: ShopifyVariantMaxAggregateOutputType | null
  }

  type GetShopifyVariantGroupByPayload<T extends ShopifyVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopifyVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopifyVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopifyVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ShopifyVariantGroupByOutputType[P]>
        }
      >
    >


  export type ShopifyVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyVariantId?: boolean
    shopifyProductId?: boolean
    title?: boolean
    price?: boolean
    compareAtPrice?: boolean
    sku?: boolean
    barcode?: boolean
    grams?: boolean
    weight?: boolean
    weightUnit?: boolean
    inventoryQuantity?: boolean
    inventoryPolicy?: boolean
    inventoryTracking?: boolean
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ShopifyProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopifyVariant"]>

  export type ShopifyVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyVariantId?: boolean
    shopifyProductId?: boolean
    title?: boolean
    price?: boolean
    compareAtPrice?: boolean
    sku?: boolean
    barcode?: boolean
    grams?: boolean
    weight?: boolean
    weightUnit?: boolean
    inventoryQuantity?: boolean
    inventoryPolicy?: boolean
    inventoryTracking?: boolean
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ShopifyProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopifyVariant"]>

  export type ShopifyVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopifyVariantId?: boolean
    shopifyProductId?: boolean
    title?: boolean
    price?: boolean
    compareAtPrice?: boolean
    sku?: boolean
    barcode?: boolean
    grams?: boolean
    weight?: boolean
    weightUnit?: boolean
    inventoryQuantity?: boolean
    inventoryPolicy?: boolean
    inventoryTracking?: boolean
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ShopifyProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopifyVariant"]>

  export type ShopifyVariantSelectScalar = {
    id?: boolean
    shopifyVariantId?: boolean
    shopifyProductId?: boolean
    title?: boolean
    price?: boolean
    compareAtPrice?: boolean
    sku?: boolean
    barcode?: boolean
    grams?: boolean
    weight?: boolean
    weightUnit?: boolean
    inventoryQuantity?: boolean
    inventoryPolicy?: boolean
    inventoryTracking?: boolean
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopifyVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopifyVariantId" | "shopifyProductId" | "title" | "price" | "compareAtPrice" | "sku" | "barcode" | "grams" | "weight" | "weightUnit" | "inventoryQuantity" | "inventoryPolicy" | "inventoryTracking" | "requiresShipping" | "taxable" | "fulfillmentService" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["shopifyVariant"]>
  export type ShopifyVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ShopifyProductDefaultArgs<ExtArgs>
  }
  export type ShopifyVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ShopifyProductDefaultArgs<ExtArgs>
  }
  export type ShopifyVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ShopifyProductDefaultArgs<ExtArgs>
  }

  export type $ShopifyVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopifyVariant"
    objects: {
      product: Prisma.$ShopifyProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopifyVariantId: string
      shopifyProductId: string
      title: string | null
      price: number | null
      compareAtPrice: number | null
      sku: string | null
      barcode: string | null
      grams: number | null
      weight: number | null
      weightUnit: string | null
      inventoryQuantity: number
      inventoryPolicy: string | null
      inventoryTracking: string | null
      requiresShipping: boolean
      taxable: boolean
      fulfillmentService: string | null
      position: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopifyVariant"]>
    composites: {}
  }

  type ShopifyVariantGetPayload<S extends boolean | null | undefined | ShopifyVariantDefaultArgs> = $Result.GetResult<Prisma.$ShopifyVariantPayload, S>

  type ShopifyVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopifyVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopifyVariantCountAggregateInputType | true
    }

  export interface ShopifyVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopifyVariant'], meta: { name: 'ShopifyVariant' } }
    /**
     * Find zero or one ShopifyVariant that matches the filter.
     * @param {ShopifyVariantFindUniqueArgs} args - Arguments to find a ShopifyVariant
     * @example
     * // Get one ShopifyVariant
     * const shopifyVariant = await prisma.shopifyVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopifyVariantFindUniqueArgs>(args: SelectSubset<T, ShopifyVariantFindUniqueArgs<ExtArgs>>): Prisma__ShopifyVariantClient<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopifyVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopifyVariantFindUniqueOrThrowArgs} args - Arguments to find a ShopifyVariant
     * @example
     * // Get one ShopifyVariant
     * const shopifyVariant = await prisma.shopifyVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopifyVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopifyVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopifyVariantClient<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopifyVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyVariantFindFirstArgs} args - Arguments to find a ShopifyVariant
     * @example
     * // Get one ShopifyVariant
     * const shopifyVariant = await prisma.shopifyVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopifyVariantFindFirstArgs>(args?: SelectSubset<T, ShopifyVariantFindFirstArgs<ExtArgs>>): Prisma__ShopifyVariantClient<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopifyVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyVariantFindFirstOrThrowArgs} args - Arguments to find a ShopifyVariant
     * @example
     * // Get one ShopifyVariant
     * const shopifyVariant = await prisma.shopifyVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopifyVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopifyVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopifyVariantClient<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopifyVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopifyVariants
     * const shopifyVariants = await prisma.shopifyVariant.findMany()
     * 
     * // Get first 10 ShopifyVariants
     * const shopifyVariants = await prisma.shopifyVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopifyVariantWithIdOnly = await prisma.shopifyVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopifyVariantFindManyArgs>(args?: SelectSubset<T, ShopifyVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopifyVariant.
     * @param {ShopifyVariantCreateArgs} args - Arguments to create a ShopifyVariant.
     * @example
     * // Create one ShopifyVariant
     * const ShopifyVariant = await prisma.shopifyVariant.create({
     *   data: {
     *     // ... data to create a ShopifyVariant
     *   }
     * })
     * 
     */
    create<T extends ShopifyVariantCreateArgs>(args: SelectSubset<T, ShopifyVariantCreateArgs<ExtArgs>>): Prisma__ShopifyVariantClient<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopifyVariants.
     * @param {ShopifyVariantCreateManyArgs} args - Arguments to create many ShopifyVariants.
     * @example
     * // Create many ShopifyVariants
     * const shopifyVariant = await prisma.shopifyVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopifyVariantCreateManyArgs>(args?: SelectSubset<T, ShopifyVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShopifyVariants and returns the data saved in the database.
     * @param {ShopifyVariantCreateManyAndReturnArgs} args - Arguments to create many ShopifyVariants.
     * @example
     * // Create many ShopifyVariants
     * const shopifyVariant = await prisma.shopifyVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShopifyVariants and only return the `id`
     * const shopifyVariantWithIdOnly = await prisma.shopifyVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopifyVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopifyVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShopifyVariant.
     * @param {ShopifyVariantDeleteArgs} args - Arguments to delete one ShopifyVariant.
     * @example
     * // Delete one ShopifyVariant
     * const ShopifyVariant = await prisma.shopifyVariant.delete({
     *   where: {
     *     // ... filter to delete one ShopifyVariant
     *   }
     * })
     * 
     */
    delete<T extends ShopifyVariantDeleteArgs>(args: SelectSubset<T, ShopifyVariantDeleteArgs<ExtArgs>>): Prisma__ShopifyVariantClient<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopifyVariant.
     * @param {ShopifyVariantUpdateArgs} args - Arguments to update one ShopifyVariant.
     * @example
     * // Update one ShopifyVariant
     * const shopifyVariant = await prisma.shopifyVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopifyVariantUpdateArgs>(args: SelectSubset<T, ShopifyVariantUpdateArgs<ExtArgs>>): Prisma__ShopifyVariantClient<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopifyVariants.
     * @param {ShopifyVariantDeleteManyArgs} args - Arguments to filter ShopifyVariants to delete.
     * @example
     * // Delete a few ShopifyVariants
     * const { count } = await prisma.shopifyVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopifyVariantDeleteManyArgs>(args?: SelectSubset<T, ShopifyVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopifyVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopifyVariants
     * const shopifyVariant = await prisma.shopifyVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopifyVariantUpdateManyArgs>(args: SelectSubset<T, ShopifyVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopifyVariants and returns the data updated in the database.
     * @param {ShopifyVariantUpdateManyAndReturnArgs} args - Arguments to update many ShopifyVariants.
     * @example
     * // Update many ShopifyVariants
     * const shopifyVariant = await prisma.shopifyVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShopifyVariants and only return the `id`
     * const shopifyVariantWithIdOnly = await prisma.shopifyVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopifyVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopifyVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShopifyVariant.
     * @param {ShopifyVariantUpsertArgs} args - Arguments to update or create a ShopifyVariant.
     * @example
     * // Update or create a ShopifyVariant
     * const shopifyVariant = await prisma.shopifyVariant.upsert({
     *   create: {
     *     // ... data to create a ShopifyVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopifyVariant we want to update
     *   }
     * })
     */
    upsert<T extends ShopifyVariantUpsertArgs>(args: SelectSubset<T, ShopifyVariantUpsertArgs<ExtArgs>>): Prisma__ShopifyVariantClient<$Result.GetResult<Prisma.$ShopifyVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopifyVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyVariantCountArgs} args - Arguments to filter ShopifyVariants to count.
     * @example
     * // Count the number of ShopifyVariants
     * const count = await prisma.shopifyVariant.count({
     *   where: {
     *     // ... the filter for the ShopifyVariants we want to count
     *   }
     * })
    **/
    count<T extends ShopifyVariantCountArgs>(
      args?: Subset<T, ShopifyVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopifyVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopifyVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopifyVariantAggregateArgs>(args: Subset<T, ShopifyVariantAggregateArgs>): Prisma.PrismaPromise<GetShopifyVariantAggregateType<T>>

    /**
     * Group by ShopifyVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopifyVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopifyVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopifyVariantGroupByArgs['orderBy'] }
        : { orderBy?: ShopifyVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopifyVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopifyVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopifyVariant model
   */
  readonly fields: ShopifyVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopifyVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopifyVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ShopifyProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopifyProductDefaultArgs<ExtArgs>>): Prisma__ShopifyProductClient<$Result.GetResult<Prisma.$ShopifyProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopifyVariant model
   */
  interface ShopifyVariantFieldRefs {
    readonly id: FieldRef<"ShopifyVariant", 'String'>
    readonly shopifyVariantId: FieldRef<"ShopifyVariant", 'String'>
    readonly shopifyProductId: FieldRef<"ShopifyVariant", 'String'>
    readonly title: FieldRef<"ShopifyVariant", 'String'>
    readonly price: FieldRef<"ShopifyVariant", 'Float'>
    readonly compareAtPrice: FieldRef<"ShopifyVariant", 'Float'>
    readonly sku: FieldRef<"ShopifyVariant", 'String'>
    readonly barcode: FieldRef<"ShopifyVariant", 'String'>
    readonly grams: FieldRef<"ShopifyVariant", 'Float'>
    readonly weight: FieldRef<"ShopifyVariant", 'Float'>
    readonly weightUnit: FieldRef<"ShopifyVariant", 'String'>
    readonly inventoryQuantity: FieldRef<"ShopifyVariant", 'Int'>
    readonly inventoryPolicy: FieldRef<"ShopifyVariant", 'String'>
    readonly inventoryTracking: FieldRef<"ShopifyVariant", 'String'>
    readonly requiresShipping: FieldRef<"ShopifyVariant", 'Boolean'>
    readonly taxable: FieldRef<"ShopifyVariant", 'Boolean'>
    readonly fulfillmentService: FieldRef<"ShopifyVariant", 'String'>
    readonly position: FieldRef<"ShopifyVariant", 'Int'>
    readonly createdAt: FieldRef<"ShopifyVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopifyVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopifyVariant findUnique
   */
  export type ShopifyVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyVariant to fetch.
     */
    where: ShopifyVariantWhereUniqueInput
  }

  /**
   * ShopifyVariant findUniqueOrThrow
   */
  export type ShopifyVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyVariant to fetch.
     */
    where: ShopifyVariantWhereUniqueInput
  }

  /**
   * ShopifyVariant findFirst
   */
  export type ShopifyVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyVariant to fetch.
     */
    where?: ShopifyVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyVariants to fetch.
     */
    orderBy?: ShopifyVariantOrderByWithRelationInput | ShopifyVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopifyVariants.
     */
    cursor?: ShopifyVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopifyVariants.
     */
    distinct?: ShopifyVariantScalarFieldEnum | ShopifyVariantScalarFieldEnum[]
  }

  /**
   * ShopifyVariant findFirstOrThrow
   */
  export type ShopifyVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyVariant to fetch.
     */
    where?: ShopifyVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyVariants to fetch.
     */
    orderBy?: ShopifyVariantOrderByWithRelationInput | ShopifyVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopifyVariants.
     */
    cursor?: ShopifyVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopifyVariants.
     */
    distinct?: ShopifyVariantScalarFieldEnum | ShopifyVariantScalarFieldEnum[]
  }

  /**
   * ShopifyVariant findMany
   */
  export type ShopifyVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * Filter, which ShopifyVariants to fetch.
     */
    where?: ShopifyVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopifyVariants to fetch.
     */
    orderBy?: ShopifyVariantOrderByWithRelationInput | ShopifyVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopifyVariants.
     */
    cursor?: ShopifyVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopifyVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopifyVariants.
     */
    skip?: number
    distinct?: ShopifyVariantScalarFieldEnum | ShopifyVariantScalarFieldEnum[]
  }

  /**
   * ShopifyVariant create
   */
  export type ShopifyVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopifyVariant.
     */
    data: XOR<ShopifyVariantCreateInput, ShopifyVariantUncheckedCreateInput>
  }

  /**
   * ShopifyVariant createMany
   */
  export type ShopifyVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopifyVariants.
     */
    data: ShopifyVariantCreateManyInput | ShopifyVariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopifyVariant createManyAndReturn
   */
  export type ShopifyVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * The data used to create many ShopifyVariants.
     */
    data: ShopifyVariantCreateManyInput | ShopifyVariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopifyVariant update
   */
  export type ShopifyVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopifyVariant.
     */
    data: XOR<ShopifyVariantUpdateInput, ShopifyVariantUncheckedUpdateInput>
    /**
     * Choose, which ShopifyVariant to update.
     */
    where: ShopifyVariantWhereUniqueInput
  }

  /**
   * ShopifyVariant updateMany
   */
  export type ShopifyVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopifyVariants.
     */
    data: XOR<ShopifyVariantUpdateManyMutationInput, ShopifyVariantUncheckedUpdateManyInput>
    /**
     * Filter which ShopifyVariants to update
     */
    where?: ShopifyVariantWhereInput
    /**
     * Limit how many ShopifyVariants to update.
     */
    limit?: number
  }

  /**
   * ShopifyVariant updateManyAndReturn
   */
  export type ShopifyVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * The data used to update ShopifyVariants.
     */
    data: XOR<ShopifyVariantUpdateManyMutationInput, ShopifyVariantUncheckedUpdateManyInput>
    /**
     * Filter which ShopifyVariants to update
     */
    where?: ShopifyVariantWhereInput
    /**
     * Limit how many ShopifyVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShopifyVariant upsert
   */
  export type ShopifyVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopifyVariant to update in case it exists.
     */
    where: ShopifyVariantWhereUniqueInput
    /**
     * In case the ShopifyVariant found by the `where` argument doesn't exist, create a new ShopifyVariant with this data.
     */
    create: XOR<ShopifyVariantCreateInput, ShopifyVariantUncheckedCreateInput>
    /**
     * In case the ShopifyVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopifyVariantUpdateInput, ShopifyVariantUncheckedUpdateInput>
  }

  /**
   * ShopifyVariant delete
   */
  export type ShopifyVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
    /**
     * Filter which ShopifyVariant to delete.
     */
    where: ShopifyVariantWhereUniqueInput
  }

  /**
   * ShopifyVariant deleteMany
   */
  export type ShopifyVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopifyVariants to delete
     */
    where?: ShopifyVariantWhereInput
    /**
     * Limit how many ShopifyVariants to delete.
     */
    limit?: number
  }

  /**
   * ShopifyVariant without action
   */
  export type ShopifyVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopifyVariant
     */
    select?: ShopifyVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopifyVariant
     */
    omit?: ShopifyVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopifyVariantInclude<ExtArgs> | null
  }


  /**
   * Model Machine
   */

  export type AggregateMachine = {
    _count: MachineCountAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  export type MachineMinAggregateOutputType = {
    id: string | null
    machineId: string | null
    name: string | null
    type: string | null
    location: string | null
    manufacturer: string | null
    model: string | null
    serialNumber: string | null
    installDate: Date | null
    status: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MachineMaxAggregateOutputType = {
    id: string | null
    machineId: string | null
    name: string | null
    type: string | null
    location: string | null
    manufacturer: string | null
    model: string | null
    serialNumber: string | null
    installDate: Date | null
    status: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MachineCountAggregateOutputType = {
    id: number
    machineId: number
    name: number
    type: number
    location: number
    manufacturer: number
    model: number
    serialNumber: number
    installDate: number
    status: number
    isActive: number
    configuration: number
    specifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MachineMinAggregateInputType = {
    id?: true
    machineId?: true
    name?: true
    type?: true
    location?: true
    manufacturer?: true
    model?: true
    serialNumber?: true
    installDate?: true
    status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MachineMaxAggregateInputType = {
    id?: true
    machineId?: true
    name?: true
    type?: true
    location?: true
    manufacturer?: true
    model?: true
    serialNumber?: true
    installDate?: true
    status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MachineCountAggregateInputType = {
    id?: true
    machineId?: true
    name?: true
    type?: true
    location?: true
    manufacturer?: true
    model?: true
    serialNumber?: true
    installDate?: true
    status?: true
    isActive?: true
    configuration?: true
    specifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MachineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machine to aggregate.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Machines
    **/
    _count?: true | MachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMaxAggregateInputType
  }

  export type GetMachineAggregateType<T extends MachineAggregateArgs> = {
        [P in keyof T & keyof AggregateMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachine[P]>
      : GetScalarType<T[P], AggregateMachine[P]>
  }




  export type MachineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineWhereInput
    orderBy?: MachineOrderByWithAggregationInput | MachineOrderByWithAggregationInput[]
    by: MachineScalarFieldEnum[] | MachineScalarFieldEnum
    having?: MachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineCountAggregateInputType | true
    _min?: MachineMinAggregateInputType
    _max?: MachineMaxAggregateInputType
  }

  export type MachineGroupByOutputType = {
    id: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer: string | null
    model: string | null
    serialNumber: string | null
    installDate: Date | null
    status: string
    isActive: boolean
    configuration: JsonValue | null
    specifications: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MachineCountAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  type GetMachineGroupByPayload<T extends MachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineGroupByOutputType[P]>
            : GetScalarType<T[P], MachineGroupByOutputType[P]>
        }
      >
    >


  export type MachineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    name?: boolean
    type?: boolean
    location?: boolean
    manufacturer?: boolean
    model?: boolean
    serialNumber?: boolean
    installDate?: boolean
    status?: boolean
    isActive?: boolean
    configuration?: boolean
    specifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sensors?: boolean | Machine$sensorsArgs<ExtArgs>
    alerts?: boolean | Machine$alertsArgs<ExtArgs>
    maintenanceRecords?: boolean | Machine$maintenanceRecordsArgs<ExtArgs>
    _count?: boolean | MachineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    name?: boolean
    type?: boolean
    location?: boolean
    manufacturer?: boolean
    model?: boolean
    serialNumber?: boolean
    installDate?: boolean
    status?: boolean
    isActive?: boolean
    configuration?: boolean
    specifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    name?: boolean
    type?: boolean
    location?: boolean
    manufacturer?: boolean
    model?: boolean
    serialNumber?: boolean
    installDate?: boolean
    status?: boolean
    isActive?: boolean
    configuration?: boolean
    specifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectScalar = {
    id?: boolean
    machineId?: boolean
    name?: boolean
    type?: boolean
    location?: boolean
    manufacturer?: boolean
    model?: boolean
    serialNumber?: boolean
    installDate?: boolean
    status?: boolean
    isActive?: boolean
    configuration?: boolean
    specifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MachineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "machineId" | "name" | "type" | "location" | "manufacturer" | "model" | "serialNumber" | "installDate" | "status" | "isActive" | "configuration" | "specifications" | "createdAt" | "updatedAt", ExtArgs["result"]["machine"]>
  export type MachineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sensors?: boolean | Machine$sensorsArgs<ExtArgs>
    alerts?: boolean | Machine$alertsArgs<ExtArgs>
    maintenanceRecords?: boolean | Machine$maintenanceRecordsArgs<ExtArgs>
    _count?: boolean | MachineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MachineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MachineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MachinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Machine"
    objects: {
      sensors: Prisma.$MachineSensorPayload<ExtArgs>[]
      alerts: Prisma.$MachineAlertPayload<ExtArgs>[]
      maintenanceRecords: Prisma.$MachineMaintenanceRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      machineId: string
      name: string
      type: string
      location: string
      manufacturer: string | null
      model: string | null
      serialNumber: string | null
      installDate: Date | null
      status: string
      isActive: boolean
      configuration: Prisma.JsonValue | null
      specifications: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["machine"]>
    composites: {}
  }

  type MachineGetPayload<S extends boolean | null | undefined | MachineDefaultArgs> = $Result.GetResult<Prisma.$MachinePayload, S>

  type MachineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MachineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MachineCountAggregateInputType | true
    }

  export interface MachineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Machine'], meta: { name: 'Machine' } }
    /**
     * Find zero or one Machine that matches the filter.
     * @param {MachineFindUniqueArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineFindUniqueArgs>(args: SelectSubset<T, MachineFindUniqueArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Machine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MachineFindUniqueOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineFindFirstArgs>(args?: SelectSubset<T, MachineFindFirstArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machines
     * const machines = await prisma.machine.findMany()
     * 
     * // Get first 10 Machines
     * const machines = await prisma.machine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineWithIdOnly = await prisma.machine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineFindManyArgs>(args?: SelectSubset<T, MachineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Machine.
     * @param {MachineCreateArgs} args - Arguments to create a Machine.
     * @example
     * // Create one Machine
     * const Machine = await prisma.machine.create({
     *   data: {
     *     // ... data to create a Machine
     *   }
     * })
     * 
     */
    create<T extends MachineCreateArgs>(args: SelectSubset<T, MachineCreateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Machines.
     * @param {MachineCreateManyArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineCreateManyArgs>(args?: SelectSubset<T, MachineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Machines and returns the data saved in the database.
     * @param {MachineCreateManyAndReturnArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Machines and only return the `id`
     * const machineWithIdOnly = await prisma.machine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Machine.
     * @param {MachineDeleteArgs} args - Arguments to delete one Machine.
     * @example
     * // Delete one Machine
     * const Machine = await prisma.machine.delete({
     *   where: {
     *     // ... filter to delete one Machine
     *   }
     * })
     * 
     */
    delete<T extends MachineDeleteArgs>(args: SelectSubset<T, MachineDeleteArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Machine.
     * @param {MachineUpdateArgs} args - Arguments to update one Machine.
     * @example
     * // Update one Machine
     * const machine = await prisma.machine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineUpdateArgs>(args: SelectSubset<T, MachineUpdateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Machines.
     * @param {MachineDeleteManyArgs} args - Arguments to filter Machines to delete.
     * @example
     * // Delete a few Machines
     * const { count } = await prisma.machine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineDeleteManyArgs>(args?: SelectSubset<T, MachineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineUpdateManyArgs>(args: SelectSubset<T, MachineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines and returns the data updated in the database.
     * @param {MachineUpdateManyAndReturnArgs} args - Arguments to update many Machines.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Machines and only return the `id`
     * const machineWithIdOnly = await prisma.machine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MachineUpdateManyAndReturnArgs>(args: SelectSubset<T, MachineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Machine.
     * @param {MachineUpsertArgs} args - Arguments to update or create a Machine.
     * @example
     * // Update or create a Machine
     * const machine = await prisma.machine.upsert({
     *   create: {
     *     // ... data to create a Machine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machine we want to update
     *   }
     * })
     */
    upsert<T extends MachineUpsertArgs>(args: SelectSubset<T, MachineUpsertArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineCountArgs} args - Arguments to filter Machines to count.
     * @example
     * // Count the number of Machines
     * const count = await prisma.machine.count({
     *   where: {
     *     // ... the filter for the Machines we want to count
     *   }
     * })
    **/
    count<T extends MachineCountArgs>(
      args?: Subset<T, MachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineAggregateArgs>(args: Subset<T, MachineAggregateArgs>): Prisma.PrismaPromise<GetMachineAggregateType<T>>

    /**
     * Group by Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineGroupByArgs['orderBy'] }
        : { orderBy?: MachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Machine model
   */
  readonly fields: MachineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Machine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sensors<T extends Machine$sensorsArgs<ExtArgs> = {}>(args?: Subset<T, Machine$sensorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    alerts<T extends Machine$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Machine$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenanceRecords<T extends Machine$maintenanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Machine$maintenanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Machine model
   */
  interface MachineFieldRefs {
    readonly id: FieldRef<"Machine", 'String'>
    readonly machineId: FieldRef<"Machine", 'String'>
    readonly name: FieldRef<"Machine", 'String'>
    readonly type: FieldRef<"Machine", 'String'>
    readonly location: FieldRef<"Machine", 'String'>
    readonly manufacturer: FieldRef<"Machine", 'String'>
    readonly model: FieldRef<"Machine", 'String'>
    readonly serialNumber: FieldRef<"Machine", 'String'>
    readonly installDate: FieldRef<"Machine", 'DateTime'>
    readonly status: FieldRef<"Machine", 'String'>
    readonly isActive: FieldRef<"Machine", 'Boolean'>
    readonly configuration: FieldRef<"Machine", 'Json'>
    readonly specifications: FieldRef<"Machine", 'Json'>
    readonly createdAt: FieldRef<"Machine", 'DateTime'>
    readonly updatedAt: FieldRef<"Machine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Machine findUnique
   */
  export type MachineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findUniqueOrThrow
   */
  export type MachineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findFirst
   */
  export type MachineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findFirstOrThrow
   */
  export type MachineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findMany
   */
  export type MachineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machines to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine create
   */
  export type MachineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to create a Machine.
     */
    data: XOR<MachineCreateInput, MachineUncheckedCreateInput>
  }

  /**
   * Machine createMany
   */
  export type MachineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Machine createManyAndReturn
   */
  export type MachineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Machine update
   */
  export type MachineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to update a Machine.
     */
    data: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
    /**
     * Choose, which Machine to update.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine updateMany
   */
  export type MachineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to update.
     */
    limit?: number
  }

  /**
   * Machine updateManyAndReturn
   */
  export type MachineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to update.
     */
    limit?: number
  }

  /**
   * Machine upsert
   */
  export type MachineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The filter to search for the Machine to update in case it exists.
     */
    where: MachineWhereUniqueInput
    /**
     * In case the Machine found by the `where` argument doesn't exist, create a new Machine with this data.
     */
    create: XOR<MachineCreateInput, MachineUncheckedCreateInput>
    /**
     * In case the Machine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
  }

  /**
   * Machine delete
   */
  export type MachineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter which Machine to delete.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine deleteMany
   */
  export type MachineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machines to delete
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to delete.
     */
    limit?: number
  }

  /**
   * Machine.sensors
   */
  export type Machine$sensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    where?: MachineSensorWhereInput
    orderBy?: MachineSensorOrderByWithRelationInput | MachineSensorOrderByWithRelationInput[]
    cursor?: MachineSensorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineSensorScalarFieldEnum | MachineSensorScalarFieldEnum[]
  }

  /**
   * Machine.alerts
   */
  export type Machine$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    where?: MachineAlertWhereInput
    orderBy?: MachineAlertOrderByWithRelationInput | MachineAlertOrderByWithRelationInput[]
    cursor?: MachineAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineAlertScalarFieldEnum | MachineAlertScalarFieldEnum[]
  }

  /**
   * Machine.maintenanceRecords
   */
  export type Machine$maintenanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    where?: MachineMaintenanceRecordWhereInput
    orderBy?: MachineMaintenanceRecordOrderByWithRelationInput | MachineMaintenanceRecordOrderByWithRelationInput[]
    cursor?: MachineMaintenanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineMaintenanceRecordScalarFieldEnum | MachineMaintenanceRecordScalarFieldEnum[]
  }

  /**
   * Machine without action
   */
  export type MachineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
  }


  /**
   * Model MachineSensor
   */

  export type AggregateMachineSensor = {
    _count: MachineSensorCountAggregateOutputType | null
    _avg: MachineSensorAvgAggregateOutputType | null
    _sum: MachineSensorSumAggregateOutputType | null
    _min: MachineSensorMinAggregateOutputType | null
    _max: MachineSensorMaxAggregateOutputType | null
  }

  export type MachineSensorAvgAggregateOutputType = {
    value: number | null
    threshold: number | null
    minValue: number | null
    maxValue: number | null
  }

  export type MachineSensorSumAggregateOutputType = {
    value: number | null
    threshold: number | null
    minValue: number | null
    maxValue: number | null
  }

  export type MachineSensorMinAggregateOutputType = {
    id: string | null
    machineId: string | null
    sensorType: string | null
    sensorName: string | null
    value: number | null
    unit: string | null
    threshold: number | null
    minValue: number | null
    maxValue: number | null
    status: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type MachineSensorMaxAggregateOutputType = {
    id: string | null
    machineId: string | null
    sensorType: string | null
    sensorName: string | null
    value: number | null
    unit: string | null
    threshold: number | null
    minValue: number | null
    maxValue: number | null
    status: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type MachineSensorCountAggregateOutputType = {
    id: number
    machineId: number
    sensorType: number
    sensorName: number
    value: number
    unit: number
    threshold: number
    minValue: number
    maxValue: number
    status: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type MachineSensorAvgAggregateInputType = {
    value?: true
    threshold?: true
    minValue?: true
    maxValue?: true
  }

  export type MachineSensorSumAggregateInputType = {
    value?: true
    threshold?: true
    minValue?: true
    maxValue?: true
  }

  export type MachineSensorMinAggregateInputType = {
    id?: true
    machineId?: true
    sensorType?: true
    sensorName?: true
    value?: true
    unit?: true
    threshold?: true
    minValue?: true
    maxValue?: true
    status?: true
    timestamp?: true
    createdAt?: true
  }

  export type MachineSensorMaxAggregateInputType = {
    id?: true
    machineId?: true
    sensorType?: true
    sensorName?: true
    value?: true
    unit?: true
    threshold?: true
    minValue?: true
    maxValue?: true
    status?: true
    timestamp?: true
    createdAt?: true
  }

  export type MachineSensorCountAggregateInputType = {
    id?: true
    machineId?: true
    sensorType?: true
    sensorName?: true
    value?: true
    unit?: true
    threshold?: true
    minValue?: true
    maxValue?: true
    status?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type MachineSensorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineSensor to aggregate.
     */
    where?: MachineSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineSensors to fetch.
     */
    orderBy?: MachineSensorOrderByWithRelationInput | MachineSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MachineSensors
    **/
    _count?: true | MachineSensorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineSensorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineSensorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineSensorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineSensorMaxAggregateInputType
  }

  export type GetMachineSensorAggregateType<T extends MachineSensorAggregateArgs> = {
        [P in keyof T & keyof AggregateMachineSensor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachineSensor[P]>
      : GetScalarType<T[P], AggregateMachineSensor[P]>
  }




  export type MachineSensorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineSensorWhereInput
    orderBy?: MachineSensorOrderByWithAggregationInput | MachineSensorOrderByWithAggregationInput[]
    by: MachineSensorScalarFieldEnum[] | MachineSensorScalarFieldEnum
    having?: MachineSensorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineSensorCountAggregateInputType | true
    _avg?: MachineSensorAvgAggregateInputType
    _sum?: MachineSensorSumAggregateInputType
    _min?: MachineSensorMinAggregateInputType
    _max?: MachineSensorMaxAggregateInputType
  }

  export type MachineSensorGroupByOutputType = {
    id: string
    machineId: string
    sensorType: string
    sensorName: string
    value: number
    unit: string | null
    threshold: number | null
    minValue: number | null
    maxValue: number | null
    status: string
    timestamp: Date
    createdAt: Date
    _count: MachineSensorCountAggregateOutputType | null
    _avg: MachineSensorAvgAggregateOutputType | null
    _sum: MachineSensorSumAggregateOutputType | null
    _min: MachineSensorMinAggregateOutputType | null
    _max: MachineSensorMaxAggregateOutputType | null
  }

  type GetMachineSensorGroupByPayload<T extends MachineSensorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineSensorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineSensorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineSensorGroupByOutputType[P]>
            : GetScalarType<T[P], MachineSensorGroupByOutputType[P]>
        }
      >
    >


  export type MachineSensorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    sensorType?: boolean
    sensorName?: boolean
    value?: boolean
    unit?: boolean
    threshold?: boolean
    minValue?: boolean
    maxValue?: boolean
    status?: boolean
    timestamp?: boolean
    createdAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineSensor"]>

  export type MachineSensorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    sensorType?: boolean
    sensorName?: boolean
    value?: boolean
    unit?: boolean
    threshold?: boolean
    minValue?: boolean
    maxValue?: boolean
    status?: boolean
    timestamp?: boolean
    createdAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineSensor"]>

  export type MachineSensorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    sensorType?: boolean
    sensorName?: boolean
    value?: boolean
    unit?: boolean
    threshold?: boolean
    minValue?: boolean
    maxValue?: boolean
    status?: boolean
    timestamp?: boolean
    createdAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineSensor"]>

  export type MachineSensorSelectScalar = {
    id?: boolean
    machineId?: boolean
    sensorType?: boolean
    sensorName?: boolean
    value?: boolean
    unit?: boolean
    threshold?: boolean
    minValue?: boolean
    maxValue?: boolean
    status?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type MachineSensorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "machineId" | "sensorType" | "sensorName" | "value" | "unit" | "threshold" | "minValue" | "maxValue" | "status" | "timestamp" | "createdAt", ExtArgs["result"]["machineSensor"]>
  export type MachineSensorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }
  export type MachineSensorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }
  export type MachineSensorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }

  export type $MachineSensorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MachineSensor"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      machineId: string
      sensorType: string
      sensorName: string
      value: number
      unit: string | null
      threshold: number | null
      minValue: number | null
      maxValue: number | null
      status: string
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["machineSensor"]>
    composites: {}
  }

  type MachineSensorGetPayload<S extends boolean | null | undefined | MachineSensorDefaultArgs> = $Result.GetResult<Prisma.$MachineSensorPayload, S>

  type MachineSensorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MachineSensorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MachineSensorCountAggregateInputType | true
    }

  export interface MachineSensorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MachineSensor'], meta: { name: 'MachineSensor' } }
    /**
     * Find zero or one MachineSensor that matches the filter.
     * @param {MachineSensorFindUniqueArgs} args - Arguments to find a MachineSensor
     * @example
     * // Get one MachineSensor
     * const machineSensor = await prisma.machineSensor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineSensorFindUniqueArgs>(args: SelectSubset<T, MachineSensorFindUniqueArgs<ExtArgs>>): Prisma__MachineSensorClient<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MachineSensor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MachineSensorFindUniqueOrThrowArgs} args - Arguments to find a MachineSensor
     * @example
     * // Get one MachineSensor
     * const machineSensor = await prisma.machineSensor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineSensorFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineSensorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineSensorClient<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MachineSensor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSensorFindFirstArgs} args - Arguments to find a MachineSensor
     * @example
     * // Get one MachineSensor
     * const machineSensor = await prisma.machineSensor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineSensorFindFirstArgs>(args?: SelectSubset<T, MachineSensorFindFirstArgs<ExtArgs>>): Prisma__MachineSensorClient<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MachineSensor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSensorFindFirstOrThrowArgs} args - Arguments to find a MachineSensor
     * @example
     * // Get one MachineSensor
     * const machineSensor = await prisma.machineSensor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineSensorFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineSensorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineSensorClient<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MachineSensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSensorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MachineSensors
     * const machineSensors = await prisma.machineSensor.findMany()
     * 
     * // Get first 10 MachineSensors
     * const machineSensors = await prisma.machineSensor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineSensorWithIdOnly = await prisma.machineSensor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineSensorFindManyArgs>(args?: SelectSubset<T, MachineSensorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MachineSensor.
     * @param {MachineSensorCreateArgs} args - Arguments to create a MachineSensor.
     * @example
     * // Create one MachineSensor
     * const MachineSensor = await prisma.machineSensor.create({
     *   data: {
     *     // ... data to create a MachineSensor
     *   }
     * })
     * 
     */
    create<T extends MachineSensorCreateArgs>(args: SelectSubset<T, MachineSensorCreateArgs<ExtArgs>>): Prisma__MachineSensorClient<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MachineSensors.
     * @param {MachineSensorCreateManyArgs} args - Arguments to create many MachineSensors.
     * @example
     * // Create many MachineSensors
     * const machineSensor = await prisma.machineSensor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineSensorCreateManyArgs>(args?: SelectSubset<T, MachineSensorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MachineSensors and returns the data saved in the database.
     * @param {MachineSensorCreateManyAndReturnArgs} args - Arguments to create many MachineSensors.
     * @example
     * // Create many MachineSensors
     * const machineSensor = await prisma.machineSensor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MachineSensors and only return the `id`
     * const machineSensorWithIdOnly = await prisma.machineSensor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineSensorCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineSensorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MachineSensor.
     * @param {MachineSensorDeleteArgs} args - Arguments to delete one MachineSensor.
     * @example
     * // Delete one MachineSensor
     * const MachineSensor = await prisma.machineSensor.delete({
     *   where: {
     *     // ... filter to delete one MachineSensor
     *   }
     * })
     * 
     */
    delete<T extends MachineSensorDeleteArgs>(args: SelectSubset<T, MachineSensorDeleteArgs<ExtArgs>>): Prisma__MachineSensorClient<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MachineSensor.
     * @param {MachineSensorUpdateArgs} args - Arguments to update one MachineSensor.
     * @example
     * // Update one MachineSensor
     * const machineSensor = await prisma.machineSensor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineSensorUpdateArgs>(args: SelectSubset<T, MachineSensorUpdateArgs<ExtArgs>>): Prisma__MachineSensorClient<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MachineSensors.
     * @param {MachineSensorDeleteManyArgs} args - Arguments to filter MachineSensors to delete.
     * @example
     * // Delete a few MachineSensors
     * const { count } = await prisma.machineSensor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineSensorDeleteManyArgs>(args?: SelectSubset<T, MachineSensorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineSensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSensorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MachineSensors
     * const machineSensor = await prisma.machineSensor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineSensorUpdateManyArgs>(args: SelectSubset<T, MachineSensorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineSensors and returns the data updated in the database.
     * @param {MachineSensorUpdateManyAndReturnArgs} args - Arguments to update many MachineSensors.
     * @example
     * // Update many MachineSensors
     * const machineSensor = await prisma.machineSensor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MachineSensors and only return the `id`
     * const machineSensorWithIdOnly = await prisma.machineSensor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MachineSensorUpdateManyAndReturnArgs>(args: SelectSubset<T, MachineSensorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MachineSensor.
     * @param {MachineSensorUpsertArgs} args - Arguments to update or create a MachineSensor.
     * @example
     * // Update or create a MachineSensor
     * const machineSensor = await prisma.machineSensor.upsert({
     *   create: {
     *     // ... data to create a MachineSensor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MachineSensor we want to update
     *   }
     * })
     */
    upsert<T extends MachineSensorUpsertArgs>(args: SelectSubset<T, MachineSensorUpsertArgs<ExtArgs>>): Prisma__MachineSensorClient<$Result.GetResult<Prisma.$MachineSensorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MachineSensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSensorCountArgs} args - Arguments to filter MachineSensors to count.
     * @example
     * // Count the number of MachineSensors
     * const count = await prisma.machineSensor.count({
     *   where: {
     *     // ... the filter for the MachineSensors we want to count
     *   }
     * })
    **/
    count<T extends MachineSensorCountArgs>(
      args?: Subset<T, MachineSensorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineSensorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MachineSensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSensorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineSensorAggregateArgs>(args: Subset<T, MachineSensorAggregateArgs>): Prisma.PrismaPromise<GetMachineSensorAggregateType<T>>

    /**
     * Group by MachineSensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineSensorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineSensorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineSensorGroupByArgs['orderBy'] }
        : { orderBy?: MachineSensorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineSensorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineSensorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MachineSensor model
   */
  readonly fields: MachineSensorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MachineSensor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineSensorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MachineSensor model
   */
  interface MachineSensorFieldRefs {
    readonly id: FieldRef<"MachineSensor", 'String'>
    readonly machineId: FieldRef<"MachineSensor", 'String'>
    readonly sensorType: FieldRef<"MachineSensor", 'String'>
    readonly sensorName: FieldRef<"MachineSensor", 'String'>
    readonly value: FieldRef<"MachineSensor", 'Float'>
    readonly unit: FieldRef<"MachineSensor", 'String'>
    readonly threshold: FieldRef<"MachineSensor", 'Float'>
    readonly minValue: FieldRef<"MachineSensor", 'Float'>
    readonly maxValue: FieldRef<"MachineSensor", 'Float'>
    readonly status: FieldRef<"MachineSensor", 'String'>
    readonly timestamp: FieldRef<"MachineSensor", 'DateTime'>
    readonly createdAt: FieldRef<"MachineSensor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MachineSensor findUnique
   */
  export type MachineSensorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * Filter, which MachineSensor to fetch.
     */
    where: MachineSensorWhereUniqueInput
  }

  /**
   * MachineSensor findUniqueOrThrow
   */
  export type MachineSensorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * Filter, which MachineSensor to fetch.
     */
    where: MachineSensorWhereUniqueInput
  }

  /**
   * MachineSensor findFirst
   */
  export type MachineSensorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * Filter, which MachineSensor to fetch.
     */
    where?: MachineSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineSensors to fetch.
     */
    orderBy?: MachineSensorOrderByWithRelationInput | MachineSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineSensors.
     */
    cursor?: MachineSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineSensors.
     */
    distinct?: MachineSensorScalarFieldEnum | MachineSensorScalarFieldEnum[]
  }

  /**
   * MachineSensor findFirstOrThrow
   */
  export type MachineSensorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * Filter, which MachineSensor to fetch.
     */
    where?: MachineSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineSensors to fetch.
     */
    orderBy?: MachineSensorOrderByWithRelationInput | MachineSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineSensors.
     */
    cursor?: MachineSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineSensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineSensors.
     */
    distinct?: MachineSensorScalarFieldEnum | MachineSensorScalarFieldEnum[]
  }

  /**
   * MachineSensor findMany
   */
  export type MachineSensorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * Filter, which MachineSensors to fetch.
     */
    where?: MachineSensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineSensors to fetch.
     */
    orderBy?: MachineSensorOrderByWithRelationInput | MachineSensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MachineSensors.
     */
    cursor?: MachineSensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineSensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineSensors.
     */
    skip?: number
    distinct?: MachineSensorScalarFieldEnum | MachineSensorScalarFieldEnum[]
  }

  /**
   * MachineSensor create
   */
  export type MachineSensorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * The data needed to create a MachineSensor.
     */
    data: XOR<MachineSensorCreateInput, MachineSensorUncheckedCreateInput>
  }

  /**
   * MachineSensor createMany
   */
  export type MachineSensorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MachineSensors.
     */
    data: MachineSensorCreateManyInput | MachineSensorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MachineSensor createManyAndReturn
   */
  export type MachineSensorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * The data used to create many MachineSensors.
     */
    data: MachineSensorCreateManyInput | MachineSensorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MachineSensor update
   */
  export type MachineSensorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * The data needed to update a MachineSensor.
     */
    data: XOR<MachineSensorUpdateInput, MachineSensorUncheckedUpdateInput>
    /**
     * Choose, which MachineSensor to update.
     */
    where: MachineSensorWhereUniqueInput
  }

  /**
   * MachineSensor updateMany
   */
  export type MachineSensorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MachineSensors.
     */
    data: XOR<MachineSensorUpdateManyMutationInput, MachineSensorUncheckedUpdateManyInput>
    /**
     * Filter which MachineSensors to update
     */
    where?: MachineSensorWhereInput
    /**
     * Limit how many MachineSensors to update.
     */
    limit?: number
  }

  /**
   * MachineSensor updateManyAndReturn
   */
  export type MachineSensorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * The data used to update MachineSensors.
     */
    data: XOR<MachineSensorUpdateManyMutationInput, MachineSensorUncheckedUpdateManyInput>
    /**
     * Filter which MachineSensors to update
     */
    where?: MachineSensorWhereInput
    /**
     * Limit how many MachineSensors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MachineSensor upsert
   */
  export type MachineSensorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * The filter to search for the MachineSensor to update in case it exists.
     */
    where: MachineSensorWhereUniqueInput
    /**
     * In case the MachineSensor found by the `where` argument doesn't exist, create a new MachineSensor with this data.
     */
    create: XOR<MachineSensorCreateInput, MachineSensorUncheckedCreateInput>
    /**
     * In case the MachineSensor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineSensorUpdateInput, MachineSensorUncheckedUpdateInput>
  }

  /**
   * MachineSensor delete
   */
  export type MachineSensorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
    /**
     * Filter which MachineSensor to delete.
     */
    where: MachineSensorWhereUniqueInput
  }

  /**
   * MachineSensor deleteMany
   */
  export type MachineSensorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineSensors to delete
     */
    where?: MachineSensorWhereInput
    /**
     * Limit how many MachineSensors to delete.
     */
    limit?: number
  }

  /**
   * MachineSensor without action
   */
  export type MachineSensorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineSensor
     */
    select?: MachineSensorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineSensor
     */
    omit?: MachineSensorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineSensorInclude<ExtArgs> | null
  }


  /**
   * Model MachineAlert
   */

  export type AggregateMachineAlert = {
    _count: MachineAlertCountAggregateOutputType | null
    _min: MachineAlertMinAggregateOutputType | null
    _max: MachineAlertMaxAggregateOutputType | null
  }

  export type MachineAlertMinAggregateOutputType = {
    id: string | null
    machineId: string | null
    severity: string | null
    type: string | null
    title: string | null
    description: string | null
    acknowledged: boolean | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type MachineAlertMaxAggregateOutputType = {
    id: string | null
    machineId: string | null
    severity: string | null
    type: string | null
    title: string | null
    description: string | null
    acknowledged: boolean | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type MachineAlertCountAggregateOutputType = {
    id: number
    machineId: number
    severity: number
    type: number
    title: number
    description: number
    acknowledged: number
    acknowledgedBy: number
    acknowledgedAt: number
    resolvedAt: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type MachineAlertMinAggregateInputType = {
    id?: true
    machineId?: true
    severity?: true
    type?: true
    title?: true
    description?: true
    acknowledged?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type MachineAlertMaxAggregateInputType = {
    id?: true
    machineId?: true
    severity?: true
    type?: true
    title?: true
    description?: true
    acknowledged?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type MachineAlertCountAggregateInputType = {
    id?: true
    machineId?: true
    severity?: true
    type?: true
    title?: true
    description?: true
    acknowledged?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    resolvedAt?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type MachineAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineAlert to aggregate.
     */
    where?: MachineAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineAlerts to fetch.
     */
    orderBy?: MachineAlertOrderByWithRelationInput | MachineAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MachineAlerts
    **/
    _count?: true | MachineAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineAlertMaxAggregateInputType
  }

  export type GetMachineAlertAggregateType<T extends MachineAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateMachineAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachineAlert[P]>
      : GetScalarType<T[P], AggregateMachineAlert[P]>
  }




  export type MachineAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineAlertWhereInput
    orderBy?: MachineAlertOrderByWithAggregationInput | MachineAlertOrderByWithAggregationInput[]
    by: MachineAlertScalarFieldEnum[] | MachineAlertScalarFieldEnum
    having?: MachineAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineAlertCountAggregateInputType | true
    _min?: MachineAlertMinAggregateInputType
    _max?: MachineAlertMaxAggregateInputType
  }

  export type MachineAlertGroupByOutputType = {
    id: string
    machineId: string
    severity: string
    type: string
    title: string
    description: string | null
    acknowledged: boolean
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    resolvedAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    _count: MachineAlertCountAggregateOutputType | null
    _min: MachineAlertMinAggregateOutputType | null
    _max: MachineAlertMaxAggregateOutputType | null
  }

  type GetMachineAlertGroupByPayload<T extends MachineAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineAlertGroupByOutputType[P]>
            : GetScalarType<T[P], MachineAlertGroupByOutputType[P]>
        }
      >
    >


  export type MachineAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    severity?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    resolvedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineAlert"]>

  export type MachineAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    severity?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    resolvedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineAlert"]>

  export type MachineAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    severity?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    resolvedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineAlert"]>

  export type MachineAlertSelectScalar = {
    id?: boolean
    machineId?: boolean
    severity?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    acknowledged?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    resolvedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type MachineAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "machineId" | "severity" | "type" | "title" | "description" | "acknowledged" | "acknowledgedBy" | "acknowledgedAt" | "resolvedAt" | "metadata" | "createdAt", ExtArgs["result"]["machineAlert"]>
  export type MachineAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }
  export type MachineAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }
  export type MachineAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }

  export type $MachineAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MachineAlert"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      machineId: string
      severity: string
      type: string
      title: string
      description: string | null
      acknowledged: boolean
      acknowledgedBy: string | null
      acknowledgedAt: Date | null
      resolvedAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["machineAlert"]>
    composites: {}
  }

  type MachineAlertGetPayload<S extends boolean | null | undefined | MachineAlertDefaultArgs> = $Result.GetResult<Prisma.$MachineAlertPayload, S>

  type MachineAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MachineAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MachineAlertCountAggregateInputType | true
    }

  export interface MachineAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MachineAlert'], meta: { name: 'MachineAlert' } }
    /**
     * Find zero or one MachineAlert that matches the filter.
     * @param {MachineAlertFindUniqueArgs} args - Arguments to find a MachineAlert
     * @example
     * // Get one MachineAlert
     * const machineAlert = await prisma.machineAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineAlertFindUniqueArgs>(args: SelectSubset<T, MachineAlertFindUniqueArgs<ExtArgs>>): Prisma__MachineAlertClient<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MachineAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MachineAlertFindUniqueOrThrowArgs} args - Arguments to find a MachineAlert
     * @example
     * // Get one MachineAlert
     * const machineAlert = await prisma.machineAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineAlertClient<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MachineAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAlertFindFirstArgs} args - Arguments to find a MachineAlert
     * @example
     * // Get one MachineAlert
     * const machineAlert = await prisma.machineAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineAlertFindFirstArgs>(args?: SelectSubset<T, MachineAlertFindFirstArgs<ExtArgs>>): Prisma__MachineAlertClient<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MachineAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAlertFindFirstOrThrowArgs} args - Arguments to find a MachineAlert
     * @example
     * // Get one MachineAlert
     * const machineAlert = await prisma.machineAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineAlertClient<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MachineAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MachineAlerts
     * const machineAlerts = await prisma.machineAlert.findMany()
     * 
     * // Get first 10 MachineAlerts
     * const machineAlerts = await prisma.machineAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineAlertWithIdOnly = await prisma.machineAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineAlertFindManyArgs>(args?: SelectSubset<T, MachineAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MachineAlert.
     * @param {MachineAlertCreateArgs} args - Arguments to create a MachineAlert.
     * @example
     * // Create one MachineAlert
     * const MachineAlert = await prisma.machineAlert.create({
     *   data: {
     *     // ... data to create a MachineAlert
     *   }
     * })
     * 
     */
    create<T extends MachineAlertCreateArgs>(args: SelectSubset<T, MachineAlertCreateArgs<ExtArgs>>): Prisma__MachineAlertClient<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MachineAlerts.
     * @param {MachineAlertCreateManyArgs} args - Arguments to create many MachineAlerts.
     * @example
     * // Create many MachineAlerts
     * const machineAlert = await prisma.machineAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineAlertCreateManyArgs>(args?: SelectSubset<T, MachineAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MachineAlerts and returns the data saved in the database.
     * @param {MachineAlertCreateManyAndReturnArgs} args - Arguments to create many MachineAlerts.
     * @example
     * // Create many MachineAlerts
     * const machineAlert = await prisma.machineAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MachineAlerts and only return the `id`
     * const machineAlertWithIdOnly = await prisma.machineAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MachineAlert.
     * @param {MachineAlertDeleteArgs} args - Arguments to delete one MachineAlert.
     * @example
     * // Delete one MachineAlert
     * const MachineAlert = await prisma.machineAlert.delete({
     *   where: {
     *     // ... filter to delete one MachineAlert
     *   }
     * })
     * 
     */
    delete<T extends MachineAlertDeleteArgs>(args: SelectSubset<T, MachineAlertDeleteArgs<ExtArgs>>): Prisma__MachineAlertClient<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MachineAlert.
     * @param {MachineAlertUpdateArgs} args - Arguments to update one MachineAlert.
     * @example
     * // Update one MachineAlert
     * const machineAlert = await prisma.machineAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineAlertUpdateArgs>(args: SelectSubset<T, MachineAlertUpdateArgs<ExtArgs>>): Prisma__MachineAlertClient<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MachineAlerts.
     * @param {MachineAlertDeleteManyArgs} args - Arguments to filter MachineAlerts to delete.
     * @example
     * // Delete a few MachineAlerts
     * const { count } = await prisma.machineAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineAlertDeleteManyArgs>(args?: SelectSubset<T, MachineAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MachineAlerts
     * const machineAlert = await prisma.machineAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineAlertUpdateManyArgs>(args: SelectSubset<T, MachineAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineAlerts and returns the data updated in the database.
     * @param {MachineAlertUpdateManyAndReturnArgs} args - Arguments to update many MachineAlerts.
     * @example
     * // Update many MachineAlerts
     * const machineAlert = await prisma.machineAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MachineAlerts and only return the `id`
     * const machineAlertWithIdOnly = await prisma.machineAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MachineAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, MachineAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MachineAlert.
     * @param {MachineAlertUpsertArgs} args - Arguments to update or create a MachineAlert.
     * @example
     * // Update or create a MachineAlert
     * const machineAlert = await prisma.machineAlert.upsert({
     *   create: {
     *     // ... data to create a MachineAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MachineAlert we want to update
     *   }
     * })
     */
    upsert<T extends MachineAlertUpsertArgs>(args: SelectSubset<T, MachineAlertUpsertArgs<ExtArgs>>): Prisma__MachineAlertClient<$Result.GetResult<Prisma.$MachineAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MachineAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAlertCountArgs} args - Arguments to filter MachineAlerts to count.
     * @example
     * // Count the number of MachineAlerts
     * const count = await prisma.machineAlert.count({
     *   where: {
     *     // ... the filter for the MachineAlerts we want to count
     *   }
     * })
    **/
    count<T extends MachineAlertCountArgs>(
      args?: Subset<T, MachineAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MachineAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineAlertAggregateArgs>(args: Subset<T, MachineAlertAggregateArgs>): Prisma.PrismaPromise<GetMachineAlertAggregateType<T>>

    /**
     * Group by MachineAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineAlertGroupByArgs['orderBy'] }
        : { orderBy?: MachineAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MachineAlert model
   */
  readonly fields: MachineAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MachineAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MachineAlert model
   */
  interface MachineAlertFieldRefs {
    readonly id: FieldRef<"MachineAlert", 'String'>
    readonly machineId: FieldRef<"MachineAlert", 'String'>
    readonly severity: FieldRef<"MachineAlert", 'String'>
    readonly type: FieldRef<"MachineAlert", 'String'>
    readonly title: FieldRef<"MachineAlert", 'String'>
    readonly description: FieldRef<"MachineAlert", 'String'>
    readonly acknowledged: FieldRef<"MachineAlert", 'Boolean'>
    readonly acknowledgedBy: FieldRef<"MachineAlert", 'String'>
    readonly acknowledgedAt: FieldRef<"MachineAlert", 'DateTime'>
    readonly resolvedAt: FieldRef<"MachineAlert", 'DateTime'>
    readonly metadata: FieldRef<"MachineAlert", 'Json'>
    readonly createdAt: FieldRef<"MachineAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MachineAlert findUnique
   */
  export type MachineAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * Filter, which MachineAlert to fetch.
     */
    where: MachineAlertWhereUniqueInput
  }

  /**
   * MachineAlert findUniqueOrThrow
   */
  export type MachineAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * Filter, which MachineAlert to fetch.
     */
    where: MachineAlertWhereUniqueInput
  }

  /**
   * MachineAlert findFirst
   */
  export type MachineAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * Filter, which MachineAlert to fetch.
     */
    where?: MachineAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineAlerts to fetch.
     */
    orderBy?: MachineAlertOrderByWithRelationInput | MachineAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineAlerts.
     */
    cursor?: MachineAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineAlerts.
     */
    distinct?: MachineAlertScalarFieldEnum | MachineAlertScalarFieldEnum[]
  }

  /**
   * MachineAlert findFirstOrThrow
   */
  export type MachineAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * Filter, which MachineAlert to fetch.
     */
    where?: MachineAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineAlerts to fetch.
     */
    orderBy?: MachineAlertOrderByWithRelationInput | MachineAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineAlerts.
     */
    cursor?: MachineAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineAlerts.
     */
    distinct?: MachineAlertScalarFieldEnum | MachineAlertScalarFieldEnum[]
  }

  /**
   * MachineAlert findMany
   */
  export type MachineAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * Filter, which MachineAlerts to fetch.
     */
    where?: MachineAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineAlerts to fetch.
     */
    orderBy?: MachineAlertOrderByWithRelationInput | MachineAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MachineAlerts.
     */
    cursor?: MachineAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineAlerts.
     */
    skip?: number
    distinct?: MachineAlertScalarFieldEnum | MachineAlertScalarFieldEnum[]
  }

  /**
   * MachineAlert create
   */
  export type MachineAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a MachineAlert.
     */
    data: XOR<MachineAlertCreateInput, MachineAlertUncheckedCreateInput>
  }

  /**
   * MachineAlert createMany
   */
  export type MachineAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MachineAlerts.
     */
    data: MachineAlertCreateManyInput | MachineAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MachineAlert createManyAndReturn
   */
  export type MachineAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * The data used to create many MachineAlerts.
     */
    data: MachineAlertCreateManyInput | MachineAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MachineAlert update
   */
  export type MachineAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a MachineAlert.
     */
    data: XOR<MachineAlertUpdateInput, MachineAlertUncheckedUpdateInput>
    /**
     * Choose, which MachineAlert to update.
     */
    where: MachineAlertWhereUniqueInput
  }

  /**
   * MachineAlert updateMany
   */
  export type MachineAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MachineAlerts.
     */
    data: XOR<MachineAlertUpdateManyMutationInput, MachineAlertUncheckedUpdateManyInput>
    /**
     * Filter which MachineAlerts to update
     */
    where?: MachineAlertWhereInput
    /**
     * Limit how many MachineAlerts to update.
     */
    limit?: number
  }

  /**
   * MachineAlert updateManyAndReturn
   */
  export type MachineAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * The data used to update MachineAlerts.
     */
    data: XOR<MachineAlertUpdateManyMutationInput, MachineAlertUncheckedUpdateManyInput>
    /**
     * Filter which MachineAlerts to update
     */
    where?: MachineAlertWhereInput
    /**
     * Limit how many MachineAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MachineAlert upsert
   */
  export type MachineAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the MachineAlert to update in case it exists.
     */
    where: MachineAlertWhereUniqueInput
    /**
     * In case the MachineAlert found by the `where` argument doesn't exist, create a new MachineAlert with this data.
     */
    create: XOR<MachineAlertCreateInput, MachineAlertUncheckedCreateInput>
    /**
     * In case the MachineAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineAlertUpdateInput, MachineAlertUncheckedUpdateInput>
  }

  /**
   * MachineAlert delete
   */
  export type MachineAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
    /**
     * Filter which MachineAlert to delete.
     */
    where: MachineAlertWhereUniqueInput
  }

  /**
   * MachineAlert deleteMany
   */
  export type MachineAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineAlerts to delete
     */
    where?: MachineAlertWhereInput
    /**
     * Limit how many MachineAlerts to delete.
     */
    limit?: number
  }

  /**
   * MachineAlert without action
   */
  export type MachineAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineAlert
     */
    select?: MachineAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineAlert
     */
    omit?: MachineAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineAlertInclude<ExtArgs> | null
  }


  /**
   * Model MachineMaintenanceRecord
   */

  export type AggregateMachineMaintenanceRecord = {
    _count: MachineMaintenanceRecordCountAggregateOutputType | null
    _avg: MachineMaintenanceRecordAvgAggregateOutputType | null
    _sum: MachineMaintenanceRecordSumAggregateOutputType | null
    _min: MachineMaintenanceRecordMinAggregateOutputType | null
    _max: MachineMaintenanceRecordMaxAggregateOutputType | null
  }

  export type MachineMaintenanceRecordAvgAggregateOutputType = {
    duration: number | null
    cost: number | null
  }

  export type MachineMaintenanceRecordSumAggregateOutputType = {
    duration: number | null
    cost: number | null
  }

  export type MachineMaintenanceRecordMinAggregateOutputType = {
    id: string | null
    machineId: string | null
    type: string | null
    description: string | null
    performedBy: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    duration: number | null
    cost: number | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MachineMaintenanceRecordMaxAggregateOutputType = {
    id: string | null
    machineId: string | null
    type: string | null
    description: string | null
    performedBy: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    duration: number | null
    cost: number | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MachineMaintenanceRecordCountAggregateOutputType = {
    id: number
    machineId: number
    type: number
    description: number
    performedBy: number
    scheduledDate: number
    completedDate: number
    duration: number
    cost: number
    status: number
    notes: number
    attachments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MachineMaintenanceRecordAvgAggregateInputType = {
    duration?: true
    cost?: true
  }

  export type MachineMaintenanceRecordSumAggregateInputType = {
    duration?: true
    cost?: true
  }

  export type MachineMaintenanceRecordMinAggregateInputType = {
    id?: true
    machineId?: true
    type?: true
    description?: true
    performedBy?: true
    scheduledDate?: true
    completedDate?: true
    duration?: true
    cost?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MachineMaintenanceRecordMaxAggregateInputType = {
    id?: true
    machineId?: true
    type?: true
    description?: true
    performedBy?: true
    scheduledDate?: true
    completedDate?: true
    duration?: true
    cost?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MachineMaintenanceRecordCountAggregateInputType = {
    id?: true
    machineId?: true
    type?: true
    description?: true
    performedBy?: true
    scheduledDate?: true
    completedDate?: true
    duration?: true
    cost?: true
    status?: true
    notes?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MachineMaintenanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineMaintenanceRecord to aggregate.
     */
    where?: MachineMaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineMaintenanceRecords to fetch.
     */
    orderBy?: MachineMaintenanceRecordOrderByWithRelationInput | MachineMaintenanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineMaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineMaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineMaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MachineMaintenanceRecords
    **/
    _count?: true | MachineMaintenanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineMaintenanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineMaintenanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMaintenanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMaintenanceRecordMaxAggregateInputType
  }

  export type GetMachineMaintenanceRecordAggregateType<T extends MachineMaintenanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateMachineMaintenanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachineMaintenanceRecord[P]>
      : GetScalarType<T[P], AggregateMachineMaintenanceRecord[P]>
  }




  export type MachineMaintenanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineMaintenanceRecordWhereInput
    orderBy?: MachineMaintenanceRecordOrderByWithAggregationInput | MachineMaintenanceRecordOrderByWithAggregationInput[]
    by: MachineMaintenanceRecordScalarFieldEnum[] | MachineMaintenanceRecordScalarFieldEnum
    having?: MachineMaintenanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineMaintenanceRecordCountAggregateInputType | true
    _avg?: MachineMaintenanceRecordAvgAggregateInputType
    _sum?: MachineMaintenanceRecordSumAggregateInputType
    _min?: MachineMaintenanceRecordMinAggregateInputType
    _max?: MachineMaintenanceRecordMaxAggregateInputType
  }

  export type MachineMaintenanceRecordGroupByOutputType = {
    id: string
    machineId: string
    type: string
    description: string
    performedBy: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    duration: number | null
    cost: number | null
    status: string
    notes: string | null
    attachments: string[]
    createdAt: Date
    updatedAt: Date
    _count: MachineMaintenanceRecordCountAggregateOutputType | null
    _avg: MachineMaintenanceRecordAvgAggregateOutputType | null
    _sum: MachineMaintenanceRecordSumAggregateOutputType | null
    _min: MachineMaintenanceRecordMinAggregateOutputType | null
    _max: MachineMaintenanceRecordMaxAggregateOutputType | null
  }

  type GetMachineMaintenanceRecordGroupByPayload<T extends MachineMaintenanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineMaintenanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineMaintenanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineMaintenanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], MachineMaintenanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type MachineMaintenanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    type?: boolean
    description?: boolean
    performedBy?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    duration?: boolean
    cost?: boolean
    status?: boolean
    notes?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineMaintenanceRecord"]>

  export type MachineMaintenanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    type?: boolean
    description?: boolean
    performedBy?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    duration?: boolean
    cost?: boolean
    status?: boolean
    notes?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineMaintenanceRecord"]>

  export type MachineMaintenanceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    machineId?: boolean
    type?: boolean
    description?: boolean
    performedBy?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    duration?: boolean
    cost?: boolean
    status?: boolean
    notes?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machineMaintenanceRecord"]>

  export type MachineMaintenanceRecordSelectScalar = {
    id?: boolean
    machineId?: boolean
    type?: boolean
    description?: boolean
    performedBy?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    duration?: boolean
    cost?: boolean
    status?: boolean
    notes?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MachineMaintenanceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "machineId" | "type" | "description" | "performedBy" | "scheduledDate" | "completedDate" | "duration" | "cost" | "status" | "notes" | "attachments" | "createdAt" | "updatedAt", ExtArgs["result"]["machineMaintenanceRecord"]>
  export type MachineMaintenanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }
  export type MachineMaintenanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }
  export type MachineMaintenanceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }

  export type $MachineMaintenanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MachineMaintenanceRecord"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      machineId: string
      type: string
      description: string
      performedBy: string | null
      scheduledDate: Date | null
      completedDate: Date | null
      duration: number | null
      cost: number | null
      status: string
      notes: string | null
      attachments: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["machineMaintenanceRecord"]>
    composites: {}
  }

  type MachineMaintenanceRecordGetPayload<S extends boolean | null | undefined | MachineMaintenanceRecordDefaultArgs> = $Result.GetResult<Prisma.$MachineMaintenanceRecordPayload, S>

  type MachineMaintenanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MachineMaintenanceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MachineMaintenanceRecordCountAggregateInputType | true
    }

  export interface MachineMaintenanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MachineMaintenanceRecord'], meta: { name: 'MachineMaintenanceRecord' } }
    /**
     * Find zero or one MachineMaintenanceRecord that matches the filter.
     * @param {MachineMaintenanceRecordFindUniqueArgs} args - Arguments to find a MachineMaintenanceRecord
     * @example
     * // Get one MachineMaintenanceRecord
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineMaintenanceRecordFindUniqueArgs>(args: SelectSubset<T, MachineMaintenanceRecordFindUniqueArgs<ExtArgs>>): Prisma__MachineMaintenanceRecordClient<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MachineMaintenanceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MachineMaintenanceRecordFindUniqueOrThrowArgs} args - Arguments to find a MachineMaintenanceRecord
     * @example
     * // Get one MachineMaintenanceRecord
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineMaintenanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineMaintenanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineMaintenanceRecordClient<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MachineMaintenanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMaintenanceRecordFindFirstArgs} args - Arguments to find a MachineMaintenanceRecord
     * @example
     * // Get one MachineMaintenanceRecord
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineMaintenanceRecordFindFirstArgs>(args?: SelectSubset<T, MachineMaintenanceRecordFindFirstArgs<ExtArgs>>): Prisma__MachineMaintenanceRecordClient<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MachineMaintenanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMaintenanceRecordFindFirstOrThrowArgs} args - Arguments to find a MachineMaintenanceRecord
     * @example
     * // Get one MachineMaintenanceRecord
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineMaintenanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineMaintenanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineMaintenanceRecordClient<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MachineMaintenanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMaintenanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MachineMaintenanceRecords
     * const machineMaintenanceRecords = await prisma.machineMaintenanceRecord.findMany()
     * 
     * // Get first 10 MachineMaintenanceRecords
     * const machineMaintenanceRecords = await prisma.machineMaintenanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineMaintenanceRecordWithIdOnly = await prisma.machineMaintenanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineMaintenanceRecordFindManyArgs>(args?: SelectSubset<T, MachineMaintenanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MachineMaintenanceRecord.
     * @param {MachineMaintenanceRecordCreateArgs} args - Arguments to create a MachineMaintenanceRecord.
     * @example
     * // Create one MachineMaintenanceRecord
     * const MachineMaintenanceRecord = await prisma.machineMaintenanceRecord.create({
     *   data: {
     *     // ... data to create a MachineMaintenanceRecord
     *   }
     * })
     * 
     */
    create<T extends MachineMaintenanceRecordCreateArgs>(args: SelectSubset<T, MachineMaintenanceRecordCreateArgs<ExtArgs>>): Prisma__MachineMaintenanceRecordClient<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MachineMaintenanceRecords.
     * @param {MachineMaintenanceRecordCreateManyArgs} args - Arguments to create many MachineMaintenanceRecords.
     * @example
     * // Create many MachineMaintenanceRecords
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineMaintenanceRecordCreateManyArgs>(args?: SelectSubset<T, MachineMaintenanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MachineMaintenanceRecords and returns the data saved in the database.
     * @param {MachineMaintenanceRecordCreateManyAndReturnArgs} args - Arguments to create many MachineMaintenanceRecords.
     * @example
     * // Create many MachineMaintenanceRecords
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MachineMaintenanceRecords and only return the `id`
     * const machineMaintenanceRecordWithIdOnly = await prisma.machineMaintenanceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineMaintenanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineMaintenanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MachineMaintenanceRecord.
     * @param {MachineMaintenanceRecordDeleteArgs} args - Arguments to delete one MachineMaintenanceRecord.
     * @example
     * // Delete one MachineMaintenanceRecord
     * const MachineMaintenanceRecord = await prisma.machineMaintenanceRecord.delete({
     *   where: {
     *     // ... filter to delete one MachineMaintenanceRecord
     *   }
     * })
     * 
     */
    delete<T extends MachineMaintenanceRecordDeleteArgs>(args: SelectSubset<T, MachineMaintenanceRecordDeleteArgs<ExtArgs>>): Prisma__MachineMaintenanceRecordClient<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MachineMaintenanceRecord.
     * @param {MachineMaintenanceRecordUpdateArgs} args - Arguments to update one MachineMaintenanceRecord.
     * @example
     * // Update one MachineMaintenanceRecord
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineMaintenanceRecordUpdateArgs>(args: SelectSubset<T, MachineMaintenanceRecordUpdateArgs<ExtArgs>>): Prisma__MachineMaintenanceRecordClient<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MachineMaintenanceRecords.
     * @param {MachineMaintenanceRecordDeleteManyArgs} args - Arguments to filter MachineMaintenanceRecords to delete.
     * @example
     * // Delete a few MachineMaintenanceRecords
     * const { count } = await prisma.machineMaintenanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineMaintenanceRecordDeleteManyArgs>(args?: SelectSubset<T, MachineMaintenanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineMaintenanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMaintenanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MachineMaintenanceRecords
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineMaintenanceRecordUpdateManyArgs>(args: SelectSubset<T, MachineMaintenanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MachineMaintenanceRecords and returns the data updated in the database.
     * @param {MachineMaintenanceRecordUpdateManyAndReturnArgs} args - Arguments to update many MachineMaintenanceRecords.
     * @example
     * // Update many MachineMaintenanceRecords
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MachineMaintenanceRecords and only return the `id`
     * const machineMaintenanceRecordWithIdOnly = await prisma.machineMaintenanceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MachineMaintenanceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, MachineMaintenanceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MachineMaintenanceRecord.
     * @param {MachineMaintenanceRecordUpsertArgs} args - Arguments to update or create a MachineMaintenanceRecord.
     * @example
     * // Update or create a MachineMaintenanceRecord
     * const machineMaintenanceRecord = await prisma.machineMaintenanceRecord.upsert({
     *   create: {
     *     // ... data to create a MachineMaintenanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MachineMaintenanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends MachineMaintenanceRecordUpsertArgs>(args: SelectSubset<T, MachineMaintenanceRecordUpsertArgs<ExtArgs>>): Prisma__MachineMaintenanceRecordClient<$Result.GetResult<Prisma.$MachineMaintenanceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MachineMaintenanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMaintenanceRecordCountArgs} args - Arguments to filter MachineMaintenanceRecords to count.
     * @example
     * // Count the number of MachineMaintenanceRecords
     * const count = await prisma.machineMaintenanceRecord.count({
     *   where: {
     *     // ... the filter for the MachineMaintenanceRecords we want to count
     *   }
     * })
    **/
    count<T extends MachineMaintenanceRecordCountArgs>(
      args?: Subset<T, MachineMaintenanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineMaintenanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MachineMaintenanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMaintenanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineMaintenanceRecordAggregateArgs>(args: Subset<T, MachineMaintenanceRecordAggregateArgs>): Prisma.PrismaPromise<GetMachineMaintenanceRecordAggregateType<T>>

    /**
     * Group by MachineMaintenanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineMaintenanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineMaintenanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineMaintenanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: MachineMaintenanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineMaintenanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineMaintenanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MachineMaintenanceRecord model
   */
  readonly fields: MachineMaintenanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MachineMaintenanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineMaintenanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MachineMaintenanceRecord model
   */
  interface MachineMaintenanceRecordFieldRefs {
    readonly id: FieldRef<"MachineMaintenanceRecord", 'String'>
    readonly machineId: FieldRef<"MachineMaintenanceRecord", 'String'>
    readonly type: FieldRef<"MachineMaintenanceRecord", 'String'>
    readonly description: FieldRef<"MachineMaintenanceRecord", 'String'>
    readonly performedBy: FieldRef<"MachineMaintenanceRecord", 'String'>
    readonly scheduledDate: FieldRef<"MachineMaintenanceRecord", 'DateTime'>
    readonly completedDate: FieldRef<"MachineMaintenanceRecord", 'DateTime'>
    readonly duration: FieldRef<"MachineMaintenanceRecord", 'Int'>
    readonly cost: FieldRef<"MachineMaintenanceRecord", 'Float'>
    readonly status: FieldRef<"MachineMaintenanceRecord", 'String'>
    readonly notes: FieldRef<"MachineMaintenanceRecord", 'String'>
    readonly attachments: FieldRef<"MachineMaintenanceRecord", 'String[]'>
    readonly createdAt: FieldRef<"MachineMaintenanceRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"MachineMaintenanceRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MachineMaintenanceRecord findUnique
   */
  export type MachineMaintenanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MachineMaintenanceRecord to fetch.
     */
    where: MachineMaintenanceRecordWhereUniqueInput
  }

  /**
   * MachineMaintenanceRecord findUniqueOrThrow
   */
  export type MachineMaintenanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MachineMaintenanceRecord to fetch.
     */
    where: MachineMaintenanceRecordWhereUniqueInput
  }

  /**
   * MachineMaintenanceRecord findFirst
   */
  export type MachineMaintenanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MachineMaintenanceRecord to fetch.
     */
    where?: MachineMaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineMaintenanceRecords to fetch.
     */
    orderBy?: MachineMaintenanceRecordOrderByWithRelationInput | MachineMaintenanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineMaintenanceRecords.
     */
    cursor?: MachineMaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineMaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineMaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineMaintenanceRecords.
     */
    distinct?: MachineMaintenanceRecordScalarFieldEnum | MachineMaintenanceRecordScalarFieldEnum[]
  }

  /**
   * MachineMaintenanceRecord findFirstOrThrow
   */
  export type MachineMaintenanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MachineMaintenanceRecord to fetch.
     */
    where?: MachineMaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineMaintenanceRecords to fetch.
     */
    orderBy?: MachineMaintenanceRecordOrderByWithRelationInput | MachineMaintenanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MachineMaintenanceRecords.
     */
    cursor?: MachineMaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineMaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineMaintenanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MachineMaintenanceRecords.
     */
    distinct?: MachineMaintenanceRecordScalarFieldEnum | MachineMaintenanceRecordScalarFieldEnum[]
  }

  /**
   * MachineMaintenanceRecord findMany
   */
  export type MachineMaintenanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which MachineMaintenanceRecords to fetch.
     */
    where?: MachineMaintenanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MachineMaintenanceRecords to fetch.
     */
    orderBy?: MachineMaintenanceRecordOrderByWithRelationInput | MachineMaintenanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MachineMaintenanceRecords.
     */
    cursor?: MachineMaintenanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MachineMaintenanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MachineMaintenanceRecords.
     */
    skip?: number
    distinct?: MachineMaintenanceRecordScalarFieldEnum | MachineMaintenanceRecordScalarFieldEnum[]
  }

  /**
   * MachineMaintenanceRecord create
   */
  export type MachineMaintenanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a MachineMaintenanceRecord.
     */
    data: XOR<MachineMaintenanceRecordCreateInput, MachineMaintenanceRecordUncheckedCreateInput>
  }

  /**
   * MachineMaintenanceRecord createMany
   */
  export type MachineMaintenanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MachineMaintenanceRecords.
     */
    data: MachineMaintenanceRecordCreateManyInput | MachineMaintenanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MachineMaintenanceRecord createManyAndReturn
   */
  export type MachineMaintenanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many MachineMaintenanceRecords.
     */
    data: MachineMaintenanceRecordCreateManyInput | MachineMaintenanceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MachineMaintenanceRecord update
   */
  export type MachineMaintenanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a MachineMaintenanceRecord.
     */
    data: XOR<MachineMaintenanceRecordUpdateInput, MachineMaintenanceRecordUncheckedUpdateInput>
    /**
     * Choose, which MachineMaintenanceRecord to update.
     */
    where: MachineMaintenanceRecordWhereUniqueInput
  }

  /**
   * MachineMaintenanceRecord updateMany
   */
  export type MachineMaintenanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MachineMaintenanceRecords.
     */
    data: XOR<MachineMaintenanceRecordUpdateManyMutationInput, MachineMaintenanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which MachineMaintenanceRecords to update
     */
    where?: MachineMaintenanceRecordWhereInput
    /**
     * Limit how many MachineMaintenanceRecords to update.
     */
    limit?: number
  }

  /**
   * MachineMaintenanceRecord updateManyAndReturn
   */
  export type MachineMaintenanceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * The data used to update MachineMaintenanceRecords.
     */
    data: XOR<MachineMaintenanceRecordUpdateManyMutationInput, MachineMaintenanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which MachineMaintenanceRecords to update
     */
    where?: MachineMaintenanceRecordWhereInput
    /**
     * Limit how many MachineMaintenanceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MachineMaintenanceRecord upsert
   */
  export type MachineMaintenanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the MachineMaintenanceRecord to update in case it exists.
     */
    where: MachineMaintenanceRecordWhereUniqueInput
    /**
     * In case the MachineMaintenanceRecord found by the `where` argument doesn't exist, create a new MachineMaintenanceRecord with this data.
     */
    create: XOR<MachineMaintenanceRecordCreateInput, MachineMaintenanceRecordUncheckedCreateInput>
    /**
     * In case the MachineMaintenanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineMaintenanceRecordUpdateInput, MachineMaintenanceRecordUncheckedUpdateInput>
  }

  /**
   * MachineMaintenanceRecord delete
   */
  export type MachineMaintenanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
    /**
     * Filter which MachineMaintenanceRecord to delete.
     */
    where: MachineMaintenanceRecordWhereUniqueInput
  }

  /**
   * MachineMaintenanceRecord deleteMany
   */
  export type MachineMaintenanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MachineMaintenanceRecords to delete
     */
    where?: MachineMaintenanceRecordWhereInput
    /**
     * Limit how many MachineMaintenanceRecords to delete.
     */
    limit?: number
  }

  /**
   * MachineMaintenanceRecord without action
   */
  export type MachineMaintenanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineMaintenanceRecord
     */
    select?: MachineMaintenanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MachineMaintenanceRecord
     */
    omit?: MachineMaintenanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineMaintenanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model QualityCheck
   */

  export type AggregateQualityCheck = {
    _count: QualityCheckCountAggregateOutputType | null
    _avg: QualityCheckAvgAggregateOutputType | null
    _sum: QualityCheckSumAggregateOutputType | null
    _min: QualityCheckMinAggregateOutputType | null
    _max: QualityCheckMaxAggregateOutputType | null
  }

  export type QualityCheckAvgAggregateOutputType = {
    score: number | null
    defectCount: number | null
    sampleSize: number | null
  }

  export type QualityCheckSumAggregateOutputType = {
    score: number | null
    defectCount: number | null
    sampleSize: number | null
  }

  export type QualityCheckMinAggregateOutputType = {
    id: string | null
    productionId: string | null
    checkType: string | null
    checkDate: Date | null
    inspector: string | null
    passed: boolean | null
    score: number | null
    defectCount: number | null
    sampleSize: number | null
    notes: string | null
    corrective: string | null
    createdAt: Date | null
  }

  export type QualityCheckMaxAggregateOutputType = {
    id: string | null
    productionId: string | null
    checkType: string | null
    checkDate: Date | null
    inspector: string | null
    passed: boolean | null
    score: number | null
    defectCount: number | null
    sampleSize: number | null
    notes: string | null
    corrective: string | null
    createdAt: Date | null
  }

  export type QualityCheckCountAggregateOutputType = {
    id: number
    productionId: number
    checkType: number
    checkDate: number
    inspector: number
    passed: number
    score: number
    defectCount: number
    sampleSize: number
    notes: number
    corrective: number
    attachments: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type QualityCheckAvgAggregateInputType = {
    score?: true
    defectCount?: true
    sampleSize?: true
  }

  export type QualityCheckSumAggregateInputType = {
    score?: true
    defectCount?: true
    sampleSize?: true
  }

  export type QualityCheckMinAggregateInputType = {
    id?: true
    productionId?: true
    checkType?: true
    checkDate?: true
    inspector?: true
    passed?: true
    score?: true
    defectCount?: true
    sampleSize?: true
    notes?: true
    corrective?: true
    createdAt?: true
  }

  export type QualityCheckMaxAggregateInputType = {
    id?: true
    productionId?: true
    checkType?: true
    checkDate?: true
    inspector?: true
    passed?: true
    score?: true
    defectCount?: true
    sampleSize?: true
    notes?: true
    corrective?: true
    createdAt?: true
  }

  export type QualityCheckCountAggregateInputType = {
    id?: true
    productionId?: true
    checkType?: true
    checkDate?: true
    inspector?: true
    passed?: true
    score?: true
    defectCount?: true
    sampleSize?: true
    notes?: true
    corrective?: true
    attachments?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type QualityCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityCheck to aggregate.
     */
    where?: QualityCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityChecks to fetch.
     */
    orderBy?: QualityCheckOrderByWithRelationInput | QualityCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QualityCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QualityChecks
    **/
    _count?: true | QualityCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualityCheckAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualityCheckSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualityCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualityCheckMaxAggregateInputType
  }

  export type GetQualityCheckAggregateType<T extends QualityCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateQualityCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualityCheck[P]>
      : GetScalarType<T[P], AggregateQualityCheck[P]>
  }




  export type QualityCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityCheckWhereInput
    orderBy?: QualityCheckOrderByWithAggregationInput | QualityCheckOrderByWithAggregationInput[]
    by: QualityCheckScalarFieldEnum[] | QualityCheckScalarFieldEnum
    having?: QualityCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualityCheckCountAggregateInputType | true
    _avg?: QualityCheckAvgAggregateInputType
    _sum?: QualityCheckSumAggregateInputType
    _min?: QualityCheckMinAggregateInputType
    _max?: QualityCheckMaxAggregateInputType
  }

  export type QualityCheckGroupByOutputType = {
    id: string
    productionId: string | null
    checkType: string
    checkDate: Date
    inspector: string | null
    passed: boolean
    score: number | null
    defectCount: number
    sampleSize: number | null
    notes: string | null
    corrective: string | null
    attachments: string[]
    metadata: JsonValue | null
    createdAt: Date
    _count: QualityCheckCountAggregateOutputType | null
    _avg: QualityCheckAvgAggregateOutputType | null
    _sum: QualityCheckSumAggregateOutputType | null
    _min: QualityCheckMinAggregateOutputType | null
    _max: QualityCheckMaxAggregateOutputType | null
  }

  type GetQualityCheckGroupByPayload<T extends QualityCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QualityCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualityCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualityCheckGroupByOutputType[P]>
            : GetScalarType<T[P], QualityCheckGroupByOutputType[P]>
        }
      >
    >


  export type QualityCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    checkType?: boolean
    checkDate?: boolean
    inspector?: boolean
    passed?: boolean
    score?: boolean
    defectCount?: boolean
    sampleSize?: boolean
    notes?: boolean
    corrective?: boolean
    attachments?: boolean
    metadata?: boolean
    createdAt?: boolean
    production?: boolean | QualityCheck$productionArgs<ExtArgs>
  }, ExtArgs["result"]["qualityCheck"]>

  export type QualityCheckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    checkType?: boolean
    checkDate?: boolean
    inspector?: boolean
    passed?: boolean
    score?: boolean
    defectCount?: boolean
    sampleSize?: boolean
    notes?: boolean
    corrective?: boolean
    attachments?: boolean
    metadata?: boolean
    createdAt?: boolean
    production?: boolean | QualityCheck$productionArgs<ExtArgs>
  }, ExtArgs["result"]["qualityCheck"]>

  export type QualityCheckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionId?: boolean
    checkType?: boolean
    checkDate?: boolean
    inspector?: boolean
    passed?: boolean
    score?: boolean
    defectCount?: boolean
    sampleSize?: boolean
    notes?: boolean
    corrective?: boolean
    attachments?: boolean
    metadata?: boolean
    createdAt?: boolean
    production?: boolean | QualityCheck$productionArgs<ExtArgs>
  }, ExtArgs["result"]["qualityCheck"]>

  export type QualityCheckSelectScalar = {
    id?: boolean
    productionId?: boolean
    checkType?: boolean
    checkDate?: boolean
    inspector?: boolean
    passed?: boolean
    score?: boolean
    defectCount?: boolean
    sampleSize?: boolean
    notes?: boolean
    corrective?: boolean
    attachments?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type QualityCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productionId" | "checkType" | "checkDate" | "inspector" | "passed" | "score" | "defectCount" | "sampleSize" | "notes" | "corrective" | "attachments" | "metadata" | "createdAt", ExtArgs["result"]["qualityCheck"]>
  export type QualityCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    production?: boolean | QualityCheck$productionArgs<ExtArgs>
  }
  export type QualityCheckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    production?: boolean | QualityCheck$productionArgs<ExtArgs>
  }
  export type QualityCheckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    production?: boolean | QualityCheck$productionArgs<ExtArgs>
  }

  export type $QualityCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QualityCheck"
    objects: {
      production: Prisma.$ProductionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productionId: string | null
      checkType: string
      checkDate: Date
      inspector: string | null
      passed: boolean
      score: number | null
      defectCount: number
      sampleSize: number | null
      notes: string | null
      corrective: string | null
      attachments: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["qualityCheck"]>
    composites: {}
  }

  type QualityCheckGetPayload<S extends boolean | null | undefined | QualityCheckDefaultArgs> = $Result.GetResult<Prisma.$QualityCheckPayload, S>

  type QualityCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QualityCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QualityCheckCountAggregateInputType | true
    }

  export interface QualityCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QualityCheck'], meta: { name: 'QualityCheck' } }
    /**
     * Find zero or one QualityCheck that matches the filter.
     * @param {QualityCheckFindUniqueArgs} args - Arguments to find a QualityCheck
     * @example
     * // Get one QualityCheck
     * const qualityCheck = await prisma.qualityCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QualityCheckFindUniqueArgs>(args: SelectSubset<T, QualityCheckFindUniqueArgs<ExtArgs>>): Prisma__QualityCheckClient<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QualityCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QualityCheckFindUniqueOrThrowArgs} args - Arguments to find a QualityCheck
     * @example
     * // Get one QualityCheck
     * const qualityCheck = await prisma.qualityCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QualityCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, QualityCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QualityCheckClient<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QualityCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityCheckFindFirstArgs} args - Arguments to find a QualityCheck
     * @example
     * // Get one QualityCheck
     * const qualityCheck = await prisma.qualityCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QualityCheckFindFirstArgs>(args?: SelectSubset<T, QualityCheckFindFirstArgs<ExtArgs>>): Prisma__QualityCheckClient<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QualityCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityCheckFindFirstOrThrowArgs} args - Arguments to find a QualityCheck
     * @example
     * // Get one QualityCheck
     * const qualityCheck = await prisma.qualityCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QualityCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, QualityCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__QualityCheckClient<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QualityChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QualityChecks
     * const qualityChecks = await prisma.qualityCheck.findMany()
     * 
     * // Get first 10 QualityChecks
     * const qualityChecks = await prisma.qualityCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qualityCheckWithIdOnly = await prisma.qualityCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QualityCheckFindManyArgs>(args?: SelectSubset<T, QualityCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QualityCheck.
     * @param {QualityCheckCreateArgs} args - Arguments to create a QualityCheck.
     * @example
     * // Create one QualityCheck
     * const QualityCheck = await prisma.qualityCheck.create({
     *   data: {
     *     // ... data to create a QualityCheck
     *   }
     * })
     * 
     */
    create<T extends QualityCheckCreateArgs>(args: SelectSubset<T, QualityCheckCreateArgs<ExtArgs>>): Prisma__QualityCheckClient<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QualityChecks.
     * @param {QualityCheckCreateManyArgs} args - Arguments to create many QualityChecks.
     * @example
     * // Create many QualityChecks
     * const qualityCheck = await prisma.qualityCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QualityCheckCreateManyArgs>(args?: SelectSubset<T, QualityCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QualityChecks and returns the data saved in the database.
     * @param {QualityCheckCreateManyAndReturnArgs} args - Arguments to create many QualityChecks.
     * @example
     * // Create many QualityChecks
     * const qualityCheck = await prisma.qualityCheck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QualityChecks and only return the `id`
     * const qualityCheckWithIdOnly = await prisma.qualityCheck.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QualityCheckCreateManyAndReturnArgs>(args?: SelectSubset<T, QualityCheckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QualityCheck.
     * @param {QualityCheckDeleteArgs} args - Arguments to delete one QualityCheck.
     * @example
     * // Delete one QualityCheck
     * const QualityCheck = await prisma.qualityCheck.delete({
     *   where: {
     *     // ... filter to delete one QualityCheck
     *   }
     * })
     * 
     */
    delete<T extends QualityCheckDeleteArgs>(args: SelectSubset<T, QualityCheckDeleteArgs<ExtArgs>>): Prisma__QualityCheckClient<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QualityCheck.
     * @param {QualityCheckUpdateArgs} args - Arguments to update one QualityCheck.
     * @example
     * // Update one QualityCheck
     * const qualityCheck = await prisma.qualityCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QualityCheckUpdateArgs>(args: SelectSubset<T, QualityCheckUpdateArgs<ExtArgs>>): Prisma__QualityCheckClient<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QualityChecks.
     * @param {QualityCheckDeleteManyArgs} args - Arguments to filter QualityChecks to delete.
     * @example
     * // Delete a few QualityChecks
     * const { count } = await prisma.qualityCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QualityCheckDeleteManyArgs>(args?: SelectSubset<T, QualityCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualityChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QualityChecks
     * const qualityCheck = await prisma.qualityCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QualityCheckUpdateManyArgs>(args: SelectSubset<T, QualityCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualityChecks and returns the data updated in the database.
     * @param {QualityCheckUpdateManyAndReturnArgs} args - Arguments to update many QualityChecks.
     * @example
     * // Update many QualityChecks
     * const qualityCheck = await prisma.qualityCheck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QualityChecks and only return the `id`
     * const qualityCheckWithIdOnly = await prisma.qualityCheck.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QualityCheckUpdateManyAndReturnArgs>(args: SelectSubset<T, QualityCheckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QualityCheck.
     * @param {QualityCheckUpsertArgs} args - Arguments to update or create a QualityCheck.
     * @example
     * // Update or create a QualityCheck
     * const qualityCheck = await prisma.qualityCheck.upsert({
     *   create: {
     *     // ... data to create a QualityCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QualityCheck we want to update
     *   }
     * })
     */
    upsert<T extends QualityCheckUpsertArgs>(args: SelectSubset<T, QualityCheckUpsertArgs<ExtArgs>>): Prisma__QualityCheckClient<$Result.GetResult<Prisma.$QualityCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QualityChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityCheckCountArgs} args - Arguments to filter QualityChecks to count.
     * @example
     * // Count the number of QualityChecks
     * const count = await prisma.qualityCheck.count({
     *   where: {
     *     // ... the filter for the QualityChecks we want to count
     *   }
     * })
    **/
    count<T extends QualityCheckCountArgs>(
      args?: Subset<T, QualityCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualityCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QualityCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualityCheckAggregateArgs>(args: Subset<T, QualityCheckAggregateArgs>): Prisma.PrismaPromise<GetQualityCheckAggregateType<T>>

    /**
     * Group by QualityCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualityCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualityCheckGroupByArgs['orderBy'] }
        : { orderBy?: QualityCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualityCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualityCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QualityCheck model
   */
  readonly fields: QualityCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QualityCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QualityCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    production<T extends QualityCheck$productionArgs<ExtArgs> = {}>(args?: Subset<T, QualityCheck$productionArgs<ExtArgs>>): Prisma__ProductionClient<$Result.GetResult<Prisma.$ProductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QualityCheck model
   */
  interface QualityCheckFieldRefs {
    readonly id: FieldRef<"QualityCheck", 'String'>
    readonly productionId: FieldRef<"QualityCheck", 'String'>
    readonly checkType: FieldRef<"QualityCheck", 'String'>
    readonly checkDate: FieldRef<"QualityCheck", 'DateTime'>
    readonly inspector: FieldRef<"QualityCheck", 'String'>
    readonly passed: FieldRef<"QualityCheck", 'Boolean'>
    readonly score: FieldRef<"QualityCheck", 'Float'>
    readonly defectCount: FieldRef<"QualityCheck", 'Int'>
    readonly sampleSize: FieldRef<"QualityCheck", 'Int'>
    readonly notes: FieldRef<"QualityCheck", 'String'>
    readonly corrective: FieldRef<"QualityCheck", 'String'>
    readonly attachments: FieldRef<"QualityCheck", 'String[]'>
    readonly metadata: FieldRef<"QualityCheck", 'Json'>
    readonly createdAt: FieldRef<"QualityCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QualityCheck findUnique
   */
  export type QualityCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * Filter, which QualityCheck to fetch.
     */
    where: QualityCheckWhereUniqueInput
  }

  /**
   * QualityCheck findUniqueOrThrow
   */
  export type QualityCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * Filter, which QualityCheck to fetch.
     */
    where: QualityCheckWhereUniqueInput
  }

  /**
   * QualityCheck findFirst
   */
  export type QualityCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * Filter, which QualityCheck to fetch.
     */
    where?: QualityCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityChecks to fetch.
     */
    orderBy?: QualityCheckOrderByWithRelationInput | QualityCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityChecks.
     */
    cursor?: QualityCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityChecks.
     */
    distinct?: QualityCheckScalarFieldEnum | QualityCheckScalarFieldEnum[]
  }

  /**
   * QualityCheck findFirstOrThrow
   */
  export type QualityCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * Filter, which QualityCheck to fetch.
     */
    where?: QualityCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityChecks to fetch.
     */
    orderBy?: QualityCheckOrderByWithRelationInput | QualityCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityChecks.
     */
    cursor?: QualityCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityChecks.
     */
    distinct?: QualityCheckScalarFieldEnum | QualityCheckScalarFieldEnum[]
  }

  /**
   * QualityCheck findMany
   */
  export type QualityCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * Filter, which QualityChecks to fetch.
     */
    where?: QualityCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityChecks to fetch.
     */
    orderBy?: QualityCheckOrderByWithRelationInput | QualityCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QualityChecks.
     */
    cursor?: QualityCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityChecks.
     */
    skip?: number
    distinct?: QualityCheckScalarFieldEnum | QualityCheckScalarFieldEnum[]
  }

  /**
   * QualityCheck create
   */
  export type QualityCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a QualityCheck.
     */
    data: XOR<QualityCheckCreateInput, QualityCheckUncheckedCreateInput>
  }

  /**
   * QualityCheck createMany
   */
  export type QualityCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QualityChecks.
     */
    data: QualityCheckCreateManyInput | QualityCheckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QualityCheck createManyAndReturn
   */
  export type QualityCheckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * The data used to create many QualityChecks.
     */
    data: QualityCheckCreateManyInput | QualityCheckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QualityCheck update
   */
  export type QualityCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a QualityCheck.
     */
    data: XOR<QualityCheckUpdateInput, QualityCheckUncheckedUpdateInput>
    /**
     * Choose, which QualityCheck to update.
     */
    where: QualityCheckWhereUniqueInput
  }

  /**
   * QualityCheck updateMany
   */
  export type QualityCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QualityChecks.
     */
    data: XOR<QualityCheckUpdateManyMutationInput, QualityCheckUncheckedUpdateManyInput>
    /**
     * Filter which QualityChecks to update
     */
    where?: QualityCheckWhereInput
    /**
     * Limit how many QualityChecks to update.
     */
    limit?: number
  }

  /**
   * QualityCheck updateManyAndReturn
   */
  export type QualityCheckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * The data used to update QualityChecks.
     */
    data: XOR<QualityCheckUpdateManyMutationInput, QualityCheckUncheckedUpdateManyInput>
    /**
     * Filter which QualityChecks to update
     */
    where?: QualityCheckWhereInput
    /**
     * Limit how many QualityChecks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QualityCheck upsert
   */
  export type QualityCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the QualityCheck to update in case it exists.
     */
    where: QualityCheckWhereUniqueInput
    /**
     * In case the QualityCheck found by the `where` argument doesn't exist, create a new QualityCheck with this data.
     */
    create: XOR<QualityCheckCreateInput, QualityCheckUncheckedCreateInput>
    /**
     * In case the QualityCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QualityCheckUpdateInput, QualityCheckUncheckedUpdateInput>
  }

  /**
   * QualityCheck delete
   */
  export type QualityCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
    /**
     * Filter which QualityCheck to delete.
     */
    where: QualityCheckWhereUniqueInput
  }

  /**
   * QualityCheck deleteMany
   */
  export type QualityCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityChecks to delete
     */
    where?: QualityCheckWhereInput
    /**
     * Limit how many QualityChecks to delete.
     */
    limit?: number
  }

  /**
   * QualityCheck.production
   */
  export type QualityCheck$productionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Production
     */
    select?: ProductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Production
     */
    omit?: ProductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionInclude<ExtArgs> | null
    where?: ProductionWhereInput
  }

  /**
   * QualityCheck without action
   */
  export type QualityCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityCheck
     */
    select?: QualityCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityCheck
     */
    omit?: QualityCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityCheckInclude<ExtArgs> | null
  }


  /**
   * Model ProductionOrder
   */

  export type AggregateProductionOrder = {
    _count: ProductionOrderCountAggregateOutputType | null
    _avg: ProductionOrderAvgAggregateOutputType | null
    _sum: ProductionOrderSumAggregateOutputType | null
    _min: ProductionOrderMinAggregateOutputType | null
    _max: ProductionOrderMaxAggregateOutputType | null
  }

  export type ProductionOrderAvgAggregateOutputType = {
    quantity: number | null
    yield: number | null
    efficiency: number | null
  }

  export type ProductionOrderSumAggregateOutputType = {
    quantity: number | null
    yield: number | null
    efficiency: number | null
  }

  export type ProductionOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    productSKU: string | null
    quantity: number | null
    priority: $Enums.Priority | null
    status: $Enums.ProductionStatus | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    actualStart: Date | null
    actualEnd: Date | null
    assignedMachine: string | null
    assignedOperator: string | null
    batchNumber: string | null
    qualityGrade: string | null
    yield: number | null
    efficiency: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    productSKU: string | null
    quantity: number | null
    priority: $Enums.Priority | null
    status: $Enums.ProductionStatus | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    actualStart: Date | null
    actualEnd: Date | null
    assignedMachine: string | null
    assignedOperator: string | null
    batchNumber: string | null
    qualityGrade: string | null
    yield: number | null
    efficiency: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    productSKU: number
    quantity: number
    priority: number
    status: number
    scheduledStart: number
    scheduledEnd: number
    actualStart: number
    actualEnd: number
    assignedMachine: number
    assignedOperator: number
    batchNumber: number
    qualityGrade: number
    yield: number
    efficiency: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionOrderAvgAggregateInputType = {
    quantity?: true
    yield?: true
    efficiency?: true
  }

  export type ProductionOrderSumAggregateInputType = {
    quantity?: true
    yield?: true
    efficiency?: true
  }

  export type ProductionOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    productSKU?: true
    quantity?: true
    priority?: true
    status?: true
    scheduledStart?: true
    scheduledEnd?: true
    actualStart?: true
    actualEnd?: true
    assignedMachine?: true
    assignedOperator?: true
    batchNumber?: true
    qualityGrade?: true
    yield?: true
    efficiency?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    productSKU?: true
    quantity?: true
    priority?: true
    status?: true
    scheduledStart?: true
    scheduledEnd?: true
    actualStart?: true
    actualEnd?: true
    assignedMachine?: true
    assignedOperator?: true
    batchNumber?: true
    qualityGrade?: true
    yield?: true
    efficiency?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    productSKU?: true
    quantity?: true
    priority?: true
    status?: true
    scheduledStart?: true
    scheduledEnd?: true
    actualStart?: true
    actualEnd?: true
    assignedMachine?: true
    assignedOperator?: true
    batchNumber?: true
    qualityGrade?: true
    yield?: true
    efficiency?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionOrder to aggregate.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionOrders
    **/
    _count?: true | ProductionOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionOrderMaxAggregateInputType
  }

  export type GetProductionOrderAggregateType<T extends ProductionOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionOrder[P]>
      : GetScalarType<T[P], AggregateProductionOrder[P]>
  }




  export type ProductionOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOrderWhereInput
    orderBy?: ProductionOrderOrderByWithAggregationInput | ProductionOrderOrderByWithAggregationInput[]
    by: ProductionOrderScalarFieldEnum[] | ProductionOrderScalarFieldEnum
    having?: ProductionOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionOrderCountAggregateInputType | true
    _avg?: ProductionOrderAvgAggregateInputType
    _sum?: ProductionOrderSumAggregateInputType
    _min?: ProductionOrderMinAggregateInputType
    _max?: ProductionOrderMaxAggregateInputType
  }

  export type ProductionOrderGroupByOutputType = {
    id: string
    orderNumber: string
    productSKU: string
    quantity: number
    priority: $Enums.Priority
    status: $Enums.ProductionStatus
    scheduledStart: Date | null
    scheduledEnd: Date | null
    actualStart: Date | null
    actualEnd: Date | null
    assignedMachine: string | null
    assignedOperator: string | null
    batchNumber: string | null
    qualityGrade: string | null
    yield: number | null
    efficiency: number | null
    notes: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProductionOrderCountAggregateOutputType | null
    _avg: ProductionOrderAvgAggregateOutputType | null
    _sum: ProductionOrderSumAggregateOutputType | null
    _min: ProductionOrderMinAggregateOutputType | null
    _max: ProductionOrderMaxAggregateOutputType | null
  }

  type GetProductionOrderGroupByPayload<T extends ProductionOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionOrderGroupByOutputType[P]>
        }
      >
    >


  export type ProductionOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    productSKU?: boolean
    quantity?: boolean
    priority?: boolean
    status?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    assignedMachine?: boolean
    assignedOperator?: boolean
    batchNumber?: boolean
    qualityGrade?: boolean
    yield?: boolean
    efficiency?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productionOrder"]>

  export type ProductionOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    productSKU?: boolean
    quantity?: boolean
    priority?: boolean
    status?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    assignedMachine?: boolean
    assignedOperator?: boolean
    batchNumber?: boolean
    qualityGrade?: boolean
    yield?: boolean
    efficiency?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productionOrder"]>

  export type ProductionOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    productSKU?: boolean
    quantity?: boolean
    priority?: boolean
    status?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    assignedMachine?: boolean
    assignedOperator?: boolean
    batchNumber?: boolean
    qualityGrade?: boolean
    yield?: boolean
    efficiency?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["productionOrder"]>

  export type ProductionOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    productSKU?: boolean
    quantity?: boolean
    priority?: boolean
    status?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    assignedMachine?: boolean
    assignedOperator?: boolean
    batchNumber?: boolean
    qualityGrade?: boolean
    yield?: boolean
    efficiency?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "productSKU" | "quantity" | "priority" | "status" | "scheduledStart" | "scheduledEnd" | "actualStart" | "actualEnd" | "assignedMachine" | "assignedOperator" | "batchNumber" | "qualityGrade" | "yield" | "efficiency" | "notes" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["productionOrder"]>

  export type $ProductionOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionOrder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      productSKU: string
      quantity: number
      priority: $Enums.Priority
      status: $Enums.ProductionStatus
      scheduledStart: Date | null
      scheduledEnd: Date | null
      actualStart: Date | null
      actualEnd: Date | null
      assignedMachine: string | null
      assignedOperator: string | null
      batchNumber: string | null
      qualityGrade: string | null
      yield: number | null
      efficiency: number | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionOrder"]>
    composites: {}
  }

  type ProductionOrderGetPayload<S extends boolean | null | undefined | ProductionOrderDefaultArgs> = $Result.GetResult<Prisma.$ProductionOrderPayload, S>

  type ProductionOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductionOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductionOrderCountAggregateInputType | true
    }

  export interface ProductionOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionOrder'], meta: { name: 'ProductionOrder' } }
    /**
     * Find zero or one ProductionOrder that matches the filter.
     * @param {ProductionOrderFindUniqueArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionOrderFindUniqueArgs>(args: SelectSubset<T, ProductionOrderFindUniqueArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductionOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductionOrderFindUniqueOrThrowArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindFirstArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionOrderFindFirstArgs>(args?: SelectSubset<T, ProductionOrderFindFirstArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductionOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindFirstOrThrowArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductionOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionOrders
     * const productionOrders = await prisma.productionOrder.findMany()
     * 
     * // Get first 10 ProductionOrders
     * const productionOrders = await prisma.productionOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionOrderWithIdOnly = await prisma.productionOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionOrderFindManyArgs>(args?: SelectSubset<T, ProductionOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductionOrder.
     * @param {ProductionOrderCreateArgs} args - Arguments to create a ProductionOrder.
     * @example
     * // Create one ProductionOrder
     * const ProductionOrder = await prisma.productionOrder.create({
     *   data: {
     *     // ... data to create a ProductionOrder
     *   }
     * })
     * 
     */
    create<T extends ProductionOrderCreateArgs>(args: SelectSubset<T, ProductionOrderCreateArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductionOrders.
     * @param {ProductionOrderCreateManyArgs} args - Arguments to create many ProductionOrders.
     * @example
     * // Create many ProductionOrders
     * const productionOrder = await prisma.productionOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionOrderCreateManyArgs>(args?: SelectSubset<T, ProductionOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionOrders and returns the data saved in the database.
     * @param {ProductionOrderCreateManyAndReturnArgs} args - Arguments to create many ProductionOrders.
     * @example
     * // Create many ProductionOrders
     * const productionOrder = await prisma.productionOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionOrders and only return the `id`
     * const productionOrderWithIdOnly = await prisma.productionOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductionOrder.
     * @param {ProductionOrderDeleteArgs} args - Arguments to delete one ProductionOrder.
     * @example
     * // Delete one ProductionOrder
     * const ProductionOrder = await prisma.productionOrder.delete({
     *   where: {
     *     // ... filter to delete one ProductionOrder
     *   }
     * })
     * 
     */
    delete<T extends ProductionOrderDeleteArgs>(args: SelectSubset<T, ProductionOrderDeleteArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductionOrder.
     * @param {ProductionOrderUpdateArgs} args - Arguments to update one ProductionOrder.
     * @example
     * // Update one ProductionOrder
     * const productionOrder = await prisma.productionOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionOrderUpdateArgs>(args: SelectSubset<T, ProductionOrderUpdateArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductionOrders.
     * @param {ProductionOrderDeleteManyArgs} args - Arguments to filter ProductionOrders to delete.
     * @example
     * // Delete a few ProductionOrders
     * const { count } = await prisma.productionOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionOrderDeleteManyArgs>(args?: SelectSubset<T, ProductionOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionOrders
     * const productionOrder = await prisma.productionOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionOrderUpdateManyArgs>(args: SelectSubset<T, ProductionOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionOrders and returns the data updated in the database.
     * @param {ProductionOrderUpdateManyAndReturnArgs} args - Arguments to update many ProductionOrders.
     * @example
     * // Update many ProductionOrders
     * const productionOrder = await prisma.productionOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductionOrders and only return the `id`
     * const productionOrderWithIdOnly = await prisma.productionOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductionOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductionOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductionOrder.
     * @param {ProductionOrderUpsertArgs} args - Arguments to update or create a ProductionOrder.
     * @example
     * // Update or create a ProductionOrder
     * const productionOrder = await prisma.productionOrder.upsert({
     *   create: {
     *     // ... data to create a ProductionOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionOrder we want to update
     *   }
     * })
     */
    upsert<T extends ProductionOrderUpsertArgs>(args: SelectSubset<T, ProductionOrderUpsertArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderCountArgs} args - Arguments to filter ProductionOrders to count.
     * @example
     * // Count the number of ProductionOrders
     * const count = await prisma.productionOrder.count({
     *   where: {
     *     // ... the filter for the ProductionOrders we want to count
     *   }
     * })
    **/
    count<T extends ProductionOrderCountArgs>(
      args?: Subset<T, ProductionOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionOrderAggregateArgs>(args: Subset<T, ProductionOrderAggregateArgs>): Prisma.PrismaPromise<GetProductionOrderAggregateType<T>>

    /**
     * Group by ProductionOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionOrderGroupByArgs['orderBy'] }
        : { orderBy?: ProductionOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionOrder model
   */
  readonly fields: ProductionOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionOrder model
   */
  interface ProductionOrderFieldRefs {
    readonly id: FieldRef<"ProductionOrder", 'String'>
    readonly orderNumber: FieldRef<"ProductionOrder", 'String'>
    readonly productSKU: FieldRef<"ProductionOrder", 'String'>
    readonly quantity: FieldRef<"ProductionOrder", 'Int'>
    readonly priority: FieldRef<"ProductionOrder", 'Priority'>
    readonly status: FieldRef<"ProductionOrder", 'ProductionStatus'>
    readonly scheduledStart: FieldRef<"ProductionOrder", 'DateTime'>
    readonly scheduledEnd: FieldRef<"ProductionOrder", 'DateTime'>
    readonly actualStart: FieldRef<"ProductionOrder", 'DateTime'>
    readonly actualEnd: FieldRef<"ProductionOrder", 'DateTime'>
    readonly assignedMachine: FieldRef<"ProductionOrder", 'String'>
    readonly assignedOperator: FieldRef<"ProductionOrder", 'String'>
    readonly batchNumber: FieldRef<"ProductionOrder", 'String'>
    readonly qualityGrade: FieldRef<"ProductionOrder", 'String'>
    readonly yield: FieldRef<"ProductionOrder", 'Float'>
    readonly efficiency: FieldRef<"ProductionOrder", 'Float'>
    readonly notes: FieldRef<"ProductionOrder", 'String'>
    readonly metadata: FieldRef<"ProductionOrder", 'Json'>
    readonly createdAt: FieldRef<"ProductionOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionOrder findUnique
   */
  export type ProductionOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder findUniqueOrThrow
   */
  export type ProductionOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder findFirst
   */
  export type ProductionOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionOrders.
     */
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder findFirstOrThrow
   */
  export type ProductionOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionOrders.
     */
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder findMany
   */
  export type ProductionOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * Filter, which ProductionOrders to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder create
   */
  export type ProductionOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * The data needed to create a ProductionOrder.
     */
    data: XOR<ProductionOrderCreateInput, ProductionOrderUncheckedCreateInput>
  }

  /**
   * ProductionOrder createMany
   */
  export type ProductionOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionOrders.
     */
    data: ProductionOrderCreateManyInput | ProductionOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionOrder createManyAndReturn
   */
  export type ProductionOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ProductionOrders.
     */
    data: ProductionOrderCreateManyInput | ProductionOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionOrder update
   */
  export type ProductionOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * The data needed to update a ProductionOrder.
     */
    data: XOR<ProductionOrderUpdateInput, ProductionOrderUncheckedUpdateInput>
    /**
     * Choose, which ProductionOrder to update.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder updateMany
   */
  export type ProductionOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionOrders.
     */
    data: XOR<ProductionOrderUpdateManyMutationInput, ProductionOrderUncheckedUpdateManyInput>
    /**
     * Filter which ProductionOrders to update
     */
    where?: ProductionOrderWhereInput
    /**
     * Limit how many ProductionOrders to update.
     */
    limit?: number
  }

  /**
   * ProductionOrder updateManyAndReturn
   */
  export type ProductionOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * The data used to update ProductionOrders.
     */
    data: XOR<ProductionOrderUpdateManyMutationInput, ProductionOrderUncheckedUpdateManyInput>
    /**
     * Filter which ProductionOrders to update
     */
    where?: ProductionOrderWhereInput
    /**
     * Limit how many ProductionOrders to update.
     */
    limit?: number
  }

  /**
   * ProductionOrder upsert
   */
  export type ProductionOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * The filter to search for the ProductionOrder to update in case it exists.
     */
    where: ProductionOrderWhereUniqueInput
    /**
     * In case the ProductionOrder found by the `where` argument doesn't exist, create a new ProductionOrder with this data.
     */
    create: XOR<ProductionOrderCreateInput, ProductionOrderUncheckedCreateInput>
    /**
     * In case the ProductionOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionOrderUpdateInput, ProductionOrderUncheckedUpdateInput>
  }

  /**
   * ProductionOrder delete
   */
  export type ProductionOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
    /**
     * Filter which ProductionOrder to delete.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder deleteMany
   */
  export type ProductionOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionOrders to delete
     */
    where?: ProductionOrderWhereInput
    /**
     * Limit how many ProductionOrders to delete.
     */
    limit?: number
  }

  /**
   * ProductionOrder without action
   */
  export type ProductionOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductionOrder
     */
    omit?: ProductionOrderOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkingCapitalScalarFieldEnum: {
    id: 'id',
    date: 'date',
    currentAssets: 'currentAssets',
    currentLiabilities: 'currentLiabilities',
    inventory: 'inventory',
    accountsReceivable: 'accountsReceivable',
    accountsPayable: 'accountsPayable',
    cash: 'cash',
    dso: 'dso',
    dpo: 'dpo',
    dio: 'dio',
    cashConversionCycle: 'cashConversionCycle',
    workingCapitalRatio: 'workingCapitalRatio',
    quickRatio: 'quickRatio',
    createdAt: 'createdAt'
  };

  export type WorkingCapitalScalarFieldEnum = (typeof WorkingCapitalScalarFieldEnum)[keyof typeof WorkingCapitalScalarFieldEnum]


  export const CashRunwayScalarFieldEnum: {
    id: 'id',
    date: 'date',
    cashBalance: 'cashBalance',
    monthlyBurnRate: 'monthlyBurnRate',
    monthlyRevenue: 'monthlyRevenue',
    netBurnRate: 'netBurnRate',
    runwayMonths: 'runwayMonths',
    coverageDay30: 'coverageDay30',
    coverageDay60: 'coverageDay60',
    coverageDay90: 'coverageDay90',
    coverageDay120: 'coverageDay120',
    coverageDay180: 'coverageDay180',
    createdAt: 'createdAt'
  };

  export type CashRunwayScalarFieldEnum = (typeof CashRunwayScalarFieldEnum)[keyof typeof CashRunwayScalarFieldEnum]


  export const ProductionScalarFieldEnum: {
    id: 'id',
    jobNumber: 'jobNumber',
    productName: 'productName',
    productSKU: 'productSKU',
    quantity: 'quantity',
    targetQuantity: 'targetQuantity',
    completedQuantity: 'completedQuantity',
    status: 'status',
    priority: 'priority',
    startDate: 'startDate',
    targetDate: 'targetDate',
    completionDate: 'completionDate',
    qualityScore: 'qualityScore',
    defectRate: 'defectRate',
    efficiency: 'efficiency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionScalarFieldEnum = (typeof ProductionScalarFieldEnum)[keyof typeof ProductionScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    reorderPoint: 'reorderPoint',
    reorderQuantity: 'reorderQuantity',
    location: 'location',
    warehouse: 'warehouse',
    unitCost: 'unitCost',
    totalValue: 'totalValue',
    lastMovement: 'lastMovement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    inventoryId: 'inventoryId',
    type: 'type',
    quantity: 'quantity',
    reference: 'reference',
    reason: 'reason',
    performedBy: 'performedBy',
    createdAt: 'createdAt'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const AIInsightScalarFieldEnum: {
    id: 'id',
    type: 'type',
    category: 'category',
    title: 'title',
    content: 'content',
    confidence: 'confidence',
    priority: 'priority',
    embedding: 'embedding',
    metadata: 'metadata',
    actionable: 'actionable',
    actioned: 'actioned',
    createdAt: 'createdAt'
  };

  export type AIInsightScalarFieldEnum = (typeof AIInsightScalarFieldEnum)[keyof typeof AIInsightScalarFieldEnum]


  export const DashboardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    type: 'type',
    layout: 'layout',
    widgets: 'widgets',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DashboardScalarFieldEnum = (typeof DashboardScalarFieldEnum)[keyof typeof DashboardScalarFieldEnum]


  export const AnalyticsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    metric: 'metric',
    value: 'value',
    dimension: 'dimension',
    forecast: 'forecast',
    actual: 'actual',
    variance: 'variance',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AnalyticsScalarFieldEnum = (typeof AnalyticsScalarFieldEnum)[keyof typeof AnalyticsScalarFieldEnum]


  export const MCPRequestScalarFieldEnum: {
    id: 'id',
    tool: 'tool',
    request: 'request',
    response: 'response',
    status: 'status',
    processingTime: 'processingTime',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type MCPRequestScalarFieldEnum = (typeof MCPRequestScalarFieldEnum)[keyof typeof MCPRequestScalarFieldEnum]


  export const CashLedgerScalarFieldEnum: {
    id: 'id',
    date: 'date',
    description: 'description',
    category: 'category',
    subCategory: 'subCategory',
    amount: 'amount',
    balance: 'balance',
    source: 'source',
    sourceId: 'sourceId',
    reconciledStatus: 'reconciledStatus',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashLedgerScalarFieldEnum = (typeof CashLedgerScalarFieldEnum)[keyof typeof CashLedgerScalarFieldEnum]


  export const CashProjectionScalarFieldEnum: {
    id: 'id',
    projectionDate: 'projectionDate',
    projectedAmount: 'projectedAmount',
    actualAmount: 'actualAmount',
    variance: 'variance',
    confidenceLevel: 'confidenceLevel',
    scenarioType: 'scenarioType',
    assumptions: 'assumptions',
    projectionMethod: 'projectionMethod',
    dataSource: 'dataSource',
    isAdjusted: 'isAdjusted',
    adjustmentReason: 'adjustmentReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashProjectionScalarFieldEnum = (typeof CashProjectionScalarFieldEnum)[keyof typeof CashProjectionScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    date: 'date',
    vendor: 'vendor',
    category: 'category',
    subCategory: 'subCategory',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    invoiceNumber: 'invoiceNumber',
    approvedBy: 'approvedBy',
    department: 'department',
    project: 'project',
    isRecurring: 'isRecurring',
    recurringPeriod: 'recurringPeriod',
    taxAmount: 'taxAmount',
    tags: 'tags',
    attachments: 'attachments',
    notes: 'notes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const ExecutiveMetricScalarFieldEnum: {
    id: 'id',
    date: 'date',
    revenue: 'revenue',
    revenueTarget: 'revenueTarget',
    revenueTrend: 'revenueTrend',
    cashFlow: 'cashFlow',
    cashFlowTarget: 'cashFlowTarget',
    cashFlowTrend: 'cashFlowTrend',
    currentRatio: 'currentRatio',
    currentRatioTarget: 'currentRatioTarget',
    currentRatioTrend: 'currentRatioTrend',
    quickRatio: 'quickRatio',
    quickRatioTarget: 'quickRatioTarget',
    quickRatioTrend: 'quickRatioTrend',
    oee: 'oee',
    oeeTarget: 'oeeTarget',
    oeeTrend: 'oeeTrend',
    throughput: 'throughput',
    throughputTarget: 'throughputTarget',
    throughputTrend: 'throughputTrend',
    marketShare: 'marketShare',
    marketShareTarget: 'marketShareTarget',
    marketShareTrend: 'marketShareTrend',
    customerSatisfaction: 'customerSatisfaction',
    customerSatisfactionTarget: 'customerSatisfactionTarget',
    customerSatisfactionTrend: 'customerSatisfactionTrend',
    currentAssets: 'currentAssets',
    currentLiabilities: 'currentLiabilities',
    inventory: 'inventory',
    daysInventory: 'daysInventory',
    daysReceivables: 'daysReceivables',
    daysPayables: 'daysPayables',
    cashUnlock: 'cashUnlock',
    isActual: 'isActual',
    confidence: 'confidence',
    dataSource: 'dataSource',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExecutiveMetricScalarFieldEnum = (typeof ExecutiveMetricScalarFieldEnum)[keyof typeof ExecutiveMetricScalarFieldEnum]


  export const ExecutiveAlertScalarFieldEnum: {
    id: 'id',
    severity: 'severity',
    type: 'type',
    category: 'category',
    title: 'title',
    description: 'description',
    impact: 'impact',
    action: 'action',
    source: 'source',
    metrics: 'metrics',
    isActive: 'isActive',
    isDismissed: 'isDismissed',
    dismissedBy: 'dismissedBy',
    dismissedAt: 'dismissedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExecutiveAlertScalarFieldEnum = (typeof ExecutiveAlertScalarFieldEnum)[keyof typeof ExecutiveAlertScalarFieldEnum]


  export const EnterpriseCashCoverageScalarFieldEnum: {
    id: 'id',
    period: 'period',
    startingCash: 'startingCash',
    endingCash: 'endingCash',
    salesRevenue: 'salesRevenue',
    subscriptionRevenue: 'subscriptionRevenue',
    serviceRevenue: 'serviceRevenue',
    otherRevenue: 'otherRevenue',
    totalRevenue: 'totalRevenue',
    payrollExpenses: 'payrollExpenses',
    rentExpenses: 'rentExpenses',
    utilitiesExpenses: 'utilitiesExpenses',
    marketingExpenses: 'marketingExpenses',
    suppliesExpenses: 'suppliesExpenses',
    maintenanceExpenses: 'maintenanceExpenses',
    insuranceExpenses: 'insuranceExpenses',
    professionalFees: 'professionalFees',
    otherOperatingExpenses: 'otherOperatingExpenses',
    totalOperatingExpenses: 'totalOperatingExpenses',
    capitalExpenses: 'capitalExpenses',
    loanPayments: 'loanPayments',
    taxPayments: 'taxPayments',
    dividendPayments: 'dividendPayments',
    otherNonOperatingExpenses: 'otherNonOperatingExpenses',
    netCashFlow: 'netCashFlow',
    operatingCashFlow: 'operatingCashFlow',
    financingCashFlow: 'financingCashFlow',
    investingCashFlow: 'investingCashFlow',
    cashCoverageRatio: 'cashCoverageRatio',
    quickRatio: 'quickRatio',
    currentRatio: 'currentRatio',
    debtServiceCoverageRatio: 'debtServiceCoverageRatio',
    accountsReceivable: 'accountsReceivable',
    accountsPayable: 'accountsPayable',
    inventory: 'inventory',
    prepaidExpenses: 'prepaidExpenses',
    accruedLiabilities: 'accruedLiabilities',
    daysOfCashOnHand: 'daysOfCashOnHand',
    burnRate: 'burnRate',
    runwayMonths: 'runwayMonths',
    isActual: 'isActual',
    isForecast: 'isForecast',
    confidenceScore: 'confidenceScore',
    dataSource: 'dataSource',
    importedFrom: 'importedFrom',
    notes: 'notes',
    adjustments: 'adjustments',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnterpriseCashCoverageScalarFieldEnum = (typeof EnterpriseCashCoverageScalarFieldEnum)[keyof typeof EnterpriseCashCoverageScalarFieldEnum]


  export const XeroAccountScalarFieldEnum: {
    id: 'id',
    xeroId: 'xeroId',
    code: 'code',
    name: 'name',
    type: 'type',
    bankAccountNumber: 'bankAccountNumber',
    status: 'status',
    description: 'description',
    class: 'class',
    systemAccount: 'systemAccount',
    enablePaymentsToAccount: 'enablePaymentsToAccount',
    showInExpenseClaims: 'showInExpenseClaims',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XeroAccountScalarFieldEnum = (typeof XeroAccountScalarFieldEnum)[keyof typeof XeroAccountScalarFieldEnum]


  export const XeroContactScalarFieldEnum: {
    id: 'id',
    xeroId: 'xeroId',
    name: 'name',
    firstName: 'firstName',
    lastName: 'lastName',
    emailAddress: 'emailAddress',
    contactStatus: 'contactStatus',
    isSupplier: 'isSupplier',
    isCustomer: 'isCustomer',
    defaultCurrency: 'defaultCurrency',
    accountNumber: 'accountNumber',
    companyNumber: 'companyNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XeroContactScalarFieldEnum = (typeof XeroContactScalarFieldEnum)[keyof typeof XeroContactScalarFieldEnum]


  export const XeroInvoiceScalarFieldEnum: {
    id: 'id',
    xeroId: 'xeroId',
    invoiceNumber: 'invoiceNumber',
    reference: 'reference',
    type: 'type',
    contactId: 'contactId',
    date: 'date',
    dueDate: 'dueDate',
    status: 'status',
    lineAmountTypes: 'lineAmountTypes',
    subTotal: 'subTotal',
    totalTax: 'totalTax',
    total: 'total',
    amountDue: 'amountDue',
    amountPaid: 'amountPaid',
    amountCredited: 'amountCredited',
    currencyCode: 'currencyCode',
    fullyPaidOnDate: 'fullyPaidOnDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XeroInvoiceScalarFieldEnum = (typeof XeroInvoiceScalarFieldEnum)[keyof typeof XeroInvoiceScalarFieldEnum]


  export const XeroBillScalarFieldEnum: {
    id: 'id',
    xeroId: 'xeroId',
    billNumber: 'billNumber',
    reference: 'reference',
    type: 'type',
    contactId: 'contactId',
    date: 'date',
    dueDate: 'dueDate',
    status: 'status',
    lineAmountTypes: 'lineAmountTypes',
    subTotal: 'subTotal',
    totalTax: 'totalTax',
    total: 'total',
    amountDue: 'amountDue',
    amountPaid: 'amountPaid',
    amountCredited: 'amountCredited',
    currencyCode: 'currencyCode',
    fullyPaidOnDate: 'fullyPaidOnDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XeroBillScalarFieldEnum = (typeof XeroBillScalarFieldEnum)[keyof typeof XeroBillScalarFieldEnum]


  export const XeroPaymentScalarFieldEnum: {
    id: 'id',
    xeroId: 'xeroId',
    date: 'date',
    amount: 'amount',
    currencyCode: 'currencyCode',
    paymentType: 'paymentType',
    status: 'status',
    isReconciled: 'isReconciled',
    reference: 'reference',
    batchPaymentId: 'batchPaymentId',
    contactId: 'contactId',
    invoiceId: 'invoiceId',
    billId: 'billId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XeroPaymentScalarFieldEnum = (typeof XeroPaymentScalarFieldEnum)[keyof typeof XeroPaymentScalarFieldEnum]


  export const XeroBankTransactionScalarFieldEnum: {
    id: 'id',
    xeroId: 'xeroId',
    bankAccountId: 'bankAccountId',
    type: 'type',
    date: 'date',
    reference: 'reference',
    amount: 'amount',
    currencyCode: 'currencyCode',
    status: 'status',
    isReconciled: 'isReconciled',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XeroBankTransactionScalarFieldEnum = (typeof XeroBankTransactionScalarFieldEnum)[keyof typeof XeroBankTransactionScalarFieldEnum]


  export const XeroItemScalarFieldEnum: {
    id: 'id',
    xeroId: 'xeroId',
    code: 'code',
    name: 'name',
    description: 'description',
    salesDetails: 'salesDetails',
    purchaseDetails: 'purchaseDetails',
    isTrackedAsInventory: 'isTrackedAsInventory',
    isSold: 'isSold',
    isPurchased: 'isPurchased',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type XeroItemScalarFieldEnum = (typeof XeroItemScalarFieldEnum)[keyof typeof XeroItemScalarFieldEnum]


  export const AmazonOrderScalarFieldEnum: {
    id: 'id',
    amazonOrderId: 'amazonOrderId',
    marketplace: 'marketplace',
    orderStatus: 'orderStatus',
    fulfillmentChannel: 'fulfillmentChannel',
    salesChannel: 'salesChannel',
    orderType: 'orderType',
    purchaseDate: 'purchaseDate',
    lastUpdateDate: 'lastUpdateDate',
    orderTotal: 'orderTotal',
    currency: 'currency',
    numberOfItemsShipped: 'numberOfItemsShipped',
    numberOfItemsUnshipped: 'numberOfItemsUnshipped',
    buyerEmail: 'buyerEmail',
    isBusinessOrder: 'isBusinessOrder',
    isPrime: 'isPrime',
    isGlobalExpressEnabled: 'isGlobalExpressEnabled',
    isReplacementOrder: 'isReplacementOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmazonOrderScalarFieldEnum = (typeof AmazonOrderScalarFieldEnum)[keyof typeof AmazonOrderScalarFieldEnum]


  export const AmazonOrderItemScalarFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    amazonOrderId: 'amazonOrderId',
    asin: 'asin',
    sellerSKU: 'sellerSKU',
    title: 'title',
    quantityOrdered: 'quantityOrdered',
    quantityShipped: 'quantityShipped',
    itemPrice: 'itemPrice',
    itemTax: 'itemTax',
    shippingPrice: 'shippingPrice',
    shippingTax: 'shippingTax',
    giftWrapPrice: 'giftWrapPrice',
    giftWrapTax: 'giftWrapTax',
    itemPromotionDiscount: 'itemPromotionDiscount',
    shipPromotionDiscount: 'shipPromotionDiscount',
    currency: 'currency',
    conditionNote: 'conditionNote',
    conditionId: 'conditionId',
    conditionSubtypeId: 'conditionSubtypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmazonOrderItemScalarFieldEnum = (typeof AmazonOrderItemScalarFieldEnum)[keyof typeof AmazonOrderItemScalarFieldEnum]


  export const AmazonInventoryScalarFieldEnum: {
    id: 'id',
    sellerSKU: 'sellerSKU',
    asin: 'asin',
    fnSKU: 'fnSKU',
    productName: 'productName',
    condition: 'condition',
    totalQuantity: 'totalQuantity',
    inStockQuantity: 'inStockQuantity',
    availableQuantity: 'availableQuantity',
    fulfillableQuantity: 'fulfillableQuantity',
    inboundWorkingQuantity: 'inboundWorkingQuantity',
    inboundShippedQuantity: 'inboundShippedQuantity',
    inboundReceivingQuantity: 'inboundReceivingQuantity',
    reservedQuantity: 'reservedQuantity',
    unfulfillableQuantity: 'unfulfillableQuantity',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmazonInventoryScalarFieldEnum = (typeof AmazonInventoryScalarFieldEnum)[keyof typeof AmazonInventoryScalarFieldEnum]


  export const ShopifyOrderScalarFieldEnum: {
    id: 'id',
    shopifyOrderId: 'shopifyOrderId',
    orderNumber: 'orderNumber',
    email: 'email',
    phone: 'phone',
    name: 'name',
    financialStatus: 'financialStatus',
    fulfillmentStatus: 'fulfillmentStatus',
    tags: 'tags',
    totalPrice: 'totalPrice',
    totalTax: 'totalTax',
    totalDiscounts: 'totalDiscounts',
    totalWeight: 'totalWeight',
    currency: 'currency',
    processedAt: 'processedAt',
    closedAt: 'closedAt',
    cancelledAt: 'cancelledAt',
    test: 'test',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopifyOrderScalarFieldEnum = (typeof ShopifyOrderScalarFieldEnum)[keyof typeof ShopifyOrderScalarFieldEnum]


  export const ShopifyLineItemScalarFieldEnum: {
    id: 'id',
    lineItemId: 'lineItemId',
    shopifyOrderId: 'shopifyOrderId',
    productId: 'productId',
    variantId: 'variantId',
    title: 'title',
    variantTitle: 'variantTitle',
    sku: 'sku',
    vendor: 'vendor',
    quantity: 'quantity',
    price: 'price',
    totalDiscount: 'totalDiscount',
    grams: 'grams',
    requiresShipping: 'requiresShipping',
    taxable: 'taxable',
    fulfillmentService: 'fulfillmentService',
    fulfillmentStatus: 'fulfillmentStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopifyLineItemScalarFieldEnum = (typeof ShopifyLineItemScalarFieldEnum)[keyof typeof ShopifyLineItemScalarFieldEnum]


  export const ShopifyProductScalarFieldEnum: {
    id: 'id',
    shopifyProductId: 'shopifyProductId',
    title: 'title',
    handle: 'handle',
    vendor: 'vendor',
    productType: 'productType',
    tags: 'tags',
    status: 'status',
    description: 'description',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopifyProductScalarFieldEnum = (typeof ShopifyProductScalarFieldEnum)[keyof typeof ShopifyProductScalarFieldEnum]


  export const ShopifyVariantScalarFieldEnum: {
    id: 'id',
    shopifyVariantId: 'shopifyVariantId',
    shopifyProductId: 'shopifyProductId',
    title: 'title',
    price: 'price',
    compareAtPrice: 'compareAtPrice',
    sku: 'sku',
    barcode: 'barcode',
    grams: 'grams',
    weight: 'weight',
    weightUnit: 'weightUnit',
    inventoryQuantity: 'inventoryQuantity',
    inventoryPolicy: 'inventoryPolicy',
    inventoryTracking: 'inventoryTracking',
    requiresShipping: 'requiresShipping',
    taxable: 'taxable',
    fulfillmentService: 'fulfillmentService',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopifyVariantScalarFieldEnum = (typeof ShopifyVariantScalarFieldEnum)[keyof typeof ShopifyVariantScalarFieldEnum]


  export const MachineScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    name: 'name',
    type: 'type',
    location: 'location',
    manufacturer: 'manufacturer',
    model: 'model',
    serialNumber: 'serialNumber',
    installDate: 'installDate',
    status: 'status',
    isActive: 'isActive',
    configuration: 'configuration',
    specifications: 'specifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MachineScalarFieldEnum = (typeof MachineScalarFieldEnum)[keyof typeof MachineScalarFieldEnum]


  export const MachineSensorScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    sensorType: 'sensorType',
    sensorName: 'sensorName',
    value: 'value',
    unit: 'unit',
    threshold: 'threshold',
    minValue: 'minValue',
    maxValue: 'maxValue',
    status: 'status',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type MachineSensorScalarFieldEnum = (typeof MachineSensorScalarFieldEnum)[keyof typeof MachineSensorScalarFieldEnum]


  export const MachineAlertScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    severity: 'severity',
    type: 'type',
    title: 'title',
    description: 'description',
    acknowledged: 'acknowledged',
    acknowledgedBy: 'acknowledgedBy',
    acknowledgedAt: 'acknowledgedAt',
    resolvedAt: 'resolvedAt',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type MachineAlertScalarFieldEnum = (typeof MachineAlertScalarFieldEnum)[keyof typeof MachineAlertScalarFieldEnum]


  export const MachineMaintenanceRecordScalarFieldEnum: {
    id: 'id',
    machineId: 'machineId',
    type: 'type',
    description: 'description',
    performedBy: 'performedBy',
    scheduledDate: 'scheduledDate',
    completedDate: 'completedDate',
    duration: 'duration',
    cost: 'cost',
    status: 'status',
    notes: 'notes',
    attachments: 'attachments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MachineMaintenanceRecordScalarFieldEnum = (typeof MachineMaintenanceRecordScalarFieldEnum)[keyof typeof MachineMaintenanceRecordScalarFieldEnum]


  export const QualityCheckScalarFieldEnum: {
    id: 'id',
    productionId: 'productionId',
    checkType: 'checkType',
    checkDate: 'checkDate',
    inspector: 'inspector',
    passed: 'passed',
    score: 'score',
    defectCount: 'defectCount',
    sampleSize: 'sampleSize',
    notes: 'notes',
    corrective: 'corrective',
    attachments: 'attachments',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type QualityCheckScalarFieldEnum = (typeof QualityCheckScalarFieldEnum)[keyof typeof QualityCheckScalarFieldEnum]


  export const ProductionOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    productSKU: 'productSKU',
    quantity: 'quantity',
    priority: 'priority',
    status: 'status',
    scheduledStart: 'scheduledStart',
    scheduledEnd: 'scheduledEnd',
    actualStart: 'actualStart',
    actualEnd: 'actualEnd',
    assignedMachine: 'assignedMachine',
    assignedOperator: 'assignedOperator',
    batchNumber: 'batchNumber',
    qualityGrade: 'qualityGrade',
    yield: 'yield',
    efficiency: 'efficiency',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionOrderScalarFieldEnum = (typeof ProductionOrderScalarFieldEnum)[keyof typeof ProductionOrderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProductionStatus'
   */
  export type EnumProductionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductionStatus'>
    


  /**
   * Reference to a field of type 'ProductionStatus[]'
   */
  export type ListEnumProductionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductionStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'MovementType'
   */
  export type EnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType'>
    


  /**
   * Reference to a field of type 'MovementType[]'
   */
  export type ListEnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    preferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    dashboards?: DashboardListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dashboards?: DashboardOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    preferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    dashboards?: DashboardListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    preferences?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type WorkingCapitalWhereInput = {
    AND?: WorkingCapitalWhereInput | WorkingCapitalWhereInput[]
    OR?: WorkingCapitalWhereInput[]
    NOT?: WorkingCapitalWhereInput | WorkingCapitalWhereInput[]
    id?: StringFilter<"WorkingCapital"> | string
    date?: DateTimeFilter<"WorkingCapital"> | Date | string
    currentAssets?: FloatFilter<"WorkingCapital"> | number
    currentLiabilities?: FloatFilter<"WorkingCapital"> | number
    inventory?: FloatFilter<"WorkingCapital"> | number
    accountsReceivable?: FloatFilter<"WorkingCapital"> | number
    accountsPayable?: FloatFilter<"WorkingCapital"> | number
    cash?: FloatFilter<"WorkingCapital"> | number
    dso?: IntFilter<"WorkingCapital"> | number
    dpo?: IntFilter<"WorkingCapital"> | number
    dio?: IntFilter<"WorkingCapital"> | number
    cashConversionCycle?: IntFilter<"WorkingCapital"> | number
    workingCapitalRatio?: FloatFilter<"WorkingCapital"> | number
    quickRatio?: FloatFilter<"WorkingCapital"> | number
    createdAt?: DateTimeFilter<"WorkingCapital"> | Date | string
  }

  export type WorkingCapitalOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    cash?: SortOrder
    dso?: SortOrder
    dpo?: SortOrder
    dio?: SortOrder
    cashConversionCycle?: SortOrder
    workingCapitalRatio?: SortOrder
    quickRatio?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkingCapitalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkingCapitalWhereInput | WorkingCapitalWhereInput[]
    OR?: WorkingCapitalWhereInput[]
    NOT?: WorkingCapitalWhereInput | WorkingCapitalWhereInput[]
    date?: DateTimeFilter<"WorkingCapital"> | Date | string
    currentAssets?: FloatFilter<"WorkingCapital"> | number
    currentLiabilities?: FloatFilter<"WorkingCapital"> | number
    inventory?: FloatFilter<"WorkingCapital"> | number
    accountsReceivable?: FloatFilter<"WorkingCapital"> | number
    accountsPayable?: FloatFilter<"WorkingCapital"> | number
    cash?: FloatFilter<"WorkingCapital"> | number
    dso?: IntFilter<"WorkingCapital"> | number
    dpo?: IntFilter<"WorkingCapital"> | number
    dio?: IntFilter<"WorkingCapital"> | number
    cashConversionCycle?: IntFilter<"WorkingCapital"> | number
    workingCapitalRatio?: FloatFilter<"WorkingCapital"> | number
    quickRatio?: FloatFilter<"WorkingCapital"> | number
    createdAt?: DateTimeFilter<"WorkingCapital"> | Date | string
  }, "id">

  export type WorkingCapitalOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    cash?: SortOrder
    dso?: SortOrder
    dpo?: SortOrder
    dio?: SortOrder
    cashConversionCycle?: SortOrder
    workingCapitalRatio?: SortOrder
    quickRatio?: SortOrder
    createdAt?: SortOrder
    _count?: WorkingCapitalCountOrderByAggregateInput
    _avg?: WorkingCapitalAvgOrderByAggregateInput
    _max?: WorkingCapitalMaxOrderByAggregateInput
    _min?: WorkingCapitalMinOrderByAggregateInput
    _sum?: WorkingCapitalSumOrderByAggregateInput
  }

  export type WorkingCapitalScalarWhereWithAggregatesInput = {
    AND?: WorkingCapitalScalarWhereWithAggregatesInput | WorkingCapitalScalarWhereWithAggregatesInput[]
    OR?: WorkingCapitalScalarWhereWithAggregatesInput[]
    NOT?: WorkingCapitalScalarWhereWithAggregatesInput | WorkingCapitalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkingCapital"> | string
    date?: DateTimeWithAggregatesFilter<"WorkingCapital"> | Date | string
    currentAssets?: FloatWithAggregatesFilter<"WorkingCapital"> | number
    currentLiabilities?: FloatWithAggregatesFilter<"WorkingCapital"> | number
    inventory?: FloatWithAggregatesFilter<"WorkingCapital"> | number
    accountsReceivable?: FloatWithAggregatesFilter<"WorkingCapital"> | number
    accountsPayable?: FloatWithAggregatesFilter<"WorkingCapital"> | number
    cash?: FloatWithAggregatesFilter<"WorkingCapital"> | number
    dso?: IntWithAggregatesFilter<"WorkingCapital"> | number
    dpo?: IntWithAggregatesFilter<"WorkingCapital"> | number
    dio?: IntWithAggregatesFilter<"WorkingCapital"> | number
    cashConversionCycle?: IntWithAggregatesFilter<"WorkingCapital"> | number
    workingCapitalRatio?: FloatWithAggregatesFilter<"WorkingCapital"> | number
    quickRatio?: FloatWithAggregatesFilter<"WorkingCapital"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkingCapital"> | Date | string
  }

  export type CashRunwayWhereInput = {
    AND?: CashRunwayWhereInput | CashRunwayWhereInput[]
    OR?: CashRunwayWhereInput[]
    NOT?: CashRunwayWhereInput | CashRunwayWhereInput[]
    id?: StringFilter<"CashRunway"> | string
    date?: DateTimeFilter<"CashRunway"> | Date | string
    cashBalance?: FloatFilter<"CashRunway"> | number
    monthlyBurnRate?: FloatFilter<"CashRunway"> | number
    monthlyRevenue?: FloatFilter<"CashRunway"> | number
    netBurnRate?: FloatFilter<"CashRunway"> | number
    runwayMonths?: FloatFilter<"CashRunway"> | number
    coverageDay30?: FloatFilter<"CashRunway"> | number
    coverageDay60?: FloatFilter<"CashRunway"> | number
    coverageDay90?: FloatFilter<"CashRunway"> | number
    coverageDay120?: FloatFilter<"CashRunway"> | number
    coverageDay180?: FloatFilter<"CashRunway"> | number
    createdAt?: DateTimeFilter<"CashRunway"> | Date | string
  }

  export type CashRunwayOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    cashBalance?: SortOrder
    monthlyBurnRate?: SortOrder
    monthlyRevenue?: SortOrder
    netBurnRate?: SortOrder
    runwayMonths?: SortOrder
    coverageDay30?: SortOrder
    coverageDay60?: SortOrder
    coverageDay90?: SortOrder
    coverageDay120?: SortOrder
    coverageDay180?: SortOrder
    createdAt?: SortOrder
  }

  export type CashRunwayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashRunwayWhereInput | CashRunwayWhereInput[]
    OR?: CashRunwayWhereInput[]
    NOT?: CashRunwayWhereInput | CashRunwayWhereInput[]
    date?: DateTimeFilter<"CashRunway"> | Date | string
    cashBalance?: FloatFilter<"CashRunway"> | number
    monthlyBurnRate?: FloatFilter<"CashRunway"> | number
    monthlyRevenue?: FloatFilter<"CashRunway"> | number
    netBurnRate?: FloatFilter<"CashRunway"> | number
    runwayMonths?: FloatFilter<"CashRunway"> | number
    coverageDay30?: FloatFilter<"CashRunway"> | number
    coverageDay60?: FloatFilter<"CashRunway"> | number
    coverageDay90?: FloatFilter<"CashRunway"> | number
    coverageDay120?: FloatFilter<"CashRunway"> | number
    coverageDay180?: FloatFilter<"CashRunway"> | number
    createdAt?: DateTimeFilter<"CashRunway"> | Date | string
  }, "id">

  export type CashRunwayOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    cashBalance?: SortOrder
    monthlyBurnRate?: SortOrder
    monthlyRevenue?: SortOrder
    netBurnRate?: SortOrder
    runwayMonths?: SortOrder
    coverageDay30?: SortOrder
    coverageDay60?: SortOrder
    coverageDay90?: SortOrder
    coverageDay120?: SortOrder
    coverageDay180?: SortOrder
    createdAt?: SortOrder
    _count?: CashRunwayCountOrderByAggregateInput
    _avg?: CashRunwayAvgOrderByAggregateInput
    _max?: CashRunwayMaxOrderByAggregateInput
    _min?: CashRunwayMinOrderByAggregateInput
    _sum?: CashRunwaySumOrderByAggregateInput
  }

  export type CashRunwayScalarWhereWithAggregatesInput = {
    AND?: CashRunwayScalarWhereWithAggregatesInput | CashRunwayScalarWhereWithAggregatesInput[]
    OR?: CashRunwayScalarWhereWithAggregatesInput[]
    NOT?: CashRunwayScalarWhereWithAggregatesInput | CashRunwayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashRunway"> | string
    date?: DateTimeWithAggregatesFilter<"CashRunway"> | Date | string
    cashBalance?: FloatWithAggregatesFilter<"CashRunway"> | number
    monthlyBurnRate?: FloatWithAggregatesFilter<"CashRunway"> | number
    monthlyRevenue?: FloatWithAggregatesFilter<"CashRunway"> | number
    netBurnRate?: FloatWithAggregatesFilter<"CashRunway"> | number
    runwayMonths?: FloatWithAggregatesFilter<"CashRunway"> | number
    coverageDay30?: FloatWithAggregatesFilter<"CashRunway"> | number
    coverageDay60?: FloatWithAggregatesFilter<"CashRunway"> | number
    coverageDay90?: FloatWithAggregatesFilter<"CashRunway"> | number
    coverageDay120?: FloatWithAggregatesFilter<"CashRunway"> | number
    coverageDay180?: FloatWithAggregatesFilter<"CashRunway"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CashRunway"> | Date | string
  }

  export type ProductionWhereInput = {
    AND?: ProductionWhereInput | ProductionWhereInput[]
    OR?: ProductionWhereInput[]
    NOT?: ProductionWhereInput | ProductionWhereInput[]
    id?: StringFilter<"Production"> | string
    jobNumber?: StringFilter<"Production"> | string
    productName?: StringFilter<"Production"> | string
    productSKU?: StringNullableFilter<"Production"> | string | null
    quantity?: IntFilter<"Production"> | number
    targetQuantity?: IntFilter<"Production"> | number
    completedQuantity?: IntFilter<"Production"> | number
    status?: EnumProductionStatusFilter<"Production"> | $Enums.ProductionStatus
    priority?: EnumPriorityFilter<"Production"> | $Enums.Priority
    startDate?: DateTimeFilter<"Production"> | Date | string
    targetDate?: DateTimeFilter<"Production"> | Date | string
    completionDate?: DateTimeNullableFilter<"Production"> | Date | string | null
    qualityScore?: FloatNullableFilter<"Production"> | number | null
    defectRate?: FloatNullableFilter<"Production"> | number | null
    efficiency?: FloatNullableFilter<"Production"> | number | null
    createdAt?: DateTimeFilter<"Production"> | Date | string
    updatedAt?: DateTimeFilter<"Production"> | Date | string
    qualityChecks?: QualityCheckListRelationFilter
  }

  export type ProductionOrderByWithRelationInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    productName?: SortOrder
    productSKU?: SortOrderInput | SortOrder
    quantity?: SortOrder
    targetQuantity?: SortOrder
    completedQuantity?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    defectRate?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    qualityChecks?: QualityCheckOrderByRelationAggregateInput
  }

  export type ProductionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobNumber?: string
    AND?: ProductionWhereInput | ProductionWhereInput[]
    OR?: ProductionWhereInput[]
    NOT?: ProductionWhereInput | ProductionWhereInput[]
    productName?: StringFilter<"Production"> | string
    productSKU?: StringNullableFilter<"Production"> | string | null
    quantity?: IntFilter<"Production"> | number
    targetQuantity?: IntFilter<"Production"> | number
    completedQuantity?: IntFilter<"Production"> | number
    status?: EnumProductionStatusFilter<"Production"> | $Enums.ProductionStatus
    priority?: EnumPriorityFilter<"Production"> | $Enums.Priority
    startDate?: DateTimeFilter<"Production"> | Date | string
    targetDate?: DateTimeFilter<"Production"> | Date | string
    completionDate?: DateTimeNullableFilter<"Production"> | Date | string | null
    qualityScore?: FloatNullableFilter<"Production"> | number | null
    defectRate?: FloatNullableFilter<"Production"> | number | null
    efficiency?: FloatNullableFilter<"Production"> | number | null
    createdAt?: DateTimeFilter<"Production"> | Date | string
    updatedAt?: DateTimeFilter<"Production"> | Date | string
    qualityChecks?: QualityCheckListRelationFilter
  }, "id" | "jobNumber">

  export type ProductionOrderByWithAggregationInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    productName?: SortOrder
    productSKU?: SortOrderInput | SortOrder
    quantity?: SortOrder
    targetQuantity?: SortOrder
    completedQuantity?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    defectRate?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionCountOrderByAggregateInput
    _avg?: ProductionAvgOrderByAggregateInput
    _max?: ProductionMaxOrderByAggregateInput
    _min?: ProductionMinOrderByAggregateInput
    _sum?: ProductionSumOrderByAggregateInput
  }

  export type ProductionScalarWhereWithAggregatesInput = {
    AND?: ProductionScalarWhereWithAggregatesInput | ProductionScalarWhereWithAggregatesInput[]
    OR?: ProductionScalarWhereWithAggregatesInput[]
    NOT?: ProductionScalarWhereWithAggregatesInput | ProductionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Production"> | string
    jobNumber?: StringWithAggregatesFilter<"Production"> | string
    productName?: StringWithAggregatesFilter<"Production"> | string
    productSKU?: StringNullableWithAggregatesFilter<"Production"> | string | null
    quantity?: IntWithAggregatesFilter<"Production"> | number
    targetQuantity?: IntWithAggregatesFilter<"Production"> | number
    completedQuantity?: IntWithAggregatesFilter<"Production"> | number
    status?: EnumProductionStatusWithAggregatesFilter<"Production"> | $Enums.ProductionStatus
    priority?: EnumPriorityWithAggregatesFilter<"Production"> | $Enums.Priority
    startDate?: DateTimeWithAggregatesFilter<"Production"> | Date | string
    targetDate?: DateTimeWithAggregatesFilter<"Production"> | Date | string
    completionDate?: DateTimeNullableWithAggregatesFilter<"Production"> | Date | string | null
    qualityScore?: FloatNullableWithAggregatesFilter<"Production"> | number | null
    defectRate?: FloatNullableWithAggregatesFilter<"Production"> | number | null
    efficiency?: FloatNullableWithAggregatesFilter<"Production"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Production"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Production"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    sku?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    quantity?: IntFilter<"Inventory"> | number
    reorderPoint?: IntFilter<"Inventory"> | number
    reorderQuantity?: IntFilter<"Inventory"> | number
    location?: StringFilter<"Inventory"> | string
    warehouse?: StringFilter<"Inventory"> | string
    unitCost?: FloatFilter<"Inventory"> | number
    totalValue?: FloatFilter<"Inventory"> | number
    lastMovement?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    movements?: InventoryMovementListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    location?: SortOrder
    warehouse?: SortOrder
    unitCost?: SortOrder
    totalValue?: SortOrder
    lastMovement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    movements?: InventoryMovementOrderByRelationAggregateInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    quantity?: IntFilter<"Inventory"> | number
    reorderPoint?: IntFilter<"Inventory"> | number
    reorderQuantity?: IntFilter<"Inventory"> | number
    location?: StringFilter<"Inventory"> | string
    warehouse?: StringFilter<"Inventory"> | string
    unitCost?: FloatFilter<"Inventory"> | number
    totalValue?: FloatFilter<"Inventory"> | number
    lastMovement?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    movements?: InventoryMovementListRelationFilter
  }, "id" | "sku">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    location?: SortOrder
    warehouse?: SortOrder
    unitCost?: SortOrder
    totalValue?: SortOrder
    lastMovement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    sku?: StringWithAggregatesFilter<"Inventory"> | string
    name?: StringWithAggregatesFilter<"Inventory"> | string
    description?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
    reorderPoint?: IntWithAggregatesFilter<"Inventory"> | number
    reorderQuantity?: IntWithAggregatesFilter<"Inventory"> | number
    location?: StringWithAggregatesFilter<"Inventory"> | string
    warehouse?: StringWithAggregatesFilter<"Inventory"> | string
    unitCost?: FloatWithAggregatesFilter<"Inventory"> | number
    totalValue?: FloatWithAggregatesFilter<"Inventory"> | number
    lastMovement?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    inventoryId?: StringFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    performedBy?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    inventory?: InventoryOrderByWithRelationInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    inventoryId?: StringFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    performedBy?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryMovement"> | string
    inventoryId?: StringWithAggregatesFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeWithAggregatesFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: IntWithAggregatesFilter<"InventoryMovement"> | number
    reference?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    reason?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
  }

  export type AIInsightWhereInput = {
    AND?: AIInsightWhereInput | AIInsightWhereInput[]
    OR?: AIInsightWhereInput[]
    NOT?: AIInsightWhereInput | AIInsightWhereInput[]
    id?: StringFilter<"AIInsight"> | string
    type?: StringFilter<"AIInsight"> | string
    category?: StringFilter<"AIInsight"> | string
    title?: StringFilter<"AIInsight"> | string
    content?: StringFilter<"AIInsight"> | string
    confidence?: FloatFilter<"AIInsight"> | number
    priority?: StringFilter<"AIInsight"> | string
    embedding?: FloatNullableListFilter<"AIInsight">
    metadata?: JsonFilter<"AIInsight">
    actionable?: BoolFilter<"AIInsight"> | boolean
    actioned?: BoolFilter<"AIInsight"> | boolean
    createdAt?: DateTimeFilter<"AIInsight"> | Date | string
  }

  export type AIInsightOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    confidence?: SortOrder
    priority?: SortOrder
    embedding?: SortOrder
    metadata?: SortOrder
    actionable?: SortOrder
    actioned?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIInsightWhereInput | AIInsightWhereInput[]
    OR?: AIInsightWhereInput[]
    NOT?: AIInsightWhereInput | AIInsightWhereInput[]
    type?: StringFilter<"AIInsight"> | string
    category?: StringFilter<"AIInsight"> | string
    title?: StringFilter<"AIInsight"> | string
    content?: StringFilter<"AIInsight"> | string
    confidence?: FloatFilter<"AIInsight"> | number
    priority?: StringFilter<"AIInsight"> | string
    embedding?: FloatNullableListFilter<"AIInsight">
    metadata?: JsonFilter<"AIInsight">
    actionable?: BoolFilter<"AIInsight"> | boolean
    actioned?: BoolFilter<"AIInsight"> | boolean
    createdAt?: DateTimeFilter<"AIInsight"> | Date | string
  }, "id">

  export type AIInsightOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    confidence?: SortOrder
    priority?: SortOrder
    embedding?: SortOrder
    metadata?: SortOrder
    actionable?: SortOrder
    actioned?: SortOrder
    createdAt?: SortOrder
    _count?: AIInsightCountOrderByAggregateInput
    _avg?: AIInsightAvgOrderByAggregateInput
    _max?: AIInsightMaxOrderByAggregateInput
    _min?: AIInsightMinOrderByAggregateInput
    _sum?: AIInsightSumOrderByAggregateInput
  }

  export type AIInsightScalarWhereWithAggregatesInput = {
    AND?: AIInsightScalarWhereWithAggregatesInput | AIInsightScalarWhereWithAggregatesInput[]
    OR?: AIInsightScalarWhereWithAggregatesInput[]
    NOT?: AIInsightScalarWhereWithAggregatesInput | AIInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIInsight"> | string
    type?: StringWithAggregatesFilter<"AIInsight"> | string
    category?: StringWithAggregatesFilter<"AIInsight"> | string
    title?: StringWithAggregatesFilter<"AIInsight"> | string
    content?: StringWithAggregatesFilter<"AIInsight"> | string
    confidence?: FloatWithAggregatesFilter<"AIInsight"> | number
    priority?: StringWithAggregatesFilter<"AIInsight"> | string
    embedding?: FloatNullableListFilter<"AIInsight">
    metadata?: JsonWithAggregatesFilter<"AIInsight">
    actionable?: BoolWithAggregatesFilter<"AIInsight"> | boolean
    actioned?: BoolWithAggregatesFilter<"AIInsight"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AIInsight"> | Date | string
  }

  export type DashboardWhereInput = {
    AND?: DashboardWhereInput | DashboardWhereInput[]
    OR?: DashboardWhereInput[]
    NOT?: DashboardWhereInput | DashboardWhereInput[]
    id?: StringFilter<"Dashboard"> | string
    userId?: StringFilter<"Dashboard"> | string
    name?: StringFilter<"Dashboard"> | string
    type?: StringFilter<"Dashboard"> | string
    layout?: JsonFilter<"Dashboard">
    widgets?: JsonFilter<"Dashboard">
    isDefault?: BoolFilter<"Dashboard"> | boolean
    createdAt?: DateTimeFilter<"Dashboard"> | Date | string
    updatedAt?: DateTimeFilter<"Dashboard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DashboardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    layout?: SortOrder
    widgets?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DashboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uix_dashboard_user_name?: DashboardUix_dashboard_user_nameCompoundUniqueInput
    AND?: DashboardWhereInput | DashboardWhereInput[]
    OR?: DashboardWhereInput[]
    NOT?: DashboardWhereInput | DashboardWhereInput[]
    userId?: StringFilter<"Dashboard"> | string
    name?: StringFilter<"Dashboard"> | string
    type?: StringFilter<"Dashboard"> | string
    layout?: JsonFilter<"Dashboard">
    widgets?: JsonFilter<"Dashboard">
    isDefault?: BoolFilter<"Dashboard"> | boolean
    createdAt?: DateTimeFilter<"Dashboard"> | Date | string
    updatedAt?: DateTimeFilter<"Dashboard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "uix_dashboard_user_name">

  export type DashboardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    layout?: SortOrder
    widgets?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DashboardCountOrderByAggregateInput
    _max?: DashboardMaxOrderByAggregateInput
    _min?: DashboardMinOrderByAggregateInput
  }

  export type DashboardScalarWhereWithAggregatesInput = {
    AND?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[]
    OR?: DashboardScalarWhereWithAggregatesInput[]
    NOT?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dashboard"> | string
    userId?: StringWithAggregatesFilter<"Dashboard"> | string
    name?: StringWithAggregatesFilter<"Dashboard"> | string
    type?: StringWithAggregatesFilter<"Dashboard"> | string
    layout?: JsonWithAggregatesFilter<"Dashboard">
    widgets?: JsonWithAggregatesFilter<"Dashboard">
    isDefault?: BoolWithAggregatesFilter<"Dashboard"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Dashboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dashboard"> | Date | string
  }

  export type AnalyticsWhereInput = {
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    id?: StringFilter<"Analytics"> | string
    date?: DateTimeFilter<"Analytics"> | Date | string
    metric?: StringFilter<"Analytics"> | string
    value?: FloatFilter<"Analytics"> | number
    dimension?: StringNullableFilter<"Analytics"> | string | null
    forecast?: FloatNullableFilter<"Analytics"> | number | null
    actual?: FloatNullableFilter<"Analytics"> | number | null
    variance?: FloatNullableFilter<"Analytics"> | number | null
    metadata?: JsonFilter<"Analytics">
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
  }

  export type AnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    dimension?: SortOrderInput | SortOrder
    forecast?: SortOrderInput | SortOrder
    actual?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    date?: DateTimeFilter<"Analytics"> | Date | string
    metric?: StringFilter<"Analytics"> | string
    value?: FloatFilter<"Analytics"> | number
    dimension?: StringNullableFilter<"Analytics"> | string | null
    forecast?: FloatNullableFilter<"Analytics"> | number | null
    actual?: FloatNullableFilter<"Analytics"> | number | null
    variance?: FloatNullableFilter<"Analytics"> | number | null
    metadata?: JsonFilter<"Analytics">
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
  }, "id">

  export type AnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    dimension?: SortOrderInput | SortOrder
    forecast?: SortOrderInput | SortOrder
    actual?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsCountOrderByAggregateInput
    _avg?: AnalyticsAvgOrderByAggregateInput
    _max?: AnalyticsMaxOrderByAggregateInput
    _min?: AnalyticsMinOrderByAggregateInput
    _sum?: AnalyticsSumOrderByAggregateInput
  }

  export type AnalyticsScalarWhereWithAggregatesInput = {
    AND?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    OR?: AnalyticsScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analytics"> | string
    date?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
    metric?: StringWithAggregatesFilter<"Analytics"> | string
    value?: FloatWithAggregatesFilter<"Analytics"> | number
    dimension?: StringNullableWithAggregatesFilter<"Analytics"> | string | null
    forecast?: FloatNullableWithAggregatesFilter<"Analytics"> | number | null
    actual?: FloatNullableWithAggregatesFilter<"Analytics"> | number | null
    variance?: FloatNullableWithAggregatesFilter<"Analytics"> | number | null
    metadata?: JsonWithAggregatesFilter<"Analytics">
    createdAt?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
  }

  export type MCPRequestWhereInput = {
    AND?: MCPRequestWhereInput | MCPRequestWhereInput[]
    OR?: MCPRequestWhereInput[]
    NOT?: MCPRequestWhereInput | MCPRequestWhereInput[]
    id?: StringFilter<"MCPRequest"> | string
    tool?: StringFilter<"MCPRequest"> | string
    request?: JsonFilter<"MCPRequest">
    response?: JsonNullableFilter<"MCPRequest">
    status?: StringFilter<"MCPRequest"> | string
    processingTime?: IntNullableFilter<"MCPRequest"> | number | null
    error?: StringNullableFilter<"MCPRequest"> | string | null
    createdAt?: DateTimeFilter<"MCPRequest"> | Date | string
  }

  export type MCPRequestOrderByWithRelationInput = {
    id?: SortOrder
    tool?: SortOrder
    request?: SortOrder
    response?: SortOrderInput | SortOrder
    status?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type MCPRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MCPRequestWhereInput | MCPRequestWhereInput[]
    OR?: MCPRequestWhereInput[]
    NOT?: MCPRequestWhereInput | MCPRequestWhereInput[]
    tool?: StringFilter<"MCPRequest"> | string
    request?: JsonFilter<"MCPRequest">
    response?: JsonNullableFilter<"MCPRequest">
    status?: StringFilter<"MCPRequest"> | string
    processingTime?: IntNullableFilter<"MCPRequest"> | number | null
    error?: StringNullableFilter<"MCPRequest"> | string | null
    createdAt?: DateTimeFilter<"MCPRequest"> | Date | string
  }, "id">

  export type MCPRequestOrderByWithAggregationInput = {
    id?: SortOrder
    tool?: SortOrder
    request?: SortOrder
    response?: SortOrderInput | SortOrder
    status?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MCPRequestCountOrderByAggregateInput
    _avg?: MCPRequestAvgOrderByAggregateInput
    _max?: MCPRequestMaxOrderByAggregateInput
    _min?: MCPRequestMinOrderByAggregateInput
    _sum?: MCPRequestSumOrderByAggregateInput
  }

  export type MCPRequestScalarWhereWithAggregatesInput = {
    AND?: MCPRequestScalarWhereWithAggregatesInput | MCPRequestScalarWhereWithAggregatesInput[]
    OR?: MCPRequestScalarWhereWithAggregatesInput[]
    NOT?: MCPRequestScalarWhereWithAggregatesInput | MCPRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MCPRequest"> | string
    tool?: StringWithAggregatesFilter<"MCPRequest"> | string
    request?: JsonWithAggregatesFilter<"MCPRequest">
    response?: JsonNullableWithAggregatesFilter<"MCPRequest">
    status?: StringWithAggregatesFilter<"MCPRequest"> | string
    processingTime?: IntNullableWithAggregatesFilter<"MCPRequest"> | number | null
    error?: StringNullableWithAggregatesFilter<"MCPRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MCPRequest"> | Date | string
  }

  export type CashLedgerWhereInput = {
    AND?: CashLedgerWhereInput | CashLedgerWhereInput[]
    OR?: CashLedgerWhereInput[]
    NOT?: CashLedgerWhereInput | CashLedgerWhereInput[]
    id?: StringFilter<"CashLedger"> | string
    date?: DateTimeFilter<"CashLedger"> | Date | string
    description?: StringFilter<"CashLedger"> | string
    category?: StringFilter<"CashLedger"> | string
    subCategory?: StringNullableFilter<"CashLedger"> | string | null
    amount?: FloatFilter<"CashLedger"> | number
    balance?: FloatFilter<"CashLedger"> | number
    source?: StringFilter<"CashLedger"> | string
    sourceId?: StringNullableFilter<"CashLedger"> | string | null
    reconciledStatus?: StringFilter<"CashLedger"> | string
    tags?: StringNullableListFilter<"CashLedger">
    metadata?: JsonNullableFilter<"CashLedger">
    createdAt?: DateTimeFilter<"CashLedger"> | Date | string
    updatedAt?: DateTimeFilter<"CashLedger"> | Date | string
  }

  export type CashLedgerOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    amount?: SortOrder
    balance?: SortOrder
    source?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    reconciledStatus?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashLedgerWhereInput | CashLedgerWhereInput[]
    OR?: CashLedgerWhereInput[]
    NOT?: CashLedgerWhereInput | CashLedgerWhereInput[]
    date?: DateTimeFilter<"CashLedger"> | Date | string
    description?: StringFilter<"CashLedger"> | string
    category?: StringFilter<"CashLedger"> | string
    subCategory?: StringNullableFilter<"CashLedger"> | string | null
    amount?: FloatFilter<"CashLedger"> | number
    balance?: FloatFilter<"CashLedger"> | number
    source?: StringFilter<"CashLedger"> | string
    sourceId?: StringNullableFilter<"CashLedger"> | string | null
    reconciledStatus?: StringFilter<"CashLedger"> | string
    tags?: StringNullableListFilter<"CashLedger">
    metadata?: JsonNullableFilter<"CashLedger">
    createdAt?: DateTimeFilter<"CashLedger"> | Date | string
    updatedAt?: DateTimeFilter<"CashLedger"> | Date | string
  }, "id">

  export type CashLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    amount?: SortOrder
    balance?: SortOrder
    source?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    reconciledStatus?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashLedgerCountOrderByAggregateInput
    _avg?: CashLedgerAvgOrderByAggregateInput
    _max?: CashLedgerMaxOrderByAggregateInput
    _min?: CashLedgerMinOrderByAggregateInput
    _sum?: CashLedgerSumOrderByAggregateInput
  }

  export type CashLedgerScalarWhereWithAggregatesInput = {
    AND?: CashLedgerScalarWhereWithAggregatesInput | CashLedgerScalarWhereWithAggregatesInput[]
    OR?: CashLedgerScalarWhereWithAggregatesInput[]
    NOT?: CashLedgerScalarWhereWithAggregatesInput | CashLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashLedger"> | string
    date?: DateTimeWithAggregatesFilter<"CashLedger"> | Date | string
    description?: StringWithAggregatesFilter<"CashLedger"> | string
    category?: StringWithAggregatesFilter<"CashLedger"> | string
    subCategory?: StringNullableWithAggregatesFilter<"CashLedger"> | string | null
    amount?: FloatWithAggregatesFilter<"CashLedger"> | number
    balance?: FloatWithAggregatesFilter<"CashLedger"> | number
    source?: StringWithAggregatesFilter<"CashLedger"> | string
    sourceId?: StringNullableWithAggregatesFilter<"CashLedger"> | string | null
    reconciledStatus?: StringWithAggregatesFilter<"CashLedger"> | string
    tags?: StringNullableListFilter<"CashLedger">
    metadata?: JsonNullableWithAggregatesFilter<"CashLedger">
    createdAt?: DateTimeWithAggregatesFilter<"CashLedger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashLedger"> | Date | string
  }

  export type CashProjectionWhereInput = {
    AND?: CashProjectionWhereInput | CashProjectionWhereInput[]
    OR?: CashProjectionWhereInput[]
    NOT?: CashProjectionWhereInput | CashProjectionWhereInput[]
    id?: StringFilter<"CashProjection"> | string
    projectionDate?: DateTimeFilter<"CashProjection"> | Date | string
    projectedAmount?: FloatFilter<"CashProjection"> | number
    actualAmount?: FloatNullableFilter<"CashProjection"> | number | null
    variance?: FloatNullableFilter<"CashProjection"> | number | null
    confidenceLevel?: FloatFilter<"CashProjection"> | number
    scenarioType?: StringFilter<"CashProjection"> | string
    assumptions?: JsonFilter<"CashProjection">
    projectionMethod?: StringFilter<"CashProjection"> | string
    dataSource?: StringFilter<"CashProjection"> | string
    isAdjusted?: BoolFilter<"CashProjection"> | boolean
    adjustmentReason?: StringNullableFilter<"CashProjection"> | string | null
    createdAt?: DateTimeFilter<"CashProjection"> | Date | string
    updatedAt?: DateTimeFilter<"CashProjection"> | Date | string
  }

  export type CashProjectionOrderByWithRelationInput = {
    id?: SortOrder
    projectionDate?: SortOrder
    projectedAmount?: SortOrder
    actualAmount?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    confidenceLevel?: SortOrder
    scenarioType?: SortOrder
    assumptions?: SortOrder
    projectionMethod?: SortOrder
    dataSource?: SortOrder
    isAdjusted?: SortOrder
    adjustmentReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashProjectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashProjectionWhereInput | CashProjectionWhereInput[]
    OR?: CashProjectionWhereInput[]
    NOT?: CashProjectionWhereInput | CashProjectionWhereInput[]
    projectionDate?: DateTimeFilter<"CashProjection"> | Date | string
    projectedAmount?: FloatFilter<"CashProjection"> | number
    actualAmount?: FloatNullableFilter<"CashProjection"> | number | null
    variance?: FloatNullableFilter<"CashProjection"> | number | null
    confidenceLevel?: FloatFilter<"CashProjection"> | number
    scenarioType?: StringFilter<"CashProjection"> | string
    assumptions?: JsonFilter<"CashProjection">
    projectionMethod?: StringFilter<"CashProjection"> | string
    dataSource?: StringFilter<"CashProjection"> | string
    isAdjusted?: BoolFilter<"CashProjection"> | boolean
    adjustmentReason?: StringNullableFilter<"CashProjection"> | string | null
    createdAt?: DateTimeFilter<"CashProjection"> | Date | string
    updatedAt?: DateTimeFilter<"CashProjection"> | Date | string
  }, "id">

  export type CashProjectionOrderByWithAggregationInput = {
    id?: SortOrder
    projectionDate?: SortOrder
    projectedAmount?: SortOrder
    actualAmount?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    confidenceLevel?: SortOrder
    scenarioType?: SortOrder
    assumptions?: SortOrder
    projectionMethod?: SortOrder
    dataSource?: SortOrder
    isAdjusted?: SortOrder
    adjustmentReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashProjectionCountOrderByAggregateInput
    _avg?: CashProjectionAvgOrderByAggregateInput
    _max?: CashProjectionMaxOrderByAggregateInput
    _min?: CashProjectionMinOrderByAggregateInput
    _sum?: CashProjectionSumOrderByAggregateInput
  }

  export type CashProjectionScalarWhereWithAggregatesInput = {
    AND?: CashProjectionScalarWhereWithAggregatesInput | CashProjectionScalarWhereWithAggregatesInput[]
    OR?: CashProjectionScalarWhereWithAggregatesInput[]
    NOT?: CashProjectionScalarWhereWithAggregatesInput | CashProjectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashProjection"> | string
    projectionDate?: DateTimeWithAggregatesFilter<"CashProjection"> | Date | string
    projectedAmount?: FloatWithAggregatesFilter<"CashProjection"> | number
    actualAmount?: FloatNullableWithAggregatesFilter<"CashProjection"> | number | null
    variance?: FloatNullableWithAggregatesFilter<"CashProjection"> | number | null
    confidenceLevel?: FloatWithAggregatesFilter<"CashProjection"> | number
    scenarioType?: StringWithAggregatesFilter<"CashProjection"> | string
    assumptions?: JsonWithAggregatesFilter<"CashProjection">
    projectionMethod?: StringWithAggregatesFilter<"CashProjection"> | string
    dataSource?: StringWithAggregatesFilter<"CashProjection"> | string
    isAdjusted?: BoolWithAggregatesFilter<"CashProjection"> | boolean
    adjustmentReason?: StringNullableWithAggregatesFilter<"CashProjection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CashProjection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashProjection"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    date?: DateTimeFilter<"Expense"> | Date | string
    vendor?: StringFilter<"Expense"> | string
    category?: StringFilter<"Expense"> | string
    subCategory?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    currency?: StringFilter<"Expense"> | string
    paymentMethod?: StringFilter<"Expense"> | string
    invoiceNumber?: StringNullableFilter<"Expense"> | string | null
    approvedBy?: StringNullableFilter<"Expense"> | string | null
    department?: StringNullableFilter<"Expense"> | string | null
    project?: StringNullableFilter<"Expense"> | string | null
    isRecurring?: BoolFilter<"Expense"> | boolean
    recurringPeriod?: StringNullableFilter<"Expense"> | string | null
    taxAmount?: FloatNullableFilter<"Expense"> | number | null
    tags?: StringNullableListFilter<"Expense">
    attachments?: StringNullableListFilter<"Expense">
    notes?: StringNullableFilter<"Expense"> | string | null
    status?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    vendor?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurringPeriod?: SortOrderInput | SortOrder
    taxAmount?: SortOrderInput | SortOrder
    tags?: SortOrder
    attachments?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    date?: DateTimeFilter<"Expense"> | Date | string
    vendor?: StringFilter<"Expense"> | string
    category?: StringFilter<"Expense"> | string
    subCategory?: StringNullableFilter<"Expense"> | string | null
    amount?: FloatFilter<"Expense"> | number
    currency?: StringFilter<"Expense"> | string
    paymentMethod?: StringFilter<"Expense"> | string
    invoiceNumber?: StringNullableFilter<"Expense"> | string | null
    approvedBy?: StringNullableFilter<"Expense"> | string | null
    department?: StringNullableFilter<"Expense"> | string | null
    project?: StringNullableFilter<"Expense"> | string | null
    isRecurring?: BoolFilter<"Expense"> | boolean
    recurringPeriod?: StringNullableFilter<"Expense"> | string | null
    taxAmount?: FloatNullableFilter<"Expense"> | number | null
    tags?: StringNullableListFilter<"Expense">
    attachments?: StringNullableListFilter<"Expense">
    notes?: StringNullableFilter<"Expense"> | string | null
    status?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    vendor?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    project?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurringPeriod?: SortOrderInput | SortOrder
    taxAmount?: SortOrderInput | SortOrder
    tags?: SortOrder
    attachments?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    vendor?: StringWithAggregatesFilter<"Expense"> | string
    category?: StringWithAggregatesFilter<"Expense"> | string
    subCategory?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    currency?: StringWithAggregatesFilter<"Expense"> | string
    paymentMethod?: StringWithAggregatesFilter<"Expense"> | string
    invoiceNumber?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    department?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    project?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    isRecurring?: BoolWithAggregatesFilter<"Expense"> | boolean
    recurringPeriod?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    taxAmount?: FloatNullableWithAggregatesFilter<"Expense"> | number | null
    tags?: StringNullableListFilter<"Expense">
    attachments?: StringNullableListFilter<"Expense">
    notes?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    status?: StringWithAggregatesFilter<"Expense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type ExecutiveMetricWhereInput = {
    AND?: ExecutiveMetricWhereInput | ExecutiveMetricWhereInput[]
    OR?: ExecutiveMetricWhereInput[]
    NOT?: ExecutiveMetricWhereInput | ExecutiveMetricWhereInput[]
    id?: StringFilter<"ExecutiveMetric"> | string
    date?: DateTimeFilter<"ExecutiveMetric"> | Date | string
    revenue?: FloatFilter<"ExecutiveMetric"> | number
    revenueTarget?: FloatFilter<"ExecutiveMetric"> | number
    revenueTrend?: FloatFilter<"ExecutiveMetric"> | number
    cashFlow?: FloatFilter<"ExecutiveMetric"> | number
    cashFlowTarget?: FloatFilter<"ExecutiveMetric"> | number
    cashFlowTrend?: FloatFilter<"ExecutiveMetric"> | number
    currentRatio?: FloatFilter<"ExecutiveMetric"> | number
    currentRatioTarget?: FloatFilter<"ExecutiveMetric"> | number
    currentRatioTrend?: FloatFilter<"ExecutiveMetric"> | number
    quickRatio?: FloatFilter<"ExecutiveMetric"> | number
    quickRatioTarget?: FloatFilter<"ExecutiveMetric"> | number
    quickRatioTrend?: FloatFilter<"ExecutiveMetric"> | number
    oee?: FloatFilter<"ExecutiveMetric"> | number
    oeeTarget?: FloatFilter<"ExecutiveMetric"> | number
    oeeTrend?: FloatFilter<"ExecutiveMetric"> | number
    throughput?: FloatFilter<"ExecutiveMetric"> | number
    throughputTarget?: FloatFilter<"ExecutiveMetric"> | number
    throughputTrend?: FloatFilter<"ExecutiveMetric"> | number
    marketShare?: FloatFilter<"ExecutiveMetric"> | number
    marketShareTarget?: FloatFilter<"ExecutiveMetric"> | number
    marketShareTrend?: FloatFilter<"ExecutiveMetric"> | number
    customerSatisfaction?: FloatFilter<"ExecutiveMetric"> | number
    customerSatisfactionTarget?: FloatFilter<"ExecutiveMetric"> | number
    customerSatisfactionTrend?: FloatFilter<"ExecutiveMetric"> | number
    currentAssets?: FloatFilter<"ExecutiveMetric"> | number
    currentLiabilities?: FloatFilter<"ExecutiveMetric"> | number
    inventory?: FloatFilter<"ExecutiveMetric"> | number
    daysInventory?: FloatFilter<"ExecutiveMetric"> | number
    daysReceivables?: FloatFilter<"ExecutiveMetric"> | number
    daysPayables?: FloatFilter<"ExecutiveMetric"> | number
    cashUnlock?: FloatFilter<"ExecutiveMetric"> | number
    isActual?: BoolFilter<"ExecutiveMetric"> | boolean
    confidence?: FloatFilter<"ExecutiveMetric"> | number
    dataSource?: StringFilter<"ExecutiveMetric"> | string
    notes?: StringNullableFilter<"ExecutiveMetric"> | string | null
    createdAt?: DateTimeFilter<"ExecutiveMetric"> | Date | string
    updatedAt?: DateTimeFilter<"ExecutiveMetric"> | Date | string
  }

  export type ExecutiveMetricOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    revenueTarget?: SortOrder
    revenueTrend?: SortOrder
    cashFlow?: SortOrder
    cashFlowTarget?: SortOrder
    cashFlowTrend?: SortOrder
    currentRatio?: SortOrder
    currentRatioTarget?: SortOrder
    currentRatioTrend?: SortOrder
    quickRatio?: SortOrder
    quickRatioTarget?: SortOrder
    quickRatioTrend?: SortOrder
    oee?: SortOrder
    oeeTarget?: SortOrder
    oeeTrend?: SortOrder
    throughput?: SortOrder
    throughputTarget?: SortOrder
    throughputTrend?: SortOrder
    marketShare?: SortOrder
    marketShareTarget?: SortOrder
    marketShareTrend?: SortOrder
    customerSatisfaction?: SortOrder
    customerSatisfactionTarget?: SortOrder
    customerSatisfactionTrend?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    daysInventory?: SortOrder
    daysReceivables?: SortOrder
    daysPayables?: SortOrder
    cashUnlock?: SortOrder
    isActual?: SortOrder
    confidence?: SortOrder
    dataSource?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutiveMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExecutiveMetricWhereInput | ExecutiveMetricWhereInput[]
    OR?: ExecutiveMetricWhereInput[]
    NOT?: ExecutiveMetricWhereInput | ExecutiveMetricWhereInput[]
    date?: DateTimeFilter<"ExecutiveMetric"> | Date | string
    revenue?: FloatFilter<"ExecutiveMetric"> | number
    revenueTarget?: FloatFilter<"ExecutiveMetric"> | number
    revenueTrend?: FloatFilter<"ExecutiveMetric"> | number
    cashFlow?: FloatFilter<"ExecutiveMetric"> | number
    cashFlowTarget?: FloatFilter<"ExecutiveMetric"> | number
    cashFlowTrend?: FloatFilter<"ExecutiveMetric"> | number
    currentRatio?: FloatFilter<"ExecutiveMetric"> | number
    currentRatioTarget?: FloatFilter<"ExecutiveMetric"> | number
    currentRatioTrend?: FloatFilter<"ExecutiveMetric"> | number
    quickRatio?: FloatFilter<"ExecutiveMetric"> | number
    quickRatioTarget?: FloatFilter<"ExecutiveMetric"> | number
    quickRatioTrend?: FloatFilter<"ExecutiveMetric"> | number
    oee?: FloatFilter<"ExecutiveMetric"> | number
    oeeTarget?: FloatFilter<"ExecutiveMetric"> | number
    oeeTrend?: FloatFilter<"ExecutiveMetric"> | number
    throughput?: FloatFilter<"ExecutiveMetric"> | number
    throughputTarget?: FloatFilter<"ExecutiveMetric"> | number
    throughputTrend?: FloatFilter<"ExecutiveMetric"> | number
    marketShare?: FloatFilter<"ExecutiveMetric"> | number
    marketShareTarget?: FloatFilter<"ExecutiveMetric"> | number
    marketShareTrend?: FloatFilter<"ExecutiveMetric"> | number
    customerSatisfaction?: FloatFilter<"ExecutiveMetric"> | number
    customerSatisfactionTarget?: FloatFilter<"ExecutiveMetric"> | number
    customerSatisfactionTrend?: FloatFilter<"ExecutiveMetric"> | number
    currentAssets?: FloatFilter<"ExecutiveMetric"> | number
    currentLiabilities?: FloatFilter<"ExecutiveMetric"> | number
    inventory?: FloatFilter<"ExecutiveMetric"> | number
    daysInventory?: FloatFilter<"ExecutiveMetric"> | number
    daysReceivables?: FloatFilter<"ExecutiveMetric"> | number
    daysPayables?: FloatFilter<"ExecutiveMetric"> | number
    cashUnlock?: FloatFilter<"ExecutiveMetric"> | number
    isActual?: BoolFilter<"ExecutiveMetric"> | boolean
    confidence?: FloatFilter<"ExecutiveMetric"> | number
    dataSource?: StringFilter<"ExecutiveMetric"> | string
    notes?: StringNullableFilter<"ExecutiveMetric"> | string | null
    createdAt?: DateTimeFilter<"ExecutiveMetric"> | Date | string
    updatedAt?: DateTimeFilter<"ExecutiveMetric"> | Date | string
  }, "id">

  export type ExecutiveMetricOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    revenueTarget?: SortOrder
    revenueTrend?: SortOrder
    cashFlow?: SortOrder
    cashFlowTarget?: SortOrder
    cashFlowTrend?: SortOrder
    currentRatio?: SortOrder
    currentRatioTarget?: SortOrder
    currentRatioTrend?: SortOrder
    quickRatio?: SortOrder
    quickRatioTarget?: SortOrder
    quickRatioTrend?: SortOrder
    oee?: SortOrder
    oeeTarget?: SortOrder
    oeeTrend?: SortOrder
    throughput?: SortOrder
    throughputTarget?: SortOrder
    throughputTrend?: SortOrder
    marketShare?: SortOrder
    marketShareTarget?: SortOrder
    marketShareTrend?: SortOrder
    customerSatisfaction?: SortOrder
    customerSatisfactionTarget?: SortOrder
    customerSatisfactionTrend?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    daysInventory?: SortOrder
    daysReceivables?: SortOrder
    daysPayables?: SortOrder
    cashUnlock?: SortOrder
    isActual?: SortOrder
    confidence?: SortOrder
    dataSource?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExecutiveMetricCountOrderByAggregateInput
    _avg?: ExecutiveMetricAvgOrderByAggregateInput
    _max?: ExecutiveMetricMaxOrderByAggregateInput
    _min?: ExecutiveMetricMinOrderByAggregateInput
    _sum?: ExecutiveMetricSumOrderByAggregateInput
  }

  export type ExecutiveMetricScalarWhereWithAggregatesInput = {
    AND?: ExecutiveMetricScalarWhereWithAggregatesInput | ExecutiveMetricScalarWhereWithAggregatesInput[]
    OR?: ExecutiveMetricScalarWhereWithAggregatesInput[]
    NOT?: ExecutiveMetricScalarWhereWithAggregatesInput | ExecutiveMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExecutiveMetric"> | string
    date?: DateTimeWithAggregatesFilter<"ExecutiveMetric"> | Date | string
    revenue?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    revenueTarget?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    revenueTrend?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    cashFlow?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    cashFlowTarget?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    cashFlowTrend?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    currentRatio?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    currentRatioTarget?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    currentRatioTrend?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    quickRatio?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    quickRatioTarget?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    quickRatioTrend?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    oee?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    oeeTarget?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    oeeTrend?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    throughput?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    throughputTarget?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    throughputTrend?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    marketShare?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    marketShareTarget?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    marketShareTrend?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    customerSatisfaction?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    customerSatisfactionTarget?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    customerSatisfactionTrend?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    currentAssets?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    currentLiabilities?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    inventory?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    daysInventory?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    daysReceivables?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    daysPayables?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    cashUnlock?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    isActual?: BoolWithAggregatesFilter<"ExecutiveMetric"> | boolean
    confidence?: FloatWithAggregatesFilter<"ExecutiveMetric"> | number
    dataSource?: StringWithAggregatesFilter<"ExecutiveMetric"> | string
    notes?: StringNullableWithAggregatesFilter<"ExecutiveMetric"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExecutiveMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExecutiveMetric"> | Date | string
  }

  export type ExecutiveAlertWhereInput = {
    AND?: ExecutiveAlertWhereInput | ExecutiveAlertWhereInput[]
    OR?: ExecutiveAlertWhereInput[]
    NOT?: ExecutiveAlertWhereInput | ExecutiveAlertWhereInput[]
    id?: StringFilter<"ExecutiveAlert"> | string
    severity?: StringFilter<"ExecutiveAlert"> | string
    type?: StringFilter<"ExecutiveAlert"> | string
    category?: StringFilter<"ExecutiveAlert"> | string
    title?: StringFilter<"ExecutiveAlert"> | string
    description?: StringFilter<"ExecutiveAlert"> | string
    impact?: StringNullableFilter<"ExecutiveAlert"> | string | null
    action?: StringNullableFilter<"ExecutiveAlert"> | string | null
    source?: StringFilter<"ExecutiveAlert"> | string
    metrics?: JsonNullableFilter<"ExecutiveAlert">
    isActive?: BoolFilter<"ExecutiveAlert"> | boolean
    isDismissed?: BoolFilter<"ExecutiveAlert"> | boolean
    dismissedBy?: StringNullableFilter<"ExecutiveAlert"> | string | null
    dismissedAt?: DateTimeNullableFilter<"ExecutiveAlert"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ExecutiveAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"ExecutiveAlert"> | Date | string
    updatedAt?: DateTimeFilter<"ExecutiveAlert"> | Date | string
  }

  export type ExecutiveAlertOrderByWithRelationInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    impact?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    source?: SortOrder
    metrics?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDismissed?: SortOrder
    dismissedBy?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutiveAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExecutiveAlertWhereInput | ExecutiveAlertWhereInput[]
    OR?: ExecutiveAlertWhereInput[]
    NOT?: ExecutiveAlertWhereInput | ExecutiveAlertWhereInput[]
    severity?: StringFilter<"ExecutiveAlert"> | string
    type?: StringFilter<"ExecutiveAlert"> | string
    category?: StringFilter<"ExecutiveAlert"> | string
    title?: StringFilter<"ExecutiveAlert"> | string
    description?: StringFilter<"ExecutiveAlert"> | string
    impact?: StringNullableFilter<"ExecutiveAlert"> | string | null
    action?: StringNullableFilter<"ExecutiveAlert"> | string | null
    source?: StringFilter<"ExecutiveAlert"> | string
    metrics?: JsonNullableFilter<"ExecutiveAlert">
    isActive?: BoolFilter<"ExecutiveAlert"> | boolean
    isDismissed?: BoolFilter<"ExecutiveAlert"> | boolean
    dismissedBy?: StringNullableFilter<"ExecutiveAlert"> | string | null
    dismissedAt?: DateTimeNullableFilter<"ExecutiveAlert"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ExecutiveAlert"> | Date | string | null
    createdAt?: DateTimeFilter<"ExecutiveAlert"> | Date | string
    updatedAt?: DateTimeFilter<"ExecutiveAlert"> | Date | string
  }, "id">

  export type ExecutiveAlertOrderByWithAggregationInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    impact?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    source?: SortOrder
    metrics?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDismissed?: SortOrder
    dismissedBy?: SortOrderInput | SortOrder
    dismissedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExecutiveAlertCountOrderByAggregateInput
    _max?: ExecutiveAlertMaxOrderByAggregateInput
    _min?: ExecutiveAlertMinOrderByAggregateInput
  }

  export type ExecutiveAlertScalarWhereWithAggregatesInput = {
    AND?: ExecutiveAlertScalarWhereWithAggregatesInput | ExecutiveAlertScalarWhereWithAggregatesInput[]
    OR?: ExecutiveAlertScalarWhereWithAggregatesInput[]
    NOT?: ExecutiveAlertScalarWhereWithAggregatesInput | ExecutiveAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExecutiveAlert"> | string
    severity?: StringWithAggregatesFilter<"ExecutiveAlert"> | string
    type?: StringWithAggregatesFilter<"ExecutiveAlert"> | string
    category?: StringWithAggregatesFilter<"ExecutiveAlert"> | string
    title?: StringWithAggregatesFilter<"ExecutiveAlert"> | string
    description?: StringWithAggregatesFilter<"ExecutiveAlert"> | string
    impact?: StringNullableWithAggregatesFilter<"ExecutiveAlert"> | string | null
    action?: StringNullableWithAggregatesFilter<"ExecutiveAlert"> | string | null
    source?: StringWithAggregatesFilter<"ExecutiveAlert"> | string
    metrics?: JsonNullableWithAggregatesFilter<"ExecutiveAlert">
    isActive?: BoolWithAggregatesFilter<"ExecutiveAlert"> | boolean
    isDismissed?: BoolWithAggregatesFilter<"ExecutiveAlert"> | boolean
    dismissedBy?: StringNullableWithAggregatesFilter<"ExecutiveAlert"> | string | null
    dismissedAt?: DateTimeNullableWithAggregatesFilter<"ExecutiveAlert"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ExecutiveAlert"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExecutiveAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExecutiveAlert"> | Date | string
  }

  export type EnterpriseCashCoverageWhereInput = {
    AND?: EnterpriseCashCoverageWhereInput | EnterpriseCashCoverageWhereInput[]
    OR?: EnterpriseCashCoverageWhereInput[]
    NOT?: EnterpriseCashCoverageWhereInput | EnterpriseCashCoverageWhereInput[]
    id?: StringFilter<"EnterpriseCashCoverage"> | string
    period?: DateTimeFilter<"EnterpriseCashCoverage"> | Date | string
    startingCash?: FloatFilter<"EnterpriseCashCoverage"> | number
    endingCash?: FloatFilter<"EnterpriseCashCoverage"> | number
    salesRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    subscriptionRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    serviceRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    otherRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    totalRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    payrollExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    rentExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    utilitiesExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    marketingExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    suppliesExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    maintenanceExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    insuranceExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    professionalFees?: FloatFilter<"EnterpriseCashCoverage"> | number
    otherOperatingExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    totalOperatingExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    capitalExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    loanPayments?: FloatFilter<"EnterpriseCashCoverage"> | number
    taxPayments?: FloatFilter<"EnterpriseCashCoverage"> | number
    dividendPayments?: FloatFilter<"EnterpriseCashCoverage"> | number
    otherNonOperatingExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    netCashFlow?: FloatFilter<"EnterpriseCashCoverage"> | number
    operatingCashFlow?: FloatFilter<"EnterpriseCashCoverage"> | number
    financingCashFlow?: FloatFilter<"EnterpriseCashCoverage"> | number
    investingCashFlow?: FloatFilter<"EnterpriseCashCoverage"> | number
    cashCoverageRatio?: FloatFilter<"EnterpriseCashCoverage"> | number
    quickRatio?: FloatFilter<"EnterpriseCashCoverage"> | number
    currentRatio?: FloatFilter<"EnterpriseCashCoverage"> | number
    debtServiceCoverageRatio?: FloatFilter<"EnterpriseCashCoverage"> | number
    accountsReceivable?: FloatFilter<"EnterpriseCashCoverage"> | number
    accountsPayable?: FloatFilter<"EnterpriseCashCoverage"> | number
    inventory?: FloatFilter<"EnterpriseCashCoverage"> | number
    prepaidExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    accruedLiabilities?: FloatFilter<"EnterpriseCashCoverage"> | number
    daysOfCashOnHand?: FloatFilter<"EnterpriseCashCoverage"> | number
    burnRate?: FloatFilter<"EnterpriseCashCoverage"> | number
    runwayMonths?: FloatFilter<"EnterpriseCashCoverage"> | number
    isActual?: BoolFilter<"EnterpriseCashCoverage"> | boolean
    isForecast?: BoolFilter<"EnterpriseCashCoverage"> | boolean
    confidenceScore?: FloatFilter<"EnterpriseCashCoverage"> | number
    dataSource?: StringFilter<"EnterpriseCashCoverage"> | string
    importedFrom?: StringNullableFilter<"EnterpriseCashCoverage"> | string | null
    notes?: StringNullableFilter<"EnterpriseCashCoverage"> | string | null
    adjustments?: JsonNullableFilter<"EnterpriseCashCoverage">
    metadata?: JsonNullableFilter<"EnterpriseCashCoverage">
    createdAt?: DateTimeFilter<"EnterpriseCashCoverage"> | Date | string
    updatedAt?: DateTimeFilter<"EnterpriseCashCoverage"> | Date | string
  }

  export type EnterpriseCashCoverageOrderByWithRelationInput = {
    id?: SortOrder
    period?: SortOrder
    startingCash?: SortOrder
    endingCash?: SortOrder
    salesRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    serviceRevenue?: SortOrder
    otherRevenue?: SortOrder
    totalRevenue?: SortOrder
    payrollExpenses?: SortOrder
    rentExpenses?: SortOrder
    utilitiesExpenses?: SortOrder
    marketingExpenses?: SortOrder
    suppliesExpenses?: SortOrder
    maintenanceExpenses?: SortOrder
    insuranceExpenses?: SortOrder
    professionalFees?: SortOrder
    otherOperatingExpenses?: SortOrder
    totalOperatingExpenses?: SortOrder
    capitalExpenses?: SortOrder
    loanPayments?: SortOrder
    taxPayments?: SortOrder
    dividendPayments?: SortOrder
    otherNonOperatingExpenses?: SortOrder
    netCashFlow?: SortOrder
    operatingCashFlow?: SortOrder
    financingCashFlow?: SortOrder
    investingCashFlow?: SortOrder
    cashCoverageRatio?: SortOrder
    quickRatio?: SortOrder
    currentRatio?: SortOrder
    debtServiceCoverageRatio?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    inventory?: SortOrder
    prepaidExpenses?: SortOrder
    accruedLiabilities?: SortOrder
    daysOfCashOnHand?: SortOrder
    burnRate?: SortOrder
    runwayMonths?: SortOrder
    isActual?: SortOrder
    isForecast?: SortOrder
    confidenceScore?: SortOrder
    dataSource?: SortOrder
    importedFrom?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    adjustments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnterpriseCashCoverageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    period?: Date | string
    AND?: EnterpriseCashCoverageWhereInput | EnterpriseCashCoverageWhereInput[]
    OR?: EnterpriseCashCoverageWhereInput[]
    NOT?: EnterpriseCashCoverageWhereInput | EnterpriseCashCoverageWhereInput[]
    startingCash?: FloatFilter<"EnterpriseCashCoverage"> | number
    endingCash?: FloatFilter<"EnterpriseCashCoverage"> | number
    salesRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    subscriptionRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    serviceRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    otherRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    totalRevenue?: FloatFilter<"EnterpriseCashCoverage"> | number
    payrollExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    rentExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    utilitiesExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    marketingExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    suppliesExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    maintenanceExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    insuranceExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    professionalFees?: FloatFilter<"EnterpriseCashCoverage"> | number
    otherOperatingExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    totalOperatingExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    capitalExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    loanPayments?: FloatFilter<"EnterpriseCashCoverage"> | number
    taxPayments?: FloatFilter<"EnterpriseCashCoverage"> | number
    dividendPayments?: FloatFilter<"EnterpriseCashCoverage"> | number
    otherNonOperatingExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    netCashFlow?: FloatFilter<"EnterpriseCashCoverage"> | number
    operatingCashFlow?: FloatFilter<"EnterpriseCashCoverage"> | number
    financingCashFlow?: FloatFilter<"EnterpriseCashCoverage"> | number
    investingCashFlow?: FloatFilter<"EnterpriseCashCoverage"> | number
    cashCoverageRatio?: FloatFilter<"EnterpriseCashCoverage"> | number
    quickRatio?: FloatFilter<"EnterpriseCashCoverage"> | number
    currentRatio?: FloatFilter<"EnterpriseCashCoverage"> | number
    debtServiceCoverageRatio?: FloatFilter<"EnterpriseCashCoverage"> | number
    accountsReceivable?: FloatFilter<"EnterpriseCashCoverage"> | number
    accountsPayable?: FloatFilter<"EnterpriseCashCoverage"> | number
    inventory?: FloatFilter<"EnterpriseCashCoverage"> | number
    prepaidExpenses?: FloatFilter<"EnterpriseCashCoverage"> | number
    accruedLiabilities?: FloatFilter<"EnterpriseCashCoverage"> | number
    daysOfCashOnHand?: FloatFilter<"EnterpriseCashCoverage"> | number
    burnRate?: FloatFilter<"EnterpriseCashCoverage"> | number
    runwayMonths?: FloatFilter<"EnterpriseCashCoverage"> | number
    isActual?: BoolFilter<"EnterpriseCashCoverage"> | boolean
    isForecast?: BoolFilter<"EnterpriseCashCoverage"> | boolean
    confidenceScore?: FloatFilter<"EnterpriseCashCoverage"> | number
    dataSource?: StringFilter<"EnterpriseCashCoverage"> | string
    importedFrom?: StringNullableFilter<"EnterpriseCashCoverage"> | string | null
    notes?: StringNullableFilter<"EnterpriseCashCoverage"> | string | null
    adjustments?: JsonNullableFilter<"EnterpriseCashCoverage">
    metadata?: JsonNullableFilter<"EnterpriseCashCoverage">
    createdAt?: DateTimeFilter<"EnterpriseCashCoverage"> | Date | string
    updatedAt?: DateTimeFilter<"EnterpriseCashCoverage"> | Date | string
  }, "id" | "period">

  export type EnterpriseCashCoverageOrderByWithAggregationInput = {
    id?: SortOrder
    period?: SortOrder
    startingCash?: SortOrder
    endingCash?: SortOrder
    salesRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    serviceRevenue?: SortOrder
    otherRevenue?: SortOrder
    totalRevenue?: SortOrder
    payrollExpenses?: SortOrder
    rentExpenses?: SortOrder
    utilitiesExpenses?: SortOrder
    marketingExpenses?: SortOrder
    suppliesExpenses?: SortOrder
    maintenanceExpenses?: SortOrder
    insuranceExpenses?: SortOrder
    professionalFees?: SortOrder
    otherOperatingExpenses?: SortOrder
    totalOperatingExpenses?: SortOrder
    capitalExpenses?: SortOrder
    loanPayments?: SortOrder
    taxPayments?: SortOrder
    dividendPayments?: SortOrder
    otherNonOperatingExpenses?: SortOrder
    netCashFlow?: SortOrder
    operatingCashFlow?: SortOrder
    financingCashFlow?: SortOrder
    investingCashFlow?: SortOrder
    cashCoverageRatio?: SortOrder
    quickRatio?: SortOrder
    currentRatio?: SortOrder
    debtServiceCoverageRatio?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    inventory?: SortOrder
    prepaidExpenses?: SortOrder
    accruedLiabilities?: SortOrder
    daysOfCashOnHand?: SortOrder
    burnRate?: SortOrder
    runwayMonths?: SortOrder
    isActual?: SortOrder
    isForecast?: SortOrder
    confidenceScore?: SortOrder
    dataSource?: SortOrder
    importedFrom?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    adjustments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnterpriseCashCoverageCountOrderByAggregateInput
    _avg?: EnterpriseCashCoverageAvgOrderByAggregateInput
    _max?: EnterpriseCashCoverageMaxOrderByAggregateInput
    _min?: EnterpriseCashCoverageMinOrderByAggregateInput
    _sum?: EnterpriseCashCoverageSumOrderByAggregateInput
  }

  export type EnterpriseCashCoverageScalarWhereWithAggregatesInput = {
    AND?: EnterpriseCashCoverageScalarWhereWithAggregatesInput | EnterpriseCashCoverageScalarWhereWithAggregatesInput[]
    OR?: EnterpriseCashCoverageScalarWhereWithAggregatesInput[]
    NOT?: EnterpriseCashCoverageScalarWhereWithAggregatesInput | EnterpriseCashCoverageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EnterpriseCashCoverage"> | string
    period?: DateTimeWithAggregatesFilter<"EnterpriseCashCoverage"> | Date | string
    startingCash?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    endingCash?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    salesRevenue?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    subscriptionRevenue?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    serviceRevenue?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    otherRevenue?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    totalRevenue?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    payrollExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    rentExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    utilitiesExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    marketingExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    suppliesExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    maintenanceExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    insuranceExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    professionalFees?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    otherOperatingExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    totalOperatingExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    capitalExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    loanPayments?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    taxPayments?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    dividendPayments?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    otherNonOperatingExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    netCashFlow?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    operatingCashFlow?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    financingCashFlow?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    investingCashFlow?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    cashCoverageRatio?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    quickRatio?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    currentRatio?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    debtServiceCoverageRatio?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    accountsReceivable?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    accountsPayable?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    inventory?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    prepaidExpenses?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    accruedLiabilities?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    daysOfCashOnHand?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    burnRate?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    runwayMonths?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    isActual?: BoolWithAggregatesFilter<"EnterpriseCashCoverage"> | boolean
    isForecast?: BoolWithAggregatesFilter<"EnterpriseCashCoverage"> | boolean
    confidenceScore?: FloatWithAggregatesFilter<"EnterpriseCashCoverage"> | number
    dataSource?: StringWithAggregatesFilter<"EnterpriseCashCoverage"> | string
    importedFrom?: StringNullableWithAggregatesFilter<"EnterpriseCashCoverage"> | string | null
    notes?: StringNullableWithAggregatesFilter<"EnterpriseCashCoverage"> | string | null
    adjustments?: JsonNullableWithAggregatesFilter<"EnterpriseCashCoverage">
    metadata?: JsonNullableWithAggregatesFilter<"EnterpriseCashCoverage">
    createdAt?: DateTimeWithAggregatesFilter<"EnterpriseCashCoverage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EnterpriseCashCoverage"> | Date | string
  }

  export type XeroAccountWhereInput = {
    AND?: XeroAccountWhereInput | XeroAccountWhereInput[]
    OR?: XeroAccountWhereInput[]
    NOT?: XeroAccountWhereInput | XeroAccountWhereInput[]
    id?: StringFilter<"XeroAccount"> | string
    xeroId?: StringFilter<"XeroAccount"> | string
    code?: StringNullableFilter<"XeroAccount"> | string | null
    name?: StringFilter<"XeroAccount"> | string
    type?: StringFilter<"XeroAccount"> | string
    bankAccountNumber?: StringNullableFilter<"XeroAccount"> | string | null
    status?: StringFilter<"XeroAccount"> | string
    description?: StringNullableFilter<"XeroAccount"> | string | null
    class?: StringNullableFilter<"XeroAccount"> | string | null
    systemAccount?: StringNullableFilter<"XeroAccount"> | string | null
    enablePaymentsToAccount?: BoolFilter<"XeroAccount"> | boolean
    showInExpenseClaims?: BoolFilter<"XeroAccount"> | boolean
    createdAt?: DateTimeFilter<"XeroAccount"> | Date | string
    updatedAt?: DateTimeFilter<"XeroAccount"> | Date | string
  }

  export type XeroAccountOrderByWithRelationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    bankAccountNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    class?: SortOrderInput | SortOrder
    systemAccount?: SortOrderInput | SortOrder
    enablePaymentsToAccount?: SortOrder
    showInExpenseClaims?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    xeroId?: string
    AND?: XeroAccountWhereInput | XeroAccountWhereInput[]
    OR?: XeroAccountWhereInput[]
    NOT?: XeroAccountWhereInput | XeroAccountWhereInput[]
    code?: StringNullableFilter<"XeroAccount"> | string | null
    name?: StringFilter<"XeroAccount"> | string
    type?: StringFilter<"XeroAccount"> | string
    bankAccountNumber?: StringNullableFilter<"XeroAccount"> | string | null
    status?: StringFilter<"XeroAccount"> | string
    description?: StringNullableFilter<"XeroAccount"> | string | null
    class?: StringNullableFilter<"XeroAccount"> | string | null
    systemAccount?: StringNullableFilter<"XeroAccount"> | string | null
    enablePaymentsToAccount?: BoolFilter<"XeroAccount"> | boolean
    showInExpenseClaims?: BoolFilter<"XeroAccount"> | boolean
    createdAt?: DateTimeFilter<"XeroAccount"> | Date | string
    updatedAt?: DateTimeFilter<"XeroAccount"> | Date | string
  }, "id" | "xeroId">

  export type XeroAccountOrderByWithAggregationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    bankAccountNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    class?: SortOrderInput | SortOrder
    systemAccount?: SortOrderInput | SortOrder
    enablePaymentsToAccount?: SortOrder
    showInExpenseClaims?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XeroAccountCountOrderByAggregateInput
    _max?: XeroAccountMaxOrderByAggregateInput
    _min?: XeroAccountMinOrderByAggregateInput
  }

  export type XeroAccountScalarWhereWithAggregatesInput = {
    AND?: XeroAccountScalarWhereWithAggregatesInput | XeroAccountScalarWhereWithAggregatesInput[]
    OR?: XeroAccountScalarWhereWithAggregatesInput[]
    NOT?: XeroAccountScalarWhereWithAggregatesInput | XeroAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XeroAccount"> | string
    xeroId?: StringWithAggregatesFilter<"XeroAccount"> | string
    code?: StringNullableWithAggregatesFilter<"XeroAccount"> | string | null
    name?: StringWithAggregatesFilter<"XeroAccount"> | string
    type?: StringWithAggregatesFilter<"XeroAccount"> | string
    bankAccountNumber?: StringNullableWithAggregatesFilter<"XeroAccount"> | string | null
    status?: StringWithAggregatesFilter<"XeroAccount"> | string
    description?: StringNullableWithAggregatesFilter<"XeroAccount"> | string | null
    class?: StringNullableWithAggregatesFilter<"XeroAccount"> | string | null
    systemAccount?: StringNullableWithAggregatesFilter<"XeroAccount"> | string | null
    enablePaymentsToAccount?: BoolWithAggregatesFilter<"XeroAccount"> | boolean
    showInExpenseClaims?: BoolWithAggregatesFilter<"XeroAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"XeroAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XeroAccount"> | Date | string
  }

  export type XeroContactWhereInput = {
    AND?: XeroContactWhereInput | XeroContactWhereInput[]
    OR?: XeroContactWhereInput[]
    NOT?: XeroContactWhereInput | XeroContactWhereInput[]
    id?: StringFilter<"XeroContact"> | string
    xeroId?: StringFilter<"XeroContact"> | string
    name?: StringFilter<"XeroContact"> | string
    firstName?: StringNullableFilter<"XeroContact"> | string | null
    lastName?: StringNullableFilter<"XeroContact"> | string | null
    emailAddress?: StringNullableFilter<"XeroContact"> | string | null
    contactStatus?: StringNullableFilter<"XeroContact"> | string | null
    isSupplier?: BoolFilter<"XeroContact"> | boolean
    isCustomer?: BoolFilter<"XeroContact"> | boolean
    defaultCurrency?: StringNullableFilter<"XeroContact"> | string | null
    accountNumber?: StringNullableFilter<"XeroContact"> | string | null
    companyNumber?: StringNullableFilter<"XeroContact"> | string | null
    createdAt?: DateTimeFilter<"XeroContact"> | Date | string
    updatedAt?: DateTimeFilter<"XeroContact"> | Date | string
    invoices?: XeroInvoiceListRelationFilter
    bills?: XeroBillListRelationFilter
    payments?: XeroPaymentListRelationFilter
  }

  export type XeroContactOrderByWithRelationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    name?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    emailAddress?: SortOrderInput | SortOrder
    contactStatus?: SortOrderInput | SortOrder
    isSupplier?: SortOrder
    isCustomer?: SortOrder
    defaultCurrency?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    companyNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoices?: XeroInvoiceOrderByRelationAggregateInput
    bills?: XeroBillOrderByRelationAggregateInput
    payments?: XeroPaymentOrderByRelationAggregateInput
  }

  export type XeroContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    xeroId?: string
    AND?: XeroContactWhereInput | XeroContactWhereInput[]
    OR?: XeroContactWhereInput[]
    NOT?: XeroContactWhereInput | XeroContactWhereInput[]
    name?: StringFilter<"XeroContact"> | string
    firstName?: StringNullableFilter<"XeroContact"> | string | null
    lastName?: StringNullableFilter<"XeroContact"> | string | null
    emailAddress?: StringNullableFilter<"XeroContact"> | string | null
    contactStatus?: StringNullableFilter<"XeroContact"> | string | null
    isSupplier?: BoolFilter<"XeroContact"> | boolean
    isCustomer?: BoolFilter<"XeroContact"> | boolean
    defaultCurrency?: StringNullableFilter<"XeroContact"> | string | null
    accountNumber?: StringNullableFilter<"XeroContact"> | string | null
    companyNumber?: StringNullableFilter<"XeroContact"> | string | null
    createdAt?: DateTimeFilter<"XeroContact"> | Date | string
    updatedAt?: DateTimeFilter<"XeroContact"> | Date | string
    invoices?: XeroInvoiceListRelationFilter
    bills?: XeroBillListRelationFilter
    payments?: XeroPaymentListRelationFilter
  }, "id" | "xeroId">

  export type XeroContactOrderByWithAggregationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    name?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    emailAddress?: SortOrderInput | SortOrder
    contactStatus?: SortOrderInput | SortOrder
    isSupplier?: SortOrder
    isCustomer?: SortOrder
    defaultCurrency?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    companyNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XeroContactCountOrderByAggregateInput
    _max?: XeroContactMaxOrderByAggregateInput
    _min?: XeroContactMinOrderByAggregateInput
  }

  export type XeroContactScalarWhereWithAggregatesInput = {
    AND?: XeroContactScalarWhereWithAggregatesInput | XeroContactScalarWhereWithAggregatesInput[]
    OR?: XeroContactScalarWhereWithAggregatesInput[]
    NOT?: XeroContactScalarWhereWithAggregatesInput | XeroContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XeroContact"> | string
    xeroId?: StringWithAggregatesFilter<"XeroContact"> | string
    name?: StringWithAggregatesFilter<"XeroContact"> | string
    firstName?: StringNullableWithAggregatesFilter<"XeroContact"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"XeroContact"> | string | null
    emailAddress?: StringNullableWithAggregatesFilter<"XeroContact"> | string | null
    contactStatus?: StringNullableWithAggregatesFilter<"XeroContact"> | string | null
    isSupplier?: BoolWithAggregatesFilter<"XeroContact"> | boolean
    isCustomer?: BoolWithAggregatesFilter<"XeroContact"> | boolean
    defaultCurrency?: StringNullableWithAggregatesFilter<"XeroContact"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"XeroContact"> | string | null
    companyNumber?: StringNullableWithAggregatesFilter<"XeroContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"XeroContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XeroContact"> | Date | string
  }

  export type XeroInvoiceWhereInput = {
    AND?: XeroInvoiceWhereInput | XeroInvoiceWhereInput[]
    OR?: XeroInvoiceWhereInput[]
    NOT?: XeroInvoiceWhereInput | XeroInvoiceWhereInput[]
    id?: StringFilter<"XeroInvoice"> | string
    xeroId?: StringFilter<"XeroInvoice"> | string
    invoiceNumber?: StringNullableFilter<"XeroInvoice"> | string | null
    reference?: StringNullableFilter<"XeroInvoice"> | string | null
    type?: StringFilter<"XeroInvoice"> | string
    contactId?: StringFilter<"XeroInvoice"> | string
    date?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    status?: StringFilter<"XeroInvoice"> | string
    lineAmountTypes?: StringNullableFilter<"XeroInvoice"> | string | null
    subTotal?: FloatNullableFilter<"XeroInvoice"> | number | null
    totalTax?: FloatNullableFilter<"XeroInvoice"> | number | null
    total?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountDue?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountPaid?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountCredited?: FloatNullableFilter<"XeroInvoice"> | number | null
    currencyCode?: StringFilter<"XeroInvoice"> | string
    fullyPaidOnDate?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"XeroInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"XeroInvoice"> | Date | string
    contact?: XOR<XeroContactScalarRelationFilter, XeroContactWhereInput>
    payments?: XeroPaymentListRelationFilter
  }

  export type XeroInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrderInput | SortOrder
    subTotal?: SortOrderInput | SortOrder
    totalTax?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    amountDue?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    amountCredited?: SortOrderInput | SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: XeroContactOrderByWithRelationInput
    payments?: XeroPaymentOrderByRelationAggregateInput
  }

  export type XeroInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    xeroId?: string
    AND?: XeroInvoiceWhereInput | XeroInvoiceWhereInput[]
    OR?: XeroInvoiceWhereInput[]
    NOT?: XeroInvoiceWhereInput | XeroInvoiceWhereInput[]
    invoiceNumber?: StringNullableFilter<"XeroInvoice"> | string | null
    reference?: StringNullableFilter<"XeroInvoice"> | string | null
    type?: StringFilter<"XeroInvoice"> | string
    contactId?: StringFilter<"XeroInvoice"> | string
    date?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    status?: StringFilter<"XeroInvoice"> | string
    lineAmountTypes?: StringNullableFilter<"XeroInvoice"> | string | null
    subTotal?: FloatNullableFilter<"XeroInvoice"> | number | null
    totalTax?: FloatNullableFilter<"XeroInvoice"> | number | null
    total?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountDue?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountPaid?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountCredited?: FloatNullableFilter<"XeroInvoice"> | number | null
    currencyCode?: StringFilter<"XeroInvoice"> | string
    fullyPaidOnDate?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"XeroInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"XeroInvoice"> | Date | string
    contact?: XOR<XeroContactScalarRelationFilter, XeroContactWhereInput>
    payments?: XeroPaymentListRelationFilter
  }, "id" | "xeroId">

  export type XeroInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrderInput | SortOrder
    subTotal?: SortOrderInput | SortOrder
    totalTax?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    amountDue?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    amountCredited?: SortOrderInput | SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XeroInvoiceCountOrderByAggregateInput
    _avg?: XeroInvoiceAvgOrderByAggregateInput
    _max?: XeroInvoiceMaxOrderByAggregateInput
    _min?: XeroInvoiceMinOrderByAggregateInput
    _sum?: XeroInvoiceSumOrderByAggregateInput
  }

  export type XeroInvoiceScalarWhereWithAggregatesInput = {
    AND?: XeroInvoiceScalarWhereWithAggregatesInput | XeroInvoiceScalarWhereWithAggregatesInput[]
    OR?: XeroInvoiceScalarWhereWithAggregatesInput[]
    NOT?: XeroInvoiceScalarWhereWithAggregatesInput | XeroInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XeroInvoice"> | string
    xeroId?: StringWithAggregatesFilter<"XeroInvoice"> | string
    invoiceNumber?: StringNullableWithAggregatesFilter<"XeroInvoice"> | string | null
    reference?: StringNullableWithAggregatesFilter<"XeroInvoice"> | string | null
    type?: StringWithAggregatesFilter<"XeroInvoice"> | string
    contactId?: StringWithAggregatesFilter<"XeroInvoice"> | string
    date?: DateTimeNullableWithAggregatesFilter<"XeroInvoice"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"XeroInvoice"> | Date | string | null
    status?: StringWithAggregatesFilter<"XeroInvoice"> | string
    lineAmountTypes?: StringNullableWithAggregatesFilter<"XeroInvoice"> | string | null
    subTotal?: FloatNullableWithAggregatesFilter<"XeroInvoice"> | number | null
    totalTax?: FloatNullableWithAggregatesFilter<"XeroInvoice"> | number | null
    total?: FloatNullableWithAggregatesFilter<"XeroInvoice"> | number | null
    amountDue?: FloatNullableWithAggregatesFilter<"XeroInvoice"> | number | null
    amountPaid?: FloatNullableWithAggregatesFilter<"XeroInvoice"> | number | null
    amountCredited?: FloatNullableWithAggregatesFilter<"XeroInvoice"> | number | null
    currencyCode?: StringWithAggregatesFilter<"XeroInvoice"> | string
    fullyPaidOnDate?: DateTimeNullableWithAggregatesFilter<"XeroInvoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"XeroInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XeroInvoice"> | Date | string
  }

  export type XeroBillWhereInput = {
    AND?: XeroBillWhereInput | XeroBillWhereInput[]
    OR?: XeroBillWhereInput[]
    NOT?: XeroBillWhereInput | XeroBillWhereInput[]
    id?: StringFilter<"XeroBill"> | string
    xeroId?: StringFilter<"XeroBill"> | string
    billNumber?: StringNullableFilter<"XeroBill"> | string | null
    reference?: StringNullableFilter<"XeroBill"> | string | null
    type?: StringFilter<"XeroBill"> | string
    contactId?: StringFilter<"XeroBill"> | string
    date?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    status?: StringFilter<"XeroBill"> | string
    lineAmountTypes?: StringNullableFilter<"XeroBill"> | string | null
    subTotal?: FloatNullableFilter<"XeroBill"> | number | null
    totalTax?: FloatNullableFilter<"XeroBill"> | number | null
    total?: FloatNullableFilter<"XeroBill"> | number | null
    amountDue?: FloatNullableFilter<"XeroBill"> | number | null
    amountPaid?: FloatNullableFilter<"XeroBill"> | number | null
    amountCredited?: FloatNullableFilter<"XeroBill"> | number | null
    currencyCode?: StringFilter<"XeroBill"> | string
    fullyPaidOnDate?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    createdAt?: DateTimeFilter<"XeroBill"> | Date | string
    updatedAt?: DateTimeFilter<"XeroBill"> | Date | string
    contact?: XOR<XeroContactScalarRelationFilter, XeroContactWhereInput>
    payments?: XeroPaymentListRelationFilter
  }

  export type XeroBillOrderByWithRelationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    billNumber?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrderInput | SortOrder
    subTotal?: SortOrderInput | SortOrder
    totalTax?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    amountDue?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    amountCredited?: SortOrderInput | SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: XeroContactOrderByWithRelationInput
    payments?: XeroPaymentOrderByRelationAggregateInput
  }

  export type XeroBillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    xeroId?: string
    AND?: XeroBillWhereInput | XeroBillWhereInput[]
    OR?: XeroBillWhereInput[]
    NOT?: XeroBillWhereInput | XeroBillWhereInput[]
    billNumber?: StringNullableFilter<"XeroBill"> | string | null
    reference?: StringNullableFilter<"XeroBill"> | string | null
    type?: StringFilter<"XeroBill"> | string
    contactId?: StringFilter<"XeroBill"> | string
    date?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    status?: StringFilter<"XeroBill"> | string
    lineAmountTypes?: StringNullableFilter<"XeroBill"> | string | null
    subTotal?: FloatNullableFilter<"XeroBill"> | number | null
    totalTax?: FloatNullableFilter<"XeroBill"> | number | null
    total?: FloatNullableFilter<"XeroBill"> | number | null
    amountDue?: FloatNullableFilter<"XeroBill"> | number | null
    amountPaid?: FloatNullableFilter<"XeroBill"> | number | null
    amountCredited?: FloatNullableFilter<"XeroBill"> | number | null
    currencyCode?: StringFilter<"XeroBill"> | string
    fullyPaidOnDate?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    createdAt?: DateTimeFilter<"XeroBill"> | Date | string
    updatedAt?: DateTimeFilter<"XeroBill"> | Date | string
    contact?: XOR<XeroContactScalarRelationFilter, XeroContactWhereInput>
    payments?: XeroPaymentListRelationFilter
  }, "id" | "xeroId">

  export type XeroBillOrderByWithAggregationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    billNumber?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrderInput | SortOrder
    subTotal?: SortOrderInput | SortOrder
    totalTax?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    amountDue?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    amountCredited?: SortOrderInput | SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XeroBillCountOrderByAggregateInput
    _avg?: XeroBillAvgOrderByAggregateInput
    _max?: XeroBillMaxOrderByAggregateInput
    _min?: XeroBillMinOrderByAggregateInput
    _sum?: XeroBillSumOrderByAggregateInput
  }

  export type XeroBillScalarWhereWithAggregatesInput = {
    AND?: XeroBillScalarWhereWithAggregatesInput | XeroBillScalarWhereWithAggregatesInput[]
    OR?: XeroBillScalarWhereWithAggregatesInput[]
    NOT?: XeroBillScalarWhereWithAggregatesInput | XeroBillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XeroBill"> | string
    xeroId?: StringWithAggregatesFilter<"XeroBill"> | string
    billNumber?: StringNullableWithAggregatesFilter<"XeroBill"> | string | null
    reference?: StringNullableWithAggregatesFilter<"XeroBill"> | string | null
    type?: StringWithAggregatesFilter<"XeroBill"> | string
    contactId?: StringWithAggregatesFilter<"XeroBill"> | string
    date?: DateTimeNullableWithAggregatesFilter<"XeroBill"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"XeroBill"> | Date | string | null
    status?: StringWithAggregatesFilter<"XeroBill"> | string
    lineAmountTypes?: StringNullableWithAggregatesFilter<"XeroBill"> | string | null
    subTotal?: FloatNullableWithAggregatesFilter<"XeroBill"> | number | null
    totalTax?: FloatNullableWithAggregatesFilter<"XeroBill"> | number | null
    total?: FloatNullableWithAggregatesFilter<"XeroBill"> | number | null
    amountDue?: FloatNullableWithAggregatesFilter<"XeroBill"> | number | null
    amountPaid?: FloatNullableWithAggregatesFilter<"XeroBill"> | number | null
    amountCredited?: FloatNullableWithAggregatesFilter<"XeroBill"> | number | null
    currencyCode?: StringWithAggregatesFilter<"XeroBill"> | string
    fullyPaidOnDate?: DateTimeNullableWithAggregatesFilter<"XeroBill"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"XeroBill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XeroBill"> | Date | string
  }

  export type XeroPaymentWhereInput = {
    AND?: XeroPaymentWhereInput | XeroPaymentWhereInput[]
    OR?: XeroPaymentWhereInput[]
    NOT?: XeroPaymentWhereInput | XeroPaymentWhereInput[]
    id?: StringFilter<"XeroPayment"> | string
    xeroId?: StringFilter<"XeroPayment"> | string
    date?: DateTimeNullableFilter<"XeroPayment"> | Date | string | null
    amount?: FloatNullableFilter<"XeroPayment"> | number | null
    currencyCode?: StringFilter<"XeroPayment"> | string
    paymentType?: StringNullableFilter<"XeroPayment"> | string | null
    status?: StringNullableFilter<"XeroPayment"> | string | null
    isReconciled?: BoolFilter<"XeroPayment"> | boolean
    reference?: StringNullableFilter<"XeroPayment"> | string | null
    batchPaymentId?: StringNullableFilter<"XeroPayment"> | string | null
    contactId?: StringNullableFilter<"XeroPayment"> | string | null
    invoiceId?: StringNullableFilter<"XeroPayment"> | string | null
    billId?: StringNullableFilter<"XeroPayment"> | string | null
    createdAt?: DateTimeFilter<"XeroPayment"> | Date | string
    updatedAt?: DateTimeFilter<"XeroPayment"> | Date | string
    contact?: XOR<XeroContactNullableScalarRelationFilter, XeroContactWhereInput> | null
    invoice?: XOR<XeroInvoiceNullableScalarRelationFilter, XeroInvoiceWhereInput> | null
    bill?: XOR<XeroBillNullableScalarRelationFilter, XeroBillWhereInput> | null
  }

  export type XeroPaymentOrderByWithRelationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    date?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currencyCode?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    isReconciled?: SortOrder
    reference?: SortOrderInput | SortOrder
    batchPaymentId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    billId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: XeroContactOrderByWithRelationInput
    invoice?: XeroInvoiceOrderByWithRelationInput
    bill?: XeroBillOrderByWithRelationInput
  }

  export type XeroPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    xeroId?: string
    AND?: XeroPaymentWhereInput | XeroPaymentWhereInput[]
    OR?: XeroPaymentWhereInput[]
    NOT?: XeroPaymentWhereInput | XeroPaymentWhereInput[]
    date?: DateTimeNullableFilter<"XeroPayment"> | Date | string | null
    amount?: FloatNullableFilter<"XeroPayment"> | number | null
    currencyCode?: StringFilter<"XeroPayment"> | string
    paymentType?: StringNullableFilter<"XeroPayment"> | string | null
    status?: StringNullableFilter<"XeroPayment"> | string | null
    isReconciled?: BoolFilter<"XeroPayment"> | boolean
    reference?: StringNullableFilter<"XeroPayment"> | string | null
    batchPaymentId?: StringNullableFilter<"XeroPayment"> | string | null
    contactId?: StringNullableFilter<"XeroPayment"> | string | null
    invoiceId?: StringNullableFilter<"XeroPayment"> | string | null
    billId?: StringNullableFilter<"XeroPayment"> | string | null
    createdAt?: DateTimeFilter<"XeroPayment"> | Date | string
    updatedAt?: DateTimeFilter<"XeroPayment"> | Date | string
    contact?: XOR<XeroContactNullableScalarRelationFilter, XeroContactWhereInput> | null
    invoice?: XOR<XeroInvoiceNullableScalarRelationFilter, XeroInvoiceWhereInput> | null
    bill?: XOR<XeroBillNullableScalarRelationFilter, XeroBillWhereInput> | null
  }, "id" | "xeroId">

  export type XeroPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    date?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currencyCode?: SortOrder
    paymentType?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    isReconciled?: SortOrder
    reference?: SortOrderInput | SortOrder
    batchPaymentId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    billId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XeroPaymentCountOrderByAggregateInput
    _avg?: XeroPaymentAvgOrderByAggregateInput
    _max?: XeroPaymentMaxOrderByAggregateInput
    _min?: XeroPaymentMinOrderByAggregateInput
    _sum?: XeroPaymentSumOrderByAggregateInput
  }

  export type XeroPaymentScalarWhereWithAggregatesInput = {
    AND?: XeroPaymentScalarWhereWithAggregatesInput | XeroPaymentScalarWhereWithAggregatesInput[]
    OR?: XeroPaymentScalarWhereWithAggregatesInput[]
    NOT?: XeroPaymentScalarWhereWithAggregatesInput | XeroPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XeroPayment"> | string
    xeroId?: StringWithAggregatesFilter<"XeroPayment"> | string
    date?: DateTimeNullableWithAggregatesFilter<"XeroPayment"> | Date | string | null
    amount?: FloatNullableWithAggregatesFilter<"XeroPayment"> | number | null
    currencyCode?: StringWithAggregatesFilter<"XeroPayment"> | string
    paymentType?: StringNullableWithAggregatesFilter<"XeroPayment"> | string | null
    status?: StringNullableWithAggregatesFilter<"XeroPayment"> | string | null
    isReconciled?: BoolWithAggregatesFilter<"XeroPayment"> | boolean
    reference?: StringNullableWithAggregatesFilter<"XeroPayment"> | string | null
    batchPaymentId?: StringNullableWithAggregatesFilter<"XeroPayment"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"XeroPayment"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"XeroPayment"> | string | null
    billId?: StringNullableWithAggregatesFilter<"XeroPayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"XeroPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XeroPayment"> | Date | string
  }

  export type XeroBankTransactionWhereInput = {
    AND?: XeroBankTransactionWhereInput | XeroBankTransactionWhereInput[]
    OR?: XeroBankTransactionWhereInput[]
    NOT?: XeroBankTransactionWhereInput | XeroBankTransactionWhereInput[]
    id?: StringFilter<"XeroBankTransaction"> | string
    xeroId?: StringFilter<"XeroBankTransaction"> | string
    bankAccountId?: StringNullableFilter<"XeroBankTransaction"> | string | null
    type?: StringFilter<"XeroBankTransaction"> | string
    date?: DateTimeNullableFilter<"XeroBankTransaction"> | Date | string | null
    reference?: StringNullableFilter<"XeroBankTransaction"> | string | null
    amount?: FloatNullableFilter<"XeroBankTransaction"> | number | null
    currencyCode?: StringFilter<"XeroBankTransaction"> | string
    status?: StringNullableFilter<"XeroBankTransaction"> | string | null
    isReconciled?: BoolFilter<"XeroBankTransaction"> | boolean
    description?: StringNullableFilter<"XeroBankTransaction"> | string | null
    createdAt?: DateTimeFilter<"XeroBankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"XeroBankTransaction"> | Date | string
  }

  export type XeroBankTransactionOrderByWithRelationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    bankAccountId?: SortOrderInput | SortOrder
    type?: SortOrder
    date?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currencyCode?: SortOrder
    status?: SortOrderInput | SortOrder
    isReconciled?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroBankTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    xeroId?: string
    AND?: XeroBankTransactionWhereInput | XeroBankTransactionWhereInput[]
    OR?: XeroBankTransactionWhereInput[]
    NOT?: XeroBankTransactionWhereInput | XeroBankTransactionWhereInput[]
    bankAccountId?: StringNullableFilter<"XeroBankTransaction"> | string | null
    type?: StringFilter<"XeroBankTransaction"> | string
    date?: DateTimeNullableFilter<"XeroBankTransaction"> | Date | string | null
    reference?: StringNullableFilter<"XeroBankTransaction"> | string | null
    amount?: FloatNullableFilter<"XeroBankTransaction"> | number | null
    currencyCode?: StringFilter<"XeroBankTransaction"> | string
    status?: StringNullableFilter<"XeroBankTransaction"> | string | null
    isReconciled?: BoolFilter<"XeroBankTransaction"> | boolean
    description?: StringNullableFilter<"XeroBankTransaction"> | string | null
    createdAt?: DateTimeFilter<"XeroBankTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"XeroBankTransaction"> | Date | string
  }, "id" | "xeroId">

  export type XeroBankTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    bankAccountId?: SortOrderInput | SortOrder
    type?: SortOrder
    date?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currencyCode?: SortOrder
    status?: SortOrderInput | SortOrder
    isReconciled?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XeroBankTransactionCountOrderByAggregateInput
    _avg?: XeroBankTransactionAvgOrderByAggregateInput
    _max?: XeroBankTransactionMaxOrderByAggregateInput
    _min?: XeroBankTransactionMinOrderByAggregateInput
    _sum?: XeroBankTransactionSumOrderByAggregateInput
  }

  export type XeroBankTransactionScalarWhereWithAggregatesInput = {
    AND?: XeroBankTransactionScalarWhereWithAggregatesInput | XeroBankTransactionScalarWhereWithAggregatesInput[]
    OR?: XeroBankTransactionScalarWhereWithAggregatesInput[]
    NOT?: XeroBankTransactionScalarWhereWithAggregatesInput | XeroBankTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XeroBankTransaction"> | string
    xeroId?: StringWithAggregatesFilter<"XeroBankTransaction"> | string
    bankAccountId?: StringNullableWithAggregatesFilter<"XeroBankTransaction"> | string | null
    type?: StringWithAggregatesFilter<"XeroBankTransaction"> | string
    date?: DateTimeNullableWithAggregatesFilter<"XeroBankTransaction"> | Date | string | null
    reference?: StringNullableWithAggregatesFilter<"XeroBankTransaction"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"XeroBankTransaction"> | number | null
    currencyCode?: StringWithAggregatesFilter<"XeroBankTransaction"> | string
    status?: StringNullableWithAggregatesFilter<"XeroBankTransaction"> | string | null
    isReconciled?: BoolWithAggregatesFilter<"XeroBankTransaction"> | boolean
    description?: StringNullableWithAggregatesFilter<"XeroBankTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"XeroBankTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XeroBankTransaction"> | Date | string
  }

  export type XeroItemWhereInput = {
    AND?: XeroItemWhereInput | XeroItemWhereInput[]
    OR?: XeroItemWhereInput[]
    NOT?: XeroItemWhereInput | XeroItemWhereInput[]
    id?: StringFilter<"XeroItem"> | string
    xeroId?: StringFilter<"XeroItem"> | string
    code?: StringNullableFilter<"XeroItem"> | string | null
    name?: StringFilter<"XeroItem"> | string
    description?: StringNullableFilter<"XeroItem"> | string | null
    salesDetails?: JsonNullableFilter<"XeroItem">
    purchaseDetails?: JsonNullableFilter<"XeroItem">
    isTrackedAsInventory?: BoolFilter<"XeroItem"> | boolean
    isSold?: BoolFilter<"XeroItem"> | boolean
    isPurchased?: BoolFilter<"XeroItem"> | boolean
    createdAt?: DateTimeFilter<"XeroItem"> | Date | string
    updatedAt?: DateTimeFilter<"XeroItem"> | Date | string
  }

  export type XeroItemOrderByWithRelationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    salesDetails?: SortOrderInput | SortOrder
    purchaseDetails?: SortOrderInput | SortOrder
    isTrackedAsInventory?: SortOrder
    isSold?: SortOrder
    isPurchased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    xeroId?: string
    AND?: XeroItemWhereInput | XeroItemWhereInput[]
    OR?: XeroItemWhereInput[]
    NOT?: XeroItemWhereInput | XeroItemWhereInput[]
    code?: StringNullableFilter<"XeroItem"> | string | null
    name?: StringFilter<"XeroItem"> | string
    description?: StringNullableFilter<"XeroItem"> | string | null
    salesDetails?: JsonNullableFilter<"XeroItem">
    purchaseDetails?: JsonNullableFilter<"XeroItem">
    isTrackedAsInventory?: BoolFilter<"XeroItem"> | boolean
    isSold?: BoolFilter<"XeroItem"> | boolean
    isPurchased?: BoolFilter<"XeroItem"> | boolean
    createdAt?: DateTimeFilter<"XeroItem"> | Date | string
    updatedAt?: DateTimeFilter<"XeroItem"> | Date | string
  }, "id" | "xeroId">

  export type XeroItemOrderByWithAggregationInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    salesDetails?: SortOrderInput | SortOrder
    purchaseDetails?: SortOrderInput | SortOrder
    isTrackedAsInventory?: SortOrder
    isSold?: SortOrder
    isPurchased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: XeroItemCountOrderByAggregateInput
    _max?: XeroItemMaxOrderByAggregateInput
    _min?: XeroItemMinOrderByAggregateInput
  }

  export type XeroItemScalarWhereWithAggregatesInput = {
    AND?: XeroItemScalarWhereWithAggregatesInput | XeroItemScalarWhereWithAggregatesInput[]
    OR?: XeroItemScalarWhereWithAggregatesInput[]
    NOT?: XeroItemScalarWhereWithAggregatesInput | XeroItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"XeroItem"> | string
    xeroId?: StringWithAggregatesFilter<"XeroItem"> | string
    code?: StringNullableWithAggregatesFilter<"XeroItem"> | string | null
    name?: StringWithAggregatesFilter<"XeroItem"> | string
    description?: StringNullableWithAggregatesFilter<"XeroItem"> | string | null
    salesDetails?: JsonNullableWithAggregatesFilter<"XeroItem">
    purchaseDetails?: JsonNullableWithAggregatesFilter<"XeroItem">
    isTrackedAsInventory?: BoolWithAggregatesFilter<"XeroItem"> | boolean
    isSold?: BoolWithAggregatesFilter<"XeroItem"> | boolean
    isPurchased?: BoolWithAggregatesFilter<"XeroItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"XeroItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"XeroItem"> | Date | string
  }

  export type AmazonOrderWhereInput = {
    AND?: AmazonOrderWhereInput | AmazonOrderWhereInput[]
    OR?: AmazonOrderWhereInput[]
    NOT?: AmazonOrderWhereInput | AmazonOrderWhereInput[]
    id?: StringFilter<"AmazonOrder"> | string
    amazonOrderId?: StringFilter<"AmazonOrder"> | string
    marketplace?: StringFilter<"AmazonOrder"> | string
    orderStatus?: StringFilter<"AmazonOrder"> | string
    fulfillmentChannel?: StringNullableFilter<"AmazonOrder"> | string | null
    salesChannel?: StringNullableFilter<"AmazonOrder"> | string | null
    orderType?: StringNullableFilter<"AmazonOrder"> | string | null
    purchaseDate?: DateTimeNullableFilter<"AmazonOrder"> | Date | string | null
    lastUpdateDate?: DateTimeNullableFilter<"AmazonOrder"> | Date | string | null
    orderTotal?: FloatNullableFilter<"AmazonOrder"> | number | null
    currency?: StringFilter<"AmazonOrder"> | string
    numberOfItemsShipped?: IntFilter<"AmazonOrder"> | number
    numberOfItemsUnshipped?: IntFilter<"AmazonOrder"> | number
    buyerEmail?: StringNullableFilter<"AmazonOrder"> | string | null
    isBusinessOrder?: BoolFilter<"AmazonOrder"> | boolean
    isPrime?: BoolFilter<"AmazonOrder"> | boolean
    isGlobalExpressEnabled?: BoolFilter<"AmazonOrder"> | boolean
    isReplacementOrder?: BoolFilter<"AmazonOrder"> | boolean
    createdAt?: DateTimeFilter<"AmazonOrder"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonOrder"> | Date | string
    orderItems?: AmazonOrderItemListRelationFilter
  }

  export type AmazonOrderOrderByWithRelationInput = {
    id?: SortOrder
    amazonOrderId?: SortOrder
    marketplace?: SortOrder
    orderStatus?: SortOrder
    fulfillmentChannel?: SortOrderInput | SortOrder
    salesChannel?: SortOrderInput | SortOrder
    orderType?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    lastUpdateDate?: SortOrderInput | SortOrder
    orderTotal?: SortOrderInput | SortOrder
    currency?: SortOrder
    numberOfItemsShipped?: SortOrder
    numberOfItemsUnshipped?: SortOrder
    buyerEmail?: SortOrderInput | SortOrder
    isBusinessOrder?: SortOrder
    isPrime?: SortOrder
    isGlobalExpressEnabled?: SortOrder
    isReplacementOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItems?: AmazonOrderItemOrderByRelationAggregateInput
  }

  export type AmazonOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    amazonOrderId?: string
    AND?: AmazonOrderWhereInput | AmazonOrderWhereInput[]
    OR?: AmazonOrderWhereInput[]
    NOT?: AmazonOrderWhereInput | AmazonOrderWhereInput[]
    marketplace?: StringFilter<"AmazonOrder"> | string
    orderStatus?: StringFilter<"AmazonOrder"> | string
    fulfillmentChannel?: StringNullableFilter<"AmazonOrder"> | string | null
    salesChannel?: StringNullableFilter<"AmazonOrder"> | string | null
    orderType?: StringNullableFilter<"AmazonOrder"> | string | null
    purchaseDate?: DateTimeNullableFilter<"AmazonOrder"> | Date | string | null
    lastUpdateDate?: DateTimeNullableFilter<"AmazonOrder"> | Date | string | null
    orderTotal?: FloatNullableFilter<"AmazonOrder"> | number | null
    currency?: StringFilter<"AmazonOrder"> | string
    numberOfItemsShipped?: IntFilter<"AmazonOrder"> | number
    numberOfItemsUnshipped?: IntFilter<"AmazonOrder"> | number
    buyerEmail?: StringNullableFilter<"AmazonOrder"> | string | null
    isBusinessOrder?: BoolFilter<"AmazonOrder"> | boolean
    isPrime?: BoolFilter<"AmazonOrder"> | boolean
    isGlobalExpressEnabled?: BoolFilter<"AmazonOrder"> | boolean
    isReplacementOrder?: BoolFilter<"AmazonOrder"> | boolean
    createdAt?: DateTimeFilter<"AmazonOrder"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonOrder"> | Date | string
    orderItems?: AmazonOrderItemListRelationFilter
  }, "id" | "amazonOrderId">

  export type AmazonOrderOrderByWithAggregationInput = {
    id?: SortOrder
    amazonOrderId?: SortOrder
    marketplace?: SortOrder
    orderStatus?: SortOrder
    fulfillmentChannel?: SortOrderInput | SortOrder
    salesChannel?: SortOrderInput | SortOrder
    orderType?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    lastUpdateDate?: SortOrderInput | SortOrder
    orderTotal?: SortOrderInput | SortOrder
    currency?: SortOrder
    numberOfItemsShipped?: SortOrder
    numberOfItemsUnshipped?: SortOrder
    buyerEmail?: SortOrderInput | SortOrder
    isBusinessOrder?: SortOrder
    isPrime?: SortOrder
    isGlobalExpressEnabled?: SortOrder
    isReplacementOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmazonOrderCountOrderByAggregateInput
    _avg?: AmazonOrderAvgOrderByAggregateInput
    _max?: AmazonOrderMaxOrderByAggregateInput
    _min?: AmazonOrderMinOrderByAggregateInput
    _sum?: AmazonOrderSumOrderByAggregateInput
  }

  export type AmazonOrderScalarWhereWithAggregatesInput = {
    AND?: AmazonOrderScalarWhereWithAggregatesInput | AmazonOrderScalarWhereWithAggregatesInput[]
    OR?: AmazonOrderScalarWhereWithAggregatesInput[]
    NOT?: AmazonOrderScalarWhereWithAggregatesInput | AmazonOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AmazonOrder"> | string
    amazonOrderId?: StringWithAggregatesFilter<"AmazonOrder"> | string
    marketplace?: StringWithAggregatesFilter<"AmazonOrder"> | string
    orderStatus?: StringWithAggregatesFilter<"AmazonOrder"> | string
    fulfillmentChannel?: StringNullableWithAggregatesFilter<"AmazonOrder"> | string | null
    salesChannel?: StringNullableWithAggregatesFilter<"AmazonOrder"> | string | null
    orderType?: StringNullableWithAggregatesFilter<"AmazonOrder"> | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"AmazonOrder"> | Date | string | null
    lastUpdateDate?: DateTimeNullableWithAggregatesFilter<"AmazonOrder"> | Date | string | null
    orderTotal?: FloatNullableWithAggregatesFilter<"AmazonOrder"> | number | null
    currency?: StringWithAggregatesFilter<"AmazonOrder"> | string
    numberOfItemsShipped?: IntWithAggregatesFilter<"AmazonOrder"> | number
    numberOfItemsUnshipped?: IntWithAggregatesFilter<"AmazonOrder"> | number
    buyerEmail?: StringNullableWithAggregatesFilter<"AmazonOrder"> | string | null
    isBusinessOrder?: BoolWithAggregatesFilter<"AmazonOrder"> | boolean
    isPrime?: BoolWithAggregatesFilter<"AmazonOrder"> | boolean
    isGlobalExpressEnabled?: BoolWithAggregatesFilter<"AmazonOrder"> | boolean
    isReplacementOrder?: BoolWithAggregatesFilter<"AmazonOrder"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AmazonOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AmazonOrder"> | Date | string
  }

  export type AmazonOrderItemWhereInput = {
    AND?: AmazonOrderItemWhereInput | AmazonOrderItemWhereInput[]
    OR?: AmazonOrderItemWhereInput[]
    NOT?: AmazonOrderItemWhereInput | AmazonOrderItemWhereInput[]
    id?: StringFilter<"AmazonOrderItem"> | string
    orderItemId?: StringFilter<"AmazonOrderItem"> | string
    amazonOrderId?: StringFilter<"AmazonOrderItem"> | string
    asin?: StringFilter<"AmazonOrderItem"> | string
    sellerSKU?: StringNullableFilter<"AmazonOrderItem"> | string | null
    title?: StringNullableFilter<"AmazonOrderItem"> | string | null
    quantityOrdered?: IntFilter<"AmazonOrderItem"> | number
    quantityShipped?: IntFilter<"AmazonOrderItem"> | number
    itemPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    itemTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shippingPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shippingTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    giftWrapPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    giftWrapTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    itemPromotionDiscount?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shipPromotionDiscount?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    currency?: StringFilter<"AmazonOrderItem"> | string
    conditionNote?: StringNullableFilter<"AmazonOrderItem"> | string | null
    conditionId?: StringNullableFilter<"AmazonOrderItem"> | string | null
    conditionSubtypeId?: StringNullableFilter<"AmazonOrderItem"> | string | null
    createdAt?: DateTimeFilter<"AmazonOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonOrderItem"> | Date | string
    order?: XOR<AmazonOrderScalarRelationFilter, AmazonOrderWhereInput>
  }

  export type AmazonOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    amazonOrderId?: SortOrder
    asin?: SortOrder
    sellerSKU?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    quantityOrdered?: SortOrder
    quantityShipped?: SortOrder
    itemPrice?: SortOrderInput | SortOrder
    itemTax?: SortOrderInput | SortOrder
    shippingPrice?: SortOrderInput | SortOrder
    shippingTax?: SortOrderInput | SortOrder
    giftWrapPrice?: SortOrderInput | SortOrder
    giftWrapTax?: SortOrderInput | SortOrder
    itemPromotionDiscount?: SortOrderInput | SortOrder
    shipPromotionDiscount?: SortOrderInput | SortOrder
    currency?: SortOrder
    conditionNote?: SortOrderInput | SortOrder
    conditionId?: SortOrderInput | SortOrder
    conditionSubtypeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: AmazonOrderOrderByWithRelationInput
  }

  export type AmazonOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderItemId_amazonOrderId?: AmazonOrderItemOrderItemIdAmazonOrderIdCompoundUniqueInput
    AND?: AmazonOrderItemWhereInput | AmazonOrderItemWhereInput[]
    OR?: AmazonOrderItemWhereInput[]
    NOT?: AmazonOrderItemWhereInput | AmazonOrderItemWhereInput[]
    orderItemId?: StringFilter<"AmazonOrderItem"> | string
    amazonOrderId?: StringFilter<"AmazonOrderItem"> | string
    asin?: StringFilter<"AmazonOrderItem"> | string
    sellerSKU?: StringNullableFilter<"AmazonOrderItem"> | string | null
    title?: StringNullableFilter<"AmazonOrderItem"> | string | null
    quantityOrdered?: IntFilter<"AmazonOrderItem"> | number
    quantityShipped?: IntFilter<"AmazonOrderItem"> | number
    itemPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    itemTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shippingPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shippingTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    giftWrapPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    giftWrapTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    itemPromotionDiscount?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shipPromotionDiscount?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    currency?: StringFilter<"AmazonOrderItem"> | string
    conditionNote?: StringNullableFilter<"AmazonOrderItem"> | string | null
    conditionId?: StringNullableFilter<"AmazonOrderItem"> | string | null
    conditionSubtypeId?: StringNullableFilter<"AmazonOrderItem"> | string | null
    createdAt?: DateTimeFilter<"AmazonOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonOrderItem"> | Date | string
    order?: XOR<AmazonOrderScalarRelationFilter, AmazonOrderWhereInput>
  }, "id" | "orderItemId_amazonOrderId">

  export type AmazonOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    amazonOrderId?: SortOrder
    asin?: SortOrder
    sellerSKU?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    quantityOrdered?: SortOrder
    quantityShipped?: SortOrder
    itemPrice?: SortOrderInput | SortOrder
    itemTax?: SortOrderInput | SortOrder
    shippingPrice?: SortOrderInput | SortOrder
    shippingTax?: SortOrderInput | SortOrder
    giftWrapPrice?: SortOrderInput | SortOrder
    giftWrapTax?: SortOrderInput | SortOrder
    itemPromotionDiscount?: SortOrderInput | SortOrder
    shipPromotionDiscount?: SortOrderInput | SortOrder
    currency?: SortOrder
    conditionNote?: SortOrderInput | SortOrder
    conditionId?: SortOrderInput | SortOrder
    conditionSubtypeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmazonOrderItemCountOrderByAggregateInput
    _avg?: AmazonOrderItemAvgOrderByAggregateInput
    _max?: AmazonOrderItemMaxOrderByAggregateInput
    _min?: AmazonOrderItemMinOrderByAggregateInput
    _sum?: AmazonOrderItemSumOrderByAggregateInput
  }

  export type AmazonOrderItemScalarWhereWithAggregatesInput = {
    AND?: AmazonOrderItemScalarWhereWithAggregatesInput | AmazonOrderItemScalarWhereWithAggregatesInput[]
    OR?: AmazonOrderItemScalarWhereWithAggregatesInput[]
    NOT?: AmazonOrderItemScalarWhereWithAggregatesInput | AmazonOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AmazonOrderItem"> | string
    orderItemId?: StringWithAggregatesFilter<"AmazonOrderItem"> | string
    amazonOrderId?: StringWithAggregatesFilter<"AmazonOrderItem"> | string
    asin?: StringWithAggregatesFilter<"AmazonOrderItem"> | string
    sellerSKU?: StringNullableWithAggregatesFilter<"AmazonOrderItem"> | string | null
    title?: StringNullableWithAggregatesFilter<"AmazonOrderItem"> | string | null
    quantityOrdered?: IntWithAggregatesFilter<"AmazonOrderItem"> | number
    quantityShipped?: IntWithAggregatesFilter<"AmazonOrderItem"> | number
    itemPrice?: FloatNullableWithAggregatesFilter<"AmazonOrderItem"> | number | null
    itemTax?: FloatNullableWithAggregatesFilter<"AmazonOrderItem"> | number | null
    shippingPrice?: FloatNullableWithAggregatesFilter<"AmazonOrderItem"> | number | null
    shippingTax?: FloatNullableWithAggregatesFilter<"AmazonOrderItem"> | number | null
    giftWrapPrice?: FloatNullableWithAggregatesFilter<"AmazonOrderItem"> | number | null
    giftWrapTax?: FloatNullableWithAggregatesFilter<"AmazonOrderItem"> | number | null
    itemPromotionDiscount?: FloatNullableWithAggregatesFilter<"AmazonOrderItem"> | number | null
    shipPromotionDiscount?: FloatNullableWithAggregatesFilter<"AmazonOrderItem"> | number | null
    currency?: StringWithAggregatesFilter<"AmazonOrderItem"> | string
    conditionNote?: StringNullableWithAggregatesFilter<"AmazonOrderItem"> | string | null
    conditionId?: StringNullableWithAggregatesFilter<"AmazonOrderItem"> | string | null
    conditionSubtypeId?: StringNullableWithAggregatesFilter<"AmazonOrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AmazonOrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AmazonOrderItem"> | Date | string
  }

  export type AmazonInventoryWhereInput = {
    AND?: AmazonInventoryWhereInput | AmazonInventoryWhereInput[]
    OR?: AmazonInventoryWhereInput[]
    NOT?: AmazonInventoryWhereInput | AmazonInventoryWhereInput[]
    id?: StringFilter<"AmazonInventory"> | string
    sellerSKU?: StringFilter<"AmazonInventory"> | string
    asin?: StringNullableFilter<"AmazonInventory"> | string | null
    fnSKU?: StringNullableFilter<"AmazonInventory"> | string | null
    productName?: StringNullableFilter<"AmazonInventory"> | string | null
    condition?: StringNullableFilter<"AmazonInventory"> | string | null
    totalQuantity?: IntFilter<"AmazonInventory"> | number
    inStockQuantity?: IntFilter<"AmazonInventory"> | number
    availableQuantity?: IntFilter<"AmazonInventory"> | number
    fulfillableQuantity?: IntFilter<"AmazonInventory"> | number
    inboundWorkingQuantity?: IntFilter<"AmazonInventory"> | number
    inboundShippedQuantity?: IntFilter<"AmazonInventory"> | number
    inboundReceivingQuantity?: IntFilter<"AmazonInventory"> | number
    reservedQuantity?: IntFilter<"AmazonInventory"> | number
    unfulfillableQuantity?: IntFilter<"AmazonInventory"> | number
    lastUpdated?: DateTimeNullableFilter<"AmazonInventory"> | Date | string | null
    createdAt?: DateTimeFilter<"AmazonInventory"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonInventory"> | Date | string
  }

  export type AmazonInventoryOrderByWithRelationInput = {
    id?: SortOrder
    sellerSKU?: SortOrder
    asin?: SortOrderInput | SortOrder
    fnSKU?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    totalQuantity?: SortOrder
    inStockQuantity?: SortOrder
    availableQuantity?: SortOrder
    fulfillableQuantity?: SortOrder
    inboundWorkingQuantity?: SortOrder
    inboundShippedQuantity?: SortOrder
    inboundReceivingQuantity?: SortOrder
    reservedQuantity?: SortOrder
    unfulfillableQuantity?: SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonInventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sellerSKU?: string
    AND?: AmazonInventoryWhereInput | AmazonInventoryWhereInput[]
    OR?: AmazonInventoryWhereInput[]
    NOT?: AmazonInventoryWhereInput | AmazonInventoryWhereInput[]
    asin?: StringNullableFilter<"AmazonInventory"> | string | null
    fnSKU?: StringNullableFilter<"AmazonInventory"> | string | null
    productName?: StringNullableFilter<"AmazonInventory"> | string | null
    condition?: StringNullableFilter<"AmazonInventory"> | string | null
    totalQuantity?: IntFilter<"AmazonInventory"> | number
    inStockQuantity?: IntFilter<"AmazonInventory"> | number
    availableQuantity?: IntFilter<"AmazonInventory"> | number
    fulfillableQuantity?: IntFilter<"AmazonInventory"> | number
    inboundWorkingQuantity?: IntFilter<"AmazonInventory"> | number
    inboundShippedQuantity?: IntFilter<"AmazonInventory"> | number
    inboundReceivingQuantity?: IntFilter<"AmazonInventory"> | number
    reservedQuantity?: IntFilter<"AmazonInventory"> | number
    unfulfillableQuantity?: IntFilter<"AmazonInventory"> | number
    lastUpdated?: DateTimeNullableFilter<"AmazonInventory"> | Date | string | null
    createdAt?: DateTimeFilter<"AmazonInventory"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonInventory"> | Date | string
  }, "id" | "sellerSKU">

  export type AmazonInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    sellerSKU?: SortOrder
    asin?: SortOrderInput | SortOrder
    fnSKU?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    totalQuantity?: SortOrder
    inStockQuantity?: SortOrder
    availableQuantity?: SortOrder
    fulfillableQuantity?: SortOrder
    inboundWorkingQuantity?: SortOrder
    inboundShippedQuantity?: SortOrder
    inboundReceivingQuantity?: SortOrder
    reservedQuantity?: SortOrder
    unfulfillableQuantity?: SortOrder
    lastUpdated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmazonInventoryCountOrderByAggregateInput
    _avg?: AmazonInventoryAvgOrderByAggregateInput
    _max?: AmazonInventoryMaxOrderByAggregateInput
    _min?: AmazonInventoryMinOrderByAggregateInput
    _sum?: AmazonInventorySumOrderByAggregateInput
  }

  export type AmazonInventoryScalarWhereWithAggregatesInput = {
    AND?: AmazonInventoryScalarWhereWithAggregatesInput | AmazonInventoryScalarWhereWithAggregatesInput[]
    OR?: AmazonInventoryScalarWhereWithAggregatesInput[]
    NOT?: AmazonInventoryScalarWhereWithAggregatesInput | AmazonInventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AmazonInventory"> | string
    sellerSKU?: StringWithAggregatesFilter<"AmazonInventory"> | string
    asin?: StringNullableWithAggregatesFilter<"AmazonInventory"> | string | null
    fnSKU?: StringNullableWithAggregatesFilter<"AmazonInventory"> | string | null
    productName?: StringNullableWithAggregatesFilter<"AmazonInventory"> | string | null
    condition?: StringNullableWithAggregatesFilter<"AmazonInventory"> | string | null
    totalQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    inStockQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    availableQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    fulfillableQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    inboundWorkingQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    inboundShippedQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    inboundReceivingQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    reservedQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    unfulfillableQuantity?: IntWithAggregatesFilter<"AmazonInventory"> | number
    lastUpdated?: DateTimeNullableWithAggregatesFilter<"AmazonInventory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AmazonInventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AmazonInventory"> | Date | string
  }

  export type ShopifyOrderWhereInput = {
    AND?: ShopifyOrderWhereInput | ShopifyOrderWhereInput[]
    OR?: ShopifyOrderWhereInput[]
    NOT?: ShopifyOrderWhereInput | ShopifyOrderWhereInput[]
    id?: StringFilter<"ShopifyOrder"> | string
    shopifyOrderId?: StringFilter<"ShopifyOrder"> | string
    orderNumber?: StringNullableFilter<"ShopifyOrder"> | string | null
    email?: StringNullableFilter<"ShopifyOrder"> | string | null
    phone?: StringNullableFilter<"ShopifyOrder"> | string | null
    name?: StringNullableFilter<"ShopifyOrder"> | string | null
    financialStatus?: StringNullableFilter<"ShopifyOrder"> | string | null
    fulfillmentStatus?: StringNullableFilter<"ShopifyOrder"> | string | null
    tags?: StringNullableFilter<"ShopifyOrder"> | string | null
    totalPrice?: FloatNullableFilter<"ShopifyOrder"> | number | null
    totalTax?: FloatNullableFilter<"ShopifyOrder"> | number | null
    totalDiscounts?: FloatNullableFilter<"ShopifyOrder"> | number | null
    totalWeight?: FloatNullableFilter<"ShopifyOrder"> | number | null
    currency?: StringFilter<"ShopifyOrder"> | string
    processedAt?: DateTimeNullableFilter<"ShopifyOrder"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"ShopifyOrder"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"ShopifyOrder"> | Date | string | null
    test?: BoolFilter<"ShopifyOrder"> | boolean
    createdAt?: DateTimeFilter<"ShopifyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyOrder"> | Date | string
    lineItems?: ShopifyLineItemListRelationFilter
  }

  export type ShopifyOrderOrderByWithRelationInput = {
    id?: SortOrder
    shopifyOrderId?: SortOrder
    orderNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    financialStatus?: SortOrderInput | SortOrder
    fulfillmentStatus?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    totalTax?: SortOrderInput | SortOrder
    totalDiscounts?: SortOrderInput | SortOrder
    totalWeight?: SortOrderInput | SortOrder
    currency?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    test?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lineItems?: ShopifyLineItemOrderByRelationAggregateInput
  }

  export type ShopifyOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shopifyOrderId?: string
    AND?: ShopifyOrderWhereInput | ShopifyOrderWhereInput[]
    OR?: ShopifyOrderWhereInput[]
    NOT?: ShopifyOrderWhereInput | ShopifyOrderWhereInput[]
    orderNumber?: StringNullableFilter<"ShopifyOrder"> | string | null
    email?: StringNullableFilter<"ShopifyOrder"> | string | null
    phone?: StringNullableFilter<"ShopifyOrder"> | string | null
    name?: StringNullableFilter<"ShopifyOrder"> | string | null
    financialStatus?: StringNullableFilter<"ShopifyOrder"> | string | null
    fulfillmentStatus?: StringNullableFilter<"ShopifyOrder"> | string | null
    tags?: StringNullableFilter<"ShopifyOrder"> | string | null
    totalPrice?: FloatNullableFilter<"ShopifyOrder"> | number | null
    totalTax?: FloatNullableFilter<"ShopifyOrder"> | number | null
    totalDiscounts?: FloatNullableFilter<"ShopifyOrder"> | number | null
    totalWeight?: FloatNullableFilter<"ShopifyOrder"> | number | null
    currency?: StringFilter<"ShopifyOrder"> | string
    processedAt?: DateTimeNullableFilter<"ShopifyOrder"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"ShopifyOrder"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"ShopifyOrder"> | Date | string | null
    test?: BoolFilter<"ShopifyOrder"> | boolean
    createdAt?: DateTimeFilter<"ShopifyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyOrder"> | Date | string
    lineItems?: ShopifyLineItemListRelationFilter
  }, "id" | "shopifyOrderId">

  export type ShopifyOrderOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyOrderId?: SortOrder
    orderNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    financialStatus?: SortOrderInput | SortOrder
    fulfillmentStatus?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    totalPrice?: SortOrderInput | SortOrder
    totalTax?: SortOrderInput | SortOrder
    totalDiscounts?: SortOrderInput | SortOrder
    totalWeight?: SortOrderInput | SortOrder
    currency?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    test?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopifyOrderCountOrderByAggregateInput
    _avg?: ShopifyOrderAvgOrderByAggregateInput
    _max?: ShopifyOrderMaxOrderByAggregateInput
    _min?: ShopifyOrderMinOrderByAggregateInput
    _sum?: ShopifyOrderSumOrderByAggregateInput
  }

  export type ShopifyOrderScalarWhereWithAggregatesInput = {
    AND?: ShopifyOrderScalarWhereWithAggregatesInput | ShopifyOrderScalarWhereWithAggregatesInput[]
    OR?: ShopifyOrderScalarWhereWithAggregatesInput[]
    NOT?: ShopifyOrderScalarWhereWithAggregatesInput | ShopifyOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopifyOrder"> | string
    shopifyOrderId?: StringWithAggregatesFilter<"ShopifyOrder"> | string
    orderNumber?: StringNullableWithAggregatesFilter<"ShopifyOrder"> | string | null
    email?: StringNullableWithAggregatesFilter<"ShopifyOrder"> | string | null
    phone?: StringNullableWithAggregatesFilter<"ShopifyOrder"> | string | null
    name?: StringNullableWithAggregatesFilter<"ShopifyOrder"> | string | null
    financialStatus?: StringNullableWithAggregatesFilter<"ShopifyOrder"> | string | null
    fulfillmentStatus?: StringNullableWithAggregatesFilter<"ShopifyOrder"> | string | null
    tags?: StringNullableWithAggregatesFilter<"ShopifyOrder"> | string | null
    totalPrice?: FloatNullableWithAggregatesFilter<"ShopifyOrder"> | number | null
    totalTax?: FloatNullableWithAggregatesFilter<"ShopifyOrder"> | number | null
    totalDiscounts?: FloatNullableWithAggregatesFilter<"ShopifyOrder"> | number | null
    totalWeight?: FloatNullableWithAggregatesFilter<"ShopifyOrder"> | number | null
    currency?: StringWithAggregatesFilter<"ShopifyOrder"> | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"ShopifyOrder"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"ShopifyOrder"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"ShopifyOrder"> | Date | string | null
    test?: BoolWithAggregatesFilter<"ShopifyOrder"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ShopifyOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopifyOrder"> | Date | string
  }

  export type ShopifyLineItemWhereInput = {
    AND?: ShopifyLineItemWhereInput | ShopifyLineItemWhereInput[]
    OR?: ShopifyLineItemWhereInput[]
    NOT?: ShopifyLineItemWhereInput | ShopifyLineItemWhereInput[]
    id?: StringFilter<"ShopifyLineItem"> | string
    lineItemId?: StringFilter<"ShopifyLineItem"> | string
    shopifyOrderId?: StringFilter<"ShopifyLineItem"> | string
    productId?: StringNullableFilter<"ShopifyLineItem"> | string | null
    variantId?: StringNullableFilter<"ShopifyLineItem"> | string | null
    title?: StringNullableFilter<"ShopifyLineItem"> | string | null
    variantTitle?: StringNullableFilter<"ShopifyLineItem"> | string | null
    sku?: StringNullableFilter<"ShopifyLineItem"> | string | null
    vendor?: StringNullableFilter<"ShopifyLineItem"> | string | null
    quantity?: IntFilter<"ShopifyLineItem"> | number
    price?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    totalDiscount?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    grams?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    requiresShipping?: BoolFilter<"ShopifyLineItem"> | boolean
    taxable?: BoolFilter<"ShopifyLineItem"> | boolean
    fulfillmentService?: StringNullableFilter<"ShopifyLineItem"> | string | null
    fulfillmentStatus?: StringNullableFilter<"ShopifyLineItem"> | string | null
    createdAt?: DateTimeFilter<"ShopifyLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyLineItem"> | Date | string
    order?: XOR<ShopifyOrderScalarRelationFilter, ShopifyOrderWhereInput>
  }

  export type ShopifyLineItemOrderByWithRelationInput = {
    id?: SortOrder
    lineItemId?: SortOrder
    shopifyOrderId?: SortOrder
    productId?: SortOrderInput | SortOrder
    variantId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    variantTitle?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrderInput | SortOrder
    totalDiscount?: SortOrderInput | SortOrder
    grams?: SortOrderInput | SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrderInput | SortOrder
    fulfillmentStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: ShopifyOrderOrderByWithRelationInput
  }

  export type ShopifyLineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lineItemId_shopifyOrderId?: ShopifyLineItemLineItemIdShopifyOrderIdCompoundUniqueInput
    AND?: ShopifyLineItemWhereInput | ShopifyLineItemWhereInput[]
    OR?: ShopifyLineItemWhereInput[]
    NOT?: ShopifyLineItemWhereInput | ShopifyLineItemWhereInput[]
    lineItemId?: StringFilter<"ShopifyLineItem"> | string
    shopifyOrderId?: StringFilter<"ShopifyLineItem"> | string
    productId?: StringNullableFilter<"ShopifyLineItem"> | string | null
    variantId?: StringNullableFilter<"ShopifyLineItem"> | string | null
    title?: StringNullableFilter<"ShopifyLineItem"> | string | null
    variantTitle?: StringNullableFilter<"ShopifyLineItem"> | string | null
    sku?: StringNullableFilter<"ShopifyLineItem"> | string | null
    vendor?: StringNullableFilter<"ShopifyLineItem"> | string | null
    quantity?: IntFilter<"ShopifyLineItem"> | number
    price?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    totalDiscount?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    grams?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    requiresShipping?: BoolFilter<"ShopifyLineItem"> | boolean
    taxable?: BoolFilter<"ShopifyLineItem"> | boolean
    fulfillmentService?: StringNullableFilter<"ShopifyLineItem"> | string | null
    fulfillmentStatus?: StringNullableFilter<"ShopifyLineItem"> | string | null
    createdAt?: DateTimeFilter<"ShopifyLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyLineItem"> | Date | string
    order?: XOR<ShopifyOrderScalarRelationFilter, ShopifyOrderWhereInput>
  }, "id" | "lineItemId_shopifyOrderId">

  export type ShopifyLineItemOrderByWithAggregationInput = {
    id?: SortOrder
    lineItemId?: SortOrder
    shopifyOrderId?: SortOrder
    productId?: SortOrderInput | SortOrder
    variantId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    variantTitle?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrderInput | SortOrder
    totalDiscount?: SortOrderInput | SortOrder
    grams?: SortOrderInput | SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrderInput | SortOrder
    fulfillmentStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopifyLineItemCountOrderByAggregateInput
    _avg?: ShopifyLineItemAvgOrderByAggregateInput
    _max?: ShopifyLineItemMaxOrderByAggregateInput
    _min?: ShopifyLineItemMinOrderByAggregateInput
    _sum?: ShopifyLineItemSumOrderByAggregateInput
  }

  export type ShopifyLineItemScalarWhereWithAggregatesInput = {
    AND?: ShopifyLineItemScalarWhereWithAggregatesInput | ShopifyLineItemScalarWhereWithAggregatesInput[]
    OR?: ShopifyLineItemScalarWhereWithAggregatesInput[]
    NOT?: ShopifyLineItemScalarWhereWithAggregatesInput | ShopifyLineItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopifyLineItem"> | string
    lineItemId?: StringWithAggregatesFilter<"ShopifyLineItem"> | string
    shopifyOrderId?: StringWithAggregatesFilter<"ShopifyLineItem"> | string
    productId?: StringNullableWithAggregatesFilter<"ShopifyLineItem"> | string | null
    variantId?: StringNullableWithAggregatesFilter<"ShopifyLineItem"> | string | null
    title?: StringNullableWithAggregatesFilter<"ShopifyLineItem"> | string | null
    variantTitle?: StringNullableWithAggregatesFilter<"ShopifyLineItem"> | string | null
    sku?: StringNullableWithAggregatesFilter<"ShopifyLineItem"> | string | null
    vendor?: StringNullableWithAggregatesFilter<"ShopifyLineItem"> | string | null
    quantity?: IntWithAggregatesFilter<"ShopifyLineItem"> | number
    price?: FloatNullableWithAggregatesFilter<"ShopifyLineItem"> | number | null
    totalDiscount?: FloatNullableWithAggregatesFilter<"ShopifyLineItem"> | number | null
    grams?: FloatNullableWithAggregatesFilter<"ShopifyLineItem"> | number | null
    requiresShipping?: BoolWithAggregatesFilter<"ShopifyLineItem"> | boolean
    taxable?: BoolWithAggregatesFilter<"ShopifyLineItem"> | boolean
    fulfillmentService?: StringNullableWithAggregatesFilter<"ShopifyLineItem"> | string | null
    fulfillmentStatus?: StringNullableWithAggregatesFilter<"ShopifyLineItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopifyLineItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopifyLineItem"> | Date | string
  }

  export type ShopifyProductWhereInput = {
    AND?: ShopifyProductWhereInput | ShopifyProductWhereInput[]
    OR?: ShopifyProductWhereInput[]
    NOT?: ShopifyProductWhereInput | ShopifyProductWhereInput[]
    id?: StringFilter<"ShopifyProduct"> | string
    shopifyProductId?: StringFilter<"ShopifyProduct"> | string
    title?: StringFilter<"ShopifyProduct"> | string
    handle?: StringNullableFilter<"ShopifyProduct"> | string | null
    vendor?: StringNullableFilter<"ShopifyProduct"> | string | null
    productType?: StringNullableFilter<"ShopifyProduct"> | string | null
    tags?: StringNullableFilter<"ShopifyProduct"> | string | null
    status?: StringNullableFilter<"ShopifyProduct"> | string | null
    description?: StringNullableFilter<"ShopifyProduct"> | string | null
    publishedAt?: DateTimeNullableFilter<"ShopifyProduct"> | Date | string | null
    createdAt?: DateTimeFilter<"ShopifyProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyProduct"> | Date | string
    variants?: ShopifyVariantListRelationFilter
  }

  export type ShopifyProductOrderByWithRelationInput = {
    id?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrder
    handle?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variants?: ShopifyVariantOrderByRelationAggregateInput
  }

  export type ShopifyProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shopifyProductId?: string
    AND?: ShopifyProductWhereInput | ShopifyProductWhereInput[]
    OR?: ShopifyProductWhereInput[]
    NOT?: ShopifyProductWhereInput | ShopifyProductWhereInput[]
    title?: StringFilter<"ShopifyProduct"> | string
    handle?: StringNullableFilter<"ShopifyProduct"> | string | null
    vendor?: StringNullableFilter<"ShopifyProduct"> | string | null
    productType?: StringNullableFilter<"ShopifyProduct"> | string | null
    tags?: StringNullableFilter<"ShopifyProduct"> | string | null
    status?: StringNullableFilter<"ShopifyProduct"> | string | null
    description?: StringNullableFilter<"ShopifyProduct"> | string | null
    publishedAt?: DateTimeNullableFilter<"ShopifyProduct"> | Date | string | null
    createdAt?: DateTimeFilter<"ShopifyProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyProduct"> | Date | string
    variants?: ShopifyVariantListRelationFilter
  }, "id" | "shopifyProductId">

  export type ShopifyProductOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrder
    handle?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopifyProductCountOrderByAggregateInput
    _max?: ShopifyProductMaxOrderByAggregateInput
    _min?: ShopifyProductMinOrderByAggregateInput
  }

  export type ShopifyProductScalarWhereWithAggregatesInput = {
    AND?: ShopifyProductScalarWhereWithAggregatesInput | ShopifyProductScalarWhereWithAggregatesInput[]
    OR?: ShopifyProductScalarWhereWithAggregatesInput[]
    NOT?: ShopifyProductScalarWhereWithAggregatesInput | ShopifyProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopifyProduct"> | string
    shopifyProductId?: StringWithAggregatesFilter<"ShopifyProduct"> | string
    title?: StringWithAggregatesFilter<"ShopifyProduct"> | string
    handle?: StringNullableWithAggregatesFilter<"ShopifyProduct"> | string | null
    vendor?: StringNullableWithAggregatesFilter<"ShopifyProduct"> | string | null
    productType?: StringNullableWithAggregatesFilter<"ShopifyProduct"> | string | null
    tags?: StringNullableWithAggregatesFilter<"ShopifyProduct"> | string | null
    status?: StringNullableWithAggregatesFilter<"ShopifyProduct"> | string | null
    description?: StringNullableWithAggregatesFilter<"ShopifyProduct"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ShopifyProduct"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopifyProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopifyProduct"> | Date | string
  }

  export type ShopifyVariantWhereInput = {
    AND?: ShopifyVariantWhereInput | ShopifyVariantWhereInput[]
    OR?: ShopifyVariantWhereInput[]
    NOT?: ShopifyVariantWhereInput | ShopifyVariantWhereInput[]
    id?: StringFilter<"ShopifyVariant"> | string
    shopifyVariantId?: StringFilter<"ShopifyVariant"> | string
    shopifyProductId?: StringFilter<"ShopifyVariant"> | string
    title?: StringNullableFilter<"ShopifyVariant"> | string | null
    price?: FloatNullableFilter<"ShopifyVariant"> | number | null
    compareAtPrice?: FloatNullableFilter<"ShopifyVariant"> | number | null
    sku?: StringNullableFilter<"ShopifyVariant"> | string | null
    barcode?: StringNullableFilter<"ShopifyVariant"> | string | null
    grams?: FloatNullableFilter<"ShopifyVariant"> | number | null
    weight?: FloatNullableFilter<"ShopifyVariant"> | number | null
    weightUnit?: StringNullableFilter<"ShopifyVariant"> | string | null
    inventoryQuantity?: IntFilter<"ShopifyVariant"> | number
    inventoryPolicy?: StringNullableFilter<"ShopifyVariant"> | string | null
    inventoryTracking?: StringNullableFilter<"ShopifyVariant"> | string | null
    requiresShipping?: BoolFilter<"ShopifyVariant"> | boolean
    taxable?: BoolFilter<"ShopifyVariant"> | boolean
    fulfillmentService?: StringNullableFilter<"ShopifyVariant"> | string | null
    position?: IntNullableFilter<"ShopifyVariant"> | number | null
    createdAt?: DateTimeFilter<"ShopifyVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyVariant"> | Date | string
    product?: XOR<ShopifyProductScalarRelationFilter, ShopifyProductWhereInput>
  }

  export type ShopifyVariantOrderByWithRelationInput = {
    id?: SortOrder
    shopifyVariantId?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    compareAtPrice?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    grams?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrderInput | SortOrder
    inventoryQuantity?: SortOrder
    inventoryPolicy?: SortOrderInput | SortOrder
    inventoryTracking?: SortOrderInput | SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ShopifyProductOrderByWithRelationInput
  }

  export type ShopifyVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shopifyVariantId?: string
    AND?: ShopifyVariantWhereInput | ShopifyVariantWhereInput[]
    OR?: ShopifyVariantWhereInput[]
    NOT?: ShopifyVariantWhereInput | ShopifyVariantWhereInput[]
    shopifyProductId?: StringFilter<"ShopifyVariant"> | string
    title?: StringNullableFilter<"ShopifyVariant"> | string | null
    price?: FloatNullableFilter<"ShopifyVariant"> | number | null
    compareAtPrice?: FloatNullableFilter<"ShopifyVariant"> | number | null
    sku?: StringNullableFilter<"ShopifyVariant"> | string | null
    barcode?: StringNullableFilter<"ShopifyVariant"> | string | null
    grams?: FloatNullableFilter<"ShopifyVariant"> | number | null
    weight?: FloatNullableFilter<"ShopifyVariant"> | number | null
    weightUnit?: StringNullableFilter<"ShopifyVariant"> | string | null
    inventoryQuantity?: IntFilter<"ShopifyVariant"> | number
    inventoryPolicy?: StringNullableFilter<"ShopifyVariant"> | string | null
    inventoryTracking?: StringNullableFilter<"ShopifyVariant"> | string | null
    requiresShipping?: BoolFilter<"ShopifyVariant"> | boolean
    taxable?: BoolFilter<"ShopifyVariant"> | boolean
    fulfillmentService?: StringNullableFilter<"ShopifyVariant"> | string | null
    position?: IntNullableFilter<"ShopifyVariant"> | number | null
    createdAt?: DateTimeFilter<"ShopifyVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyVariant"> | Date | string
    product?: XOR<ShopifyProductScalarRelationFilter, ShopifyProductWhereInput>
  }, "id" | "shopifyVariantId">

  export type ShopifyVariantOrderByWithAggregationInput = {
    id?: SortOrder
    shopifyVariantId?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    compareAtPrice?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    grams?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrderInput | SortOrder
    inventoryQuantity?: SortOrder
    inventoryPolicy?: SortOrderInput | SortOrder
    inventoryTracking?: SortOrderInput | SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopifyVariantCountOrderByAggregateInput
    _avg?: ShopifyVariantAvgOrderByAggregateInput
    _max?: ShopifyVariantMaxOrderByAggregateInput
    _min?: ShopifyVariantMinOrderByAggregateInput
    _sum?: ShopifyVariantSumOrderByAggregateInput
  }

  export type ShopifyVariantScalarWhereWithAggregatesInput = {
    AND?: ShopifyVariantScalarWhereWithAggregatesInput | ShopifyVariantScalarWhereWithAggregatesInput[]
    OR?: ShopifyVariantScalarWhereWithAggregatesInput[]
    NOT?: ShopifyVariantScalarWhereWithAggregatesInput | ShopifyVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopifyVariant"> | string
    shopifyVariantId?: StringWithAggregatesFilter<"ShopifyVariant"> | string
    shopifyProductId?: StringWithAggregatesFilter<"ShopifyVariant"> | string
    title?: StringNullableWithAggregatesFilter<"ShopifyVariant"> | string | null
    price?: FloatNullableWithAggregatesFilter<"ShopifyVariant"> | number | null
    compareAtPrice?: FloatNullableWithAggregatesFilter<"ShopifyVariant"> | number | null
    sku?: StringNullableWithAggregatesFilter<"ShopifyVariant"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"ShopifyVariant"> | string | null
    grams?: FloatNullableWithAggregatesFilter<"ShopifyVariant"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"ShopifyVariant"> | number | null
    weightUnit?: StringNullableWithAggregatesFilter<"ShopifyVariant"> | string | null
    inventoryQuantity?: IntWithAggregatesFilter<"ShopifyVariant"> | number
    inventoryPolicy?: StringNullableWithAggregatesFilter<"ShopifyVariant"> | string | null
    inventoryTracking?: StringNullableWithAggregatesFilter<"ShopifyVariant"> | string | null
    requiresShipping?: BoolWithAggregatesFilter<"ShopifyVariant"> | boolean
    taxable?: BoolWithAggregatesFilter<"ShopifyVariant"> | boolean
    fulfillmentService?: StringNullableWithAggregatesFilter<"ShopifyVariant"> | string | null
    position?: IntNullableWithAggregatesFilter<"ShopifyVariant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopifyVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopifyVariant"> | Date | string
  }

  export type MachineWhereInput = {
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    id?: StringFilter<"Machine"> | string
    machineId?: StringFilter<"Machine"> | string
    name?: StringFilter<"Machine"> | string
    type?: StringFilter<"Machine"> | string
    location?: StringFilter<"Machine"> | string
    manufacturer?: StringNullableFilter<"Machine"> | string | null
    model?: StringNullableFilter<"Machine"> | string | null
    serialNumber?: StringNullableFilter<"Machine"> | string | null
    installDate?: DateTimeNullableFilter<"Machine"> | Date | string | null
    status?: StringFilter<"Machine"> | string
    isActive?: BoolFilter<"Machine"> | boolean
    configuration?: JsonNullableFilter<"Machine">
    specifications?: JsonNullableFilter<"Machine">
    createdAt?: DateTimeFilter<"Machine"> | Date | string
    updatedAt?: DateTimeFilter<"Machine"> | Date | string
    sensors?: MachineSensorListRelationFilter
    alerts?: MachineAlertListRelationFilter
    maintenanceRecords?: MachineMaintenanceRecordListRelationFilter
  }

  export type MachineOrderByWithRelationInput = {
    id?: SortOrder
    machineId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    installDate?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    configuration?: SortOrderInput | SortOrder
    specifications?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sensors?: MachineSensorOrderByRelationAggregateInput
    alerts?: MachineAlertOrderByRelationAggregateInput
    maintenanceRecords?: MachineMaintenanceRecordOrderByRelationAggregateInput
  }

  export type MachineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    machineId?: string
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    name?: StringFilter<"Machine"> | string
    type?: StringFilter<"Machine"> | string
    location?: StringFilter<"Machine"> | string
    manufacturer?: StringNullableFilter<"Machine"> | string | null
    model?: StringNullableFilter<"Machine"> | string | null
    serialNumber?: StringNullableFilter<"Machine"> | string | null
    installDate?: DateTimeNullableFilter<"Machine"> | Date | string | null
    status?: StringFilter<"Machine"> | string
    isActive?: BoolFilter<"Machine"> | boolean
    configuration?: JsonNullableFilter<"Machine">
    specifications?: JsonNullableFilter<"Machine">
    createdAt?: DateTimeFilter<"Machine"> | Date | string
    updatedAt?: DateTimeFilter<"Machine"> | Date | string
    sensors?: MachineSensorListRelationFilter
    alerts?: MachineAlertListRelationFilter
    maintenanceRecords?: MachineMaintenanceRecordListRelationFilter
  }, "id" | "machineId">

  export type MachineOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    installDate?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    configuration?: SortOrderInput | SortOrder
    specifications?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MachineCountOrderByAggregateInput
    _max?: MachineMaxOrderByAggregateInput
    _min?: MachineMinOrderByAggregateInput
  }

  export type MachineScalarWhereWithAggregatesInput = {
    AND?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    OR?: MachineScalarWhereWithAggregatesInput[]
    NOT?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Machine"> | string
    machineId?: StringWithAggregatesFilter<"Machine"> | string
    name?: StringWithAggregatesFilter<"Machine"> | string
    type?: StringWithAggregatesFilter<"Machine"> | string
    location?: StringWithAggregatesFilter<"Machine"> | string
    manufacturer?: StringNullableWithAggregatesFilter<"Machine"> | string | null
    model?: StringNullableWithAggregatesFilter<"Machine"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Machine"> | string | null
    installDate?: DateTimeNullableWithAggregatesFilter<"Machine"> | Date | string | null
    status?: StringWithAggregatesFilter<"Machine"> | string
    isActive?: BoolWithAggregatesFilter<"Machine"> | boolean
    configuration?: JsonNullableWithAggregatesFilter<"Machine">
    specifications?: JsonNullableWithAggregatesFilter<"Machine">
    createdAt?: DateTimeWithAggregatesFilter<"Machine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Machine"> | Date | string
  }

  export type MachineSensorWhereInput = {
    AND?: MachineSensorWhereInput | MachineSensorWhereInput[]
    OR?: MachineSensorWhereInput[]
    NOT?: MachineSensorWhereInput | MachineSensorWhereInput[]
    id?: StringFilter<"MachineSensor"> | string
    machineId?: StringFilter<"MachineSensor"> | string
    sensorType?: StringFilter<"MachineSensor"> | string
    sensorName?: StringFilter<"MachineSensor"> | string
    value?: FloatFilter<"MachineSensor"> | number
    unit?: StringNullableFilter<"MachineSensor"> | string | null
    threshold?: FloatNullableFilter<"MachineSensor"> | number | null
    minValue?: FloatNullableFilter<"MachineSensor"> | number | null
    maxValue?: FloatNullableFilter<"MachineSensor"> | number | null
    status?: StringFilter<"MachineSensor"> | string
    timestamp?: DateTimeFilter<"MachineSensor"> | Date | string
    createdAt?: DateTimeFilter<"MachineSensor"> | Date | string
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
  }

  export type MachineSensorOrderByWithRelationInput = {
    id?: SortOrder
    machineId?: SortOrder
    sensorType?: SortOrder
    sensorName?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    threshold?: SortOrderInput | SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    machine?: MachineOrderByWithRelationInput
  }

  export type MachineSensorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MachineSensorWhereInput | MachineSensorWhereInput[]
    OR?: MachineSensorWhereInput[]
    NOT?: MachineSensorWhereInput | MachineSensorWhereInput[]
    machineId?: StringFilter<"MachineSensor"> | string
    sensorType?: StringFilter<"MachineSensor"> | string
    sensorName?: StringFilter<"MachineSensor"> | string
    value?: FloatFilter<"MachineSensor"> | number
    unit?: StringNullableFilter<"MachineSensor"> | string | null
    threshold?: FloatNullableFilter<"MachineSensor"> | number | null
    minValue?: FloatNullableFilter<"MachineSensor"> | number | null
    maxValue?: FloatNullableFilter<"MachineSensor"> | number | null
    status?: StringFilter<"MachineSensor"> | string
    timestamp?: DateTimeFilter<"MachineSensor"> | Date | string
    createdAt?: DateTimeFilter<"MachineSensor"> | Date | string
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
  }, "id">

  export type MachineSensorOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    sensorType?: SortOrder
    sensorName?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    threshold?: SortOrderInput | SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: MachineSensorCountOrderByAggregateInput
    _avg?: MachineSensorAvgOrderByAggregateInput
    _max?: MachineSensorMaxOrderByAggregateInput
    _min?: MachineSensorMinOrderByAggregateInput
    _sum?: MachineSensorSumOrderByAggregateInput
  }

  export type MachineSensorScalarWhereWithAggregatesInput = {
    AND?: MachineSensorScalarWhereWithAggregatesInput | MachineSensorScalarWhereWithAggregatesInput[]
    OR?: MachineSensorScalarWhereWithAggregatesInput[]
    NOT?: MachineSensorScalarWhereWithAggregatesInput | MachineSensorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MachineSensor"> | string
    machineId?: StringWithAggregatesFilter<"MachineSensor"> | string
    sensorType?: StringWithAggregatesFilter<"MachineSensor"> | string
    sensorName?: StringWithAggregatesFilter<"MachineSensor"> | string
    value?: FloatWithAggregatesFilter<"MachineSensor"> | number
    unit?: StringNullableWithAggregatesFilter<"MachineSensor"> | string | null
    threshold?: FloatNullableWithAggregatesFilter<"MachineSensor"> | number | null
    minValue?: FloatNullableWithAggregatesFilter<"MachineSensor"> | number | null
    maxValue?: FloatNullableWithAggregatesFilter<"MachineSensor"> | number | null
    status?: StringWithAggregatesFilter<"MachineSensor"> | string
    timestamp?: DateTimeWithAggregatesFilter<"MachineSensor"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MachineSensor"> | Date | string
  }

  export type MachineAlertWhereInput = {
    AND?: MachineAlertWhereInput | MachineAlertWhereInput[]
    OR?: MachineAlertWhereInput[]
    NOT?: MachineAlertWhereInput | MachineAlertWhereInput[]
    id?: StringFilter<"MachineAlert"> | string
    machineId?: StringFilter<"MachineAlert"> | string
    severity?: StringFilter<"MachineAlert"> | string
    type?: StringFilter<"MachineAlert"> | string
    title?: StringFilter<"MachineAlert"> | string
    description?: StringNullableFilter<"MachineAlert"> | string | null
    acknowledged?: BoolFilter<"MachineAlert"> | boolean
    acknowledgedBy?: StringNullableFilter<"MachineAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"MachineAlert"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"MachineAlert"> | Date | string | null
    metadata?: JsonNullableFilter<"MachineAlert">
    createdAt?: DateTimeFilter<"MachineAlert"> | Date | string
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
  }

  export type MachineAlertOrderByWithRelationInput = {
    id?: SortOrder
    machineId?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    machine?: MachineOrderByWithRelationInput
  }

  export type MachineAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MachineAlertWhereInput | MachineAlertWhereInput[]
    OR?: MachineAlertWhereInput[]
    NOT?: MachineAlertWhereInput | MachineAlertWhereInput[]
    machineId?: StringFilter<"MachineAlert"> | string
    severity?: StringFilter<"MachineAlert"> | string
    type?: StringFilter<"MachineAlert"> | string
    title?: StringFilter<"MachineAlert"> | string
    description?: StringNullableFilter<"MachineAlert"> | string | null
    acknowledged?: BoolFilter<"MachineAlert"> | boolean
    acknowledgedBy?: StringNullableFilter<"MachineAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"MachineAlert"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"MachineAlert"> | Date | string | null
    metadata?: JsonNullableFilter<"MachineAlert">
    createdAt?: DateTimeFilter<"MachineAlert"> | Date | string
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
  }, "id">

  export type MachineAlertOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MachineAlertCountOrderByAggregateInput
    _max?: MachineAlertMaxOrderByAggregateInput
    _min?: MachineAlertMinOrderByAggregateInput
  }

  export type MachineAlertScalarWhereWithAggregatesInput = {
    AND?: MachineAlertScalarWhereWithAggregatesInput | MachineAlertScalarWhereWithAggregatesInput[]
    OR?: MachineAlertScalarWhereWithAggregatesInput[]
    NOT?: MachineAlertScalarWhereWithAggregatesInput | MachineAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MachineAlert"> | string
    machineId?: StringWithAggregatesFilter<"MachineAlert"> | string
    severity?: StringWithAggregatesFilter<"MachineAlert"> | string
    type?: StringWithAggregatesFilter<"MachineAlert"> | string
    title?: StringWithAggregatesFilter<"MachineAlert"> | string
    description?: StringNullableWithAggregatesFilter<"MachineAlert"> | string | null
    acknowledged?: BoolWithAggregatesFilter<"MachineAlert"> | boolean
    acknowledgedBy?: StringNullableWithAggregatesFilter<"MachineAlert"> | string | null
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"MachineAlert"> | Date | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"MachineAlert"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"MachineAlert">
    createdAt?: DateTimeWithAggregatesFilter<"MachineAlert"> | Date | string
  }

  export type MachineMaintenanceRecordWhereInput = {
    AND?: MachineMaintenanceRecordWhereInput | MachineMaintenanceRecordWhereInput[]
    OR?: MachineMaintenanceRecordWhereInput[]
    NOT?: MachineMaintenanceRecordWhereInput | MachineMaintenanceRecordWhereInput[]
    id?: StringFilter<"MachineMaintenanceRecord"> | string
    machineId?: StringFilter<"MachineMaintenanceRecord"> | string
    type?: StringFilter<"MachineMaintenanceRecord"> | string
    description?: StringFilter<"MachineMaintenanceRecord"> | string
    performedBy?: StringNullableFilter<"MachineMaintenanceRecord"> | string | null
    scheduledDate?: DateTimeNullableFilter<"MachineMaintenanceRecord"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"MachineMaintenanceRecord"> | Date | string | null
    duration?: IntNullableFilter<"MachineMaintenanceRecord"> | number | null
    cost?: FloatNullableFilter<"MachineMaintenanceRecord"> | number | null
    status?: StringFilter<"MachineMaintenanceRecord"> | string
    notes?: StringNullableFilter<"MachineMaintenanceRecord"> | string | null
    attachments?: StringNullableListFilter<"MachineMaintenanceRecord">
    createdAt?: DateTimeFilter<"MachineMaintenanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MachineMaintenanceRecord"> | Date | string
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
  }

  export type MachineMaintenanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    machineId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    performedBy?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    machine?: MachineOrderByWithRelationInput
  }

  export type MachineMaintenanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MachineMaintenanceRecordWhereInput | MachineMaintenanceRecordWhereInput[]
    OR?: MachineMaintenanceRecordWhereInput[]
    NOT?: MachineMaintenanceRecordWhereInput | MachineMaintenanceRecordWhereInput[]
    machineId?: StringFilter<"MachineMaintenanceRecord"> | string
    type?: StringFilter<"MachineMaintenanceRecord"> | string
    description?: StringFilter<"MachineMaintenanceRecord"> | string
    performedBy?: StringNullableFilter<"MachineMaintenanceRecord"> | string | null
    scheduledDate?: DateTimeNullableFilter<"MachineMaintenanceRecord"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"MachineMaintenanceRecord"> | Date | string | null
    duration?: IntNullableFilter<"MachineMaintenanceRecord"> | number | null
    cost?: FloatNullableFilter<"MachineMaintenanceRecord"> | number | null
    status?: StringFilter<"MachineMaintenanceRecord"> | string
    notes?: StringNullableFilter<"MachineMaintenanceRecord"> | string | null
    attachments?: StringNullableListFilter<"MachineMaintenanceRecord">
    createdAt?: DateTimeFilter<"MachineMaintenanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MachineMaintenanceRecord"> | Date | string
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
  }, "id">

  export type MachineMaintenanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    machineId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    performedBy?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MachineMaintenanceRecordCountOrderByAggregateInput
    _avg?: MachineMaintenanceRecordAvgOrderByAggregateInput
    _max?: MachineMaintenanceRecordMaxOrderByAggregateInput
    _min?: MachineMaintenanceRecordMinOrderByAggregateInput
    _sum?: MachineMaintenanceRecordSumOrderByAggregateInput
  }

  export type MachineMaintenanceRecordScalarWhereWithAggregatesInput = {
    AND?: MachineMaintenanceRecordScalarWhereWithAggregatesInput | MachineMaintenanceRecordScalarWhereWithAggregatesInput[]
    OR?: MachineMaintenanceRecordScalarWhereWithAggregatesInput[]
    NOT?: MachineMaintenanceRecordScalarWhereWithAggregatesInput | MachineMaintenanceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MachineMaintenanceRecord"> | string
    machineId?: StringWithAggregatesFilter<"MachineMaintenanceRecord"> | string
    type?: StringWithAggregatesFilter<"MachineMaintenanceRecord"> | string
    description?: StringWithAggregatesFilter<"MachineMaintenanceRecord"> | string
    performedBy?: StringNullableWithAggregatesFilter<"MachineMaintenanceRecord"> | string | null
    scheduledDate?: DateTimeNullableWithAggregatesFilter<"MachineMaintenanceRecord"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"MachineMaintenanceRecord"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"MachineMaintenanceRecord"> | number | null
    cost?: FloatNullableWithAggregatesFilter<"MachineMaintenanceRecord"> | number | null
    status?: StringWithAggregatesFilter<"MachineMaintenanceRecord"> | string
    notes?: StringNullableWithAggregatesFilter<"MachineMaintenanceRecord"> | string | null
    attachments?: StringNullableListFilter<"MachineMaintenanceRecord">
    createdAt?: DateTimeWithAggregatesFilter<"MachineMaintenanceRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MachineMaintenanceRecord"> | Date | string
  }

  export type QualityCheckWhereInput = {
    AND?: QualityCheckWhereInput | QualityCheckWhereInput[]
    OR?: QualityCheckWhereInput[]
    NOT?: QualityCheckWhereInput | QualityCheckWhereInput[]
    id?: StringFilter<"QualityCheck"> | string
    productionId?: StringNullableFilter<"QualityCheck"> | string | null
    checkType?: StringFilter<"QualityCheck"> | string
    checkDate?: DateTimeFilter<"QualityCheck"> | Date | string
    inspector?: StringNullableFilter<"QualityCheck"> | string | null
    passed?: BoolFilter<"QualityCheck"> | boolean
    score?: FloatNullableFilter<"QualityCheck"> | number | null
    defectCount?: IntFilter<"QualityCheck"> | number
    sampleSize?: IntNullableFilter<"QualityCheck"> | number | null
    notes?: StringNullableFilter<"QualityCheck"> | string | null
    corrective?: StringNullableFilter<"QualityCheck"> | string | null
    attachments?: StringNullableListFilter<"QualityCheck">
    metadata?: JsonNullableFilter<"QualityCheck">
    createdAt?: DateTimeFilter<"QualityCheck"> | Date | string
    production?: XOR<ProductionNullableScalarRelationFilter, ProductionWhereInput> | null
  }

  export type QualityCheckOrderByWithRelationInput = {
    id?: SortOrder
    productionId?: SortOrderInput | SortOrder
    checkType?: SortOrder
    checkDate?: SortOrder
    inspector?: SortOrderInput | SortOrder
    passed?: SortOrder
    score?: SortOrderInput | SortOrder
    defectCount?: SortOrder
    sampleSize?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    corrective?: SortOrderInput | SortOrder
    attachments?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    production?: ProductionOrderByWithRelationInput
  }

  export type QualityCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QualityCheckWhereInput | QualityCheckWhereInput[]
    OR?: QualityCheckWhereInput[]
    NOT?: QualityCheckWhereInput | QualityCheckWhereInput[]
    productionId?: StringNullableFilter<"QualityCheck"> | string | null
    checkType?: StringFilter<"QualityCheck"> | string
    checkDate?: DateTimeFilter<"QualityCheck"> | Date | string
    inspector?: StringNullableFilter<"QualityCheck"> | string | null
    passed?: BoolFilter<"QualityCheck"> | boolean
    score?: FloatNullableFilter<"QualityCheck"> | number | null
    defectCount?: IntFilter<"QualityCheck"> | number
    sampleSize?: IntNullableFilter<"QualityCheck"> | number | null
    notes?: StringNullableFilter<"QualityCheck"> | string | null
    corrective?: StringNullableFilter<"QualityCheck"> | string | null
    attachments?: StringNullableListFilter<"QualityCheck">
    metadata?: JsonNullableFilter<"QualityCheck">
    createdAt?: DateTimeFilter<"QualityCheck"> | Date | string
    production?: XOR<ProductionNullableScalarRelationFilter, ProductionWhereInput> | null
  }, "id">

  export type QualityCheckOrderByWithAggregationInput = {
    id?: SortOrder
    productionId?: SortOrderInput | SortOrder
    checkType?: SortOrder
    checkDate?: SortOrder
    inspector?: SortOrderInput | SortOrder
    passed?: SortOrder
    score?: SortOrderInput | SortOrder
    defectCount?: SortOrder
    sampleSize?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    corrective?: SortOrderInput | SortOrder
    attachments?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QualityCheckCountOrderByAggregateInput
    _avg?: QualityCheckAvgOrderByAggregateInput
    _max?: QualityCheckMaxOrderByAggregateInput
    _min?: QualityCheckMinOrderByAggregateInput
    _sum?: QualityCheckSumOrderByAggregateInput
  }

  export type QualityCheckScalarWhereWithAggregatesInput = {
    AND?: QualityCheckScalarWhereWithAggregatesInput | QualityCheckScalarWhereWithAggregatesInput[]
    OR?: QualityCheckScalarWhereWithAggregatesInput[]
    NOT?: QualityCheckScalarWhereWithAggregatesInput | QualityCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QualityCheck"> | string
    productionId?: StringNullableWithAggregatesFilter<"QualityCheck"> | string | null
    checkType?: StringWithAggregatesFilter<"QualityCheck"> | string
    checkDate?: DateTimeWithAggregatesFilter<"QualityCheck"> | Date | string
    inspector?: StringNullableWithAggregatesFilter<"QualityCheck"> | string | null
    passed?: BoolWithAggregatesFilter<"QualityCheck"> | boolean
    score?: FloatNullableWithAggregatesFilter<"QualityCheck"> | number | null
    defectCount?: IntWithAggregatesFilter<"QualityCheck"> | number
    sampleSize?: IntNullableWithAggregatesFilter<"QualityCheck"> | number | null
    notes?: StringNullableWithAggregatesFilter<"QualityCheck"> | string | null
    corrective?: StringNullableWithAggregatesFilter<"QualityCheck"> | string | null
    attachments?: StringNullableListFilter<"QualityCheck">
    metadata?: JsonNullableWithAggregatesFilter<"QualityCheck">
    createdAt?: DateTimeWithAggregatesFilter<"QualityCheck"> | Date | string
  }

  export type ProductionOrderWhereInput = {
    AND?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    OR?: ProductionOrderWhereInput[]
    NOT?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    id?: StringFilter<"ProductionOrder"> | string
    orderNumber?: StringFilter<"ProductionOrder"> | string
    productSKU?: StringFilter<"ProductionOrder"> | string
    quantity?: IntFilter<"ProductionOrder"> | number
    priority?: EnumPriorityFilter<"ProductionOrder"> | $Enums.Priority
    status?: EnumProductionStatusFilter<"ProductionOrder"> | $Enums.ProductionStatus
    scheduledStart?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    scheduledEnd?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    actualStart?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    actualEnd?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    assignedMachine?: StringNullableFilter<"ProductionOrder"> | string | null
    assignedOperator?: StringNullableFilter<"ProductionOrder"> | string | null
    batchNumber?: StringNullableFilter<"ProductionOrder"> | string | null
    qualityGrade?: StringNullableFilter<"ProductionOrder"> | string | null
    yield?: FloatNullableFilter<"ProductionOrder"> | number | null
    efficiency?: FloatNullableFilter<"ProductionOrder"> | number | null
    notes?: StringNullableFilter<"ProductionOrder"> | string | null
    metadata?: JsonNullableFilter<"ProductionOrder">
    createdAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOrder"> | Date | string
  }

  export type ProductionOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    productSKU?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledStart?: SortOrderInput | SortOrder
    scheduledEnd?: SortOrderInput | SortOrder
    actualStart?: SortOrderInput | SortOrder
    actualEnd?: SortOrderInput | SortOrder
    assignedMachine?: SortOrderInput | SortOrder
    assignedOperator?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    qualityGrade?: SortOrderInput | SortOrder
    yield?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    OR?: ProductionOrderWhereInput[]
    NOT?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    productSKU?: StringFilter<"ProductionOrder"> | string
    quantity?: IntFilter<"ProductionOrder"> | number
    priority?: EnumPriorityFilter<"ProductionOrder"> | $Enums.Priority
    status?: EnumProductionStatusFilter<"ProductionOrder"> | $Enums.ProductionStatus
    scheduledStart?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    scheduledEnd?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    actualStart?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    actualEnd?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    assignedMachine?: StringNullableFilter<"ProductionOrder"> | string | null
    assignedOperator?: StringNullableFilter<"ProductionOrder"> | string | null
    batchNumber?: StringNullableFilter<"ProductionOrder"> | string | null
    qualityGrade?: StringNullableFilter<"ProductionOrder"> | string | null
    yield?: FloatNullableFilter<"ProductionOrder"> | number | null
    efficiency?: FloatNullableFilter<"ProductionOrder"> | number | null
    notes?: StringNullableFilter<"ProductionOrder"> | string | null
    metadata?: JsonNullableFilter<"ProductionOrder">
    createdAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOrder"> | Date | string
  }, "id" | "orderNumber">

  export type ProductionOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    productSKU?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledStart?: SortOrderInput | SortOrder
    scheduledEnd?: SortOrderInput | SortOrder
    actualStart?: SortOrderInput | SortOrder
    actualEnd?: SortOrderInput | SortOrder
    assignedMachine?: SortOrderInput | SortOrder
    assignedOperator?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    qualityGrade?: SortOrderInput | SortOrder
    yield?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionOrderCountOrderByAggregateInput
    _avg?: ProductionOrderAvgOrderByAggregateInput
    _max?: ProductionOrderMaxOrderByAggregateInput
    _min?: ProductionOrderMinOrderByAggregateInput
    _sum?: ProductionOrderSumOrderByAggregateInput
  }

  export type ProductionOrderScalarWhereWithAggregatesInput = {
    AND?: ProductionOrderScalarWhereWithAggregatesInput | ProductionOrderScalarWhereWithAggregatesInput[]
    OR?: ProductionOrderScalarWhereWithAggregatesInput[]
    NOT?: ProductionOrderScalarWhereWithAggregatesInput | ProductionOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductionOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"ProductionOrder"> | string
    productSKU?: StringWithAggregatesFilter<"ProductionOrder"> | string
    quantity?: IntWithAggregatesFilter<"ProductionOrder"> | number
    priority?: EnumPriorityWithAggregatesFilter<"ProductionOrder"> | $Enums.Priority
    status?: EnumProductionStatusWithAggregatesFilter<"ProductionOrder"> | $Enums.ProductionStatus
    scheduledStart?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    scheduledEnd?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    actualStart?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    actualEnd?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    assignedMachine?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    assignedOperator?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    qualityGrade?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    yield?: FloatNullableWithAggregatesFilter<"ProductionOrder"> | number | null
    efficiency?: FloatNullableWithAggregatesFilter<"ProductionOrder"> | number | null
    notes?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ProductionOrder">
    createdAt?: DateTimeWithAggregatesFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionOrder"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    role: $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dashboards?: DashboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    role: $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dashboards?: DashboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dashboards?: DashboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dashboards?: DashboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    role: $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingCapitalCreateInput = {
    id?: string
    date?: Date | string
    currentAssets: number
    currentLiabilities: number
    inventory: number
    accountsReceivable: number
    accountsPayable: number
    cash: number
    dso: number
    dpo: number
    dio: number
    cashConversionCycle: number
    workingCapitalRatio: number
    quickRatio: number
    createdAt?: Date | string
  }

  export type WorkingCapitalUncheckedCreateInput = {
    id?: string
    date?: Date | string
    currentAssets: number
    currentLiabilities: number
    inventory: number
    accountsReceivable: number
    accountsPayable: number
    cash: number
    dso: number
    dpo: number
    dio: number
    cashConversionCycle: number
    workingCapitalRatio: number
    quickRatio: number
    createdAt?: Date | string
  }

  export type WorkingCapitalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAssets?: FloatFieldUpdateOperationsInput | number
    currentLiabilities?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    accountsReceivable?: FloatFieldUpdateOperationsInput | number
    accountsPayable?: FloatFieldUpdateOperationsInput | number
    cash?: FloatFieldUpdateOperationsInput | number
    dso?: IntFieldUpdateOperationsInput | number
    dpo?: IntFieldUpdateOperationsInput | number
    dio?: IntFieldUpdateOperationsInput | number
    cashConversionCycle?: IntFieldUpdateOperationsInput | number
    workingCapitalRatio?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingCapitalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAssets?: FloatFieldUpdateOperationsInput | number
    currentLiabilities?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    accountsReceivable?: FloatFieldUpdateOperationsInput | number
    accountsPayable?: FloatFieldUpdateOperationsInput | number
    cash?: FloatFieldUpdateOperationsInput | number
    dso?: IntFieldUpdateOperationsInput | number
    dpo?: IntFieldUpdateOperationsInput | number
    dio?: IntFieldUpdateOperationsInput | number
    cashConversionCycle?: IntFieldUpdateOperationsInput | number
    workingCapitalRatio?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingCapitalCreateManyInput = {
    id?: string
    date?: Date | string
    currentAssets: number
    currentLiabilities: number
    inventory: number
    accountsReceivable: number
    accountsPayable: number
    cash: number
    dso: number
    dpo: number
    dio: number
    cashConversionCycle: number
    workingCapitalRatio: number
    quickRatio: number
    createdAt?: Date | string
  }

  export type WorkingCapitalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAssets?: FloatFieldUpdateOperationsInput | number
    currentLiabilities?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    accountsReceivable?: FloatFieldUpdateOperationsInput | number
    accountsPayable?: FloatFieldUpdateOperationsInput | number
    cash?: FloatFieldUpdateOperationsInput | number
    dso?: IntFieldUpdateOperationsInput | number
    dpo?: IntFieldUpdateOperationsInput | number
    dio?: IntFieldUpdateOperationsInput | number
    cashConversionCycle?: IntFieldUpdateOperationsInput | number
    workingCapitalRatio?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkingCapitalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    currentAssets?: FloatFieldUpdateOperationsInput | number
    currentLiabilities?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    accountsReceivable?: FloatFieldUpdateOperationsInput | number
    accountsPayable?: FloatFieldUpdateOperationsInput | number
    cash?: FloatFieldUpdateOperationsInput | number
    dso?: IntFieldUpdateOperationsInput | number
    dpo?: IntFieldUpdateOperationsInput | number
    dio?: IntFieldUpdateOperationsInput | number
    cashConversionCycle?: IntFieldUpdateOperationsInput | number
    workingCapitalRatio?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRunwayCreateInput = {
    id?: string
    date: Date | string
    cashBalance: number
    monthlyBurnRate: number
    monthlyRevenue: number
    netBurnRate: number
    runwayMonths: number
    coverageDay30: number
    coverageDay60: number
    coverageDay90: number
    coverageDay120: number
    coverageDay180: number
    createdAt?: Date | string
  }

  export type CashRunwayUncheckedCreateInput = {
    id?: string
    date: Date | string
    cashBalance: number
    monthlyBurnRate: number
    monthlyRevenue: number
    netBurnRate: number
    runwayMonths: number
    coverageDay30: number
    coverageDay60: number
    coverageDay90: number
    coverageDay120: number
    coverageDay180: number
    createdAt?: Date | string
  }

  export type CashRunwayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    cashBalance?: FloatFieldUpdateOperationsInput | number
    monthlyBurnRate?: FloatFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    netBurnRate?: FloatFieldUpdateOperationsInput | number
    runwayMonths?: FloatFieldUpdateOperationsInput | number
    coverageDay30?: FloatFieldUpdateOperationsInput | number
    coverageDay60?: FloatFieldUpdateOperationsInput | number
    coverageDay90?: FloatFieldUpdateOperationsInput | number
    coverageDay120?: FloatFieldUpdateOperationsInput | number
    coverageDay180?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRunwayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    cashBalance?: FloatFieldUpdateOperationsInput | number
    monthlyBurnRate?: FloatFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    netBurnRate?: FloatFieldUpdateOperationsInput | number
    runwayMonths?: FloatFieldUpdateOperationsInput | number
    coverageDay30?: FloatFieldUpdateOperationsInput | number
    coverageDay60?: FloatFieldUpdateOperationsInput | number
    coverageDay90?: FloatFieldUpdateOperationsInput | number
    coverageDay120?: FloatFieldUpdateOperationsInput | number
    coverageDay180?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRunwayCreateManyInput = {
    id?: string
    date: Date | string
    cashBalance: number
    monthlyBurnRate: number
    monthlyRevenue: number
    netBurnRate: number
    runwayMonths: number
    coverageDay30: number
    coverageDay60: number
    coverageDay90: number
    coverageDay120: number
    coverageDay180: number
    createdAt?: Date | string
  }

  export type CashRunwayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    cashBalance?: FloatFieldUpdateOperationsInput | number
    monthlyBurnRate?: FloatFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    netBurnRate?: FloatFieldUpdateOperationsInput | number
    runwayMonths?: FloatFieldUpdateOperationsInput | number
    coverageDay30?: FloatFieldUpdateOperationsInput | number
    coverageDay60?: FloatFieldUpdateOperationsInput | number
    coverageDay90?: FloatFieldUpdateOperationsInput | number
    coverageDay120?: FloatFieldUpdateOperationsInput | number
    coverageDay180?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRunwayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    cashBalance?: FloatFieldUpdateOperationsInput | number
    monthlyBurnRate?: FloatFieldUpdateOperationsInput | number
    monthlyRevenue?: FloatFieldUpdateOperationsInput | number
    netBurnRate?: FloatFieldUpdateOperationsInput | number
    runwayMonths?: FloatFieldUpdateOperationsInput | number
    coverageDay30?: FloatFieldUpdateOperationsInput | number
    coverageDay60?: FloatFieldUpdateOperationsInput | number
    coverageDay90?: FloatFieldUpdateOperationsInput | number
    coverageDay120?: FloatFieldUpdateOperationsInput | number
    coverageDay180?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionCreateInput = {
    id?: string
    jobNumber: string
    productName: string
    productSKU?: string | null
    quantity: number
    targetQuantity: number
    completedQuantity?: number
    status: $Enums.ProductionStatus
    priority: $Enums.Priority
    startDate: Date | string
    targetDate: Date | string
    completionDate?: Date | string | null
    qualityScore?: number | null
    defectRate?: number | null
    efficiency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityChecks?: QualityCheckCreateNestedManyWithoutProductionInput
  }

  export type ProductionUncheckedCreateInput = {
    id?: string
    jobNumber: string
    productName: string
    productSKU?: string | null
    quantity: number
    targetQuantity: number
    completedQuantity?: number
    status: $Enums.ProductionStatus
    priority: $Enums.Priority
    startDate: Date | string
    targetDate: Date | string
    completionDate?: Date | string | null
    qualityScore?: number | null
    defectRate?: number | null
    efficiency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityChecks?: QualityCheckUncheckedCreateNestedManyWithoutProductionInput
  }

  export type ProductionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productSKU?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    targetQuantity?: IntFieldUpdateOperationsInput | number
    completedQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    defectRate?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityChecks?: QualityCheckUpdateManyWithoutProductionNestedInput
  }

  export type ProductionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productSKU?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    targetQuantity?: IntFieldUpdateOperationsInput | number
    completedQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    defectRate?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityChecks?: QualityCheckUncheckedUpdateManyWithoutProductionNestedInput
  }

  export type ProductionCreateManyInput = {
    id?: string
    jobNumber: string
    productName: string
    productSKU?: string | null
    quantity: number
    targetQuantity: number
    completedQuantity?: number
    status: $Enums.ProductionStatus
    priority: $Enums.Priority
    startDate: Date | string
    targetDate: Date | string
    completionDate?: Date | string | null
    qualityScore?: number | null
    defectRate?: number | null
    efficiency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productSKU?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    targetQuantity?: IntFieldUpdateOperationsInput | number
    completedQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    defectRate?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productSKU?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    targetQuantity?: IntFieldUpdateOperationsInput | number
    completedQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    defectRate?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    reorderPoint: number
    reorderQuantity: number
    location: string
    warehouse: string
    unitCost: number
    totalValue: number
    lastMovement?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    reorderPoint: number
    reorderQuantity: number
    location: string
    warehouse: string
    unitCost: number
    totalValue: number
    lastMovement?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    warehouse?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    lastMovement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    warehouse?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    lastMovement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: InventoryMovementUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    reorderPoint: number
    reorderQuantity: number
    location: string
    warehouse: string
    unitCost: number
    totalValue: number
    lastMovement?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    warehouse?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    lastMovement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    warehouse?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    lastMovement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    reference?: string | null
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutMovementsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: string
    inventoryId: string
    type: $Enums.MovementType
    quantity: number
    reference?: string | null
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyInput = {
    id?: string
    inventoryId: string
    type: $Enums.MovementType
    quantity: number
    reference?: string | null
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightCreateInput = {
    id?: string
    type: string
    category: string
    title: string
    content: string
    confidence: number
    priority: string
    embedding?: AIInsightCreateembeddingInput | number[]
    metadata: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    actioned?: boolean
    createdAt?: Date | string
  }

  export type AIInsightUncheckedCreateInput = {
    id?: string
    type: string
    category: string
    title: string
    content: string
    confidence: number
    priority: string
    embedding?: AIInsightCreateembeddingInput | number[]
    metadata: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    actioned?: boolean
    createdAt?: Date | string
  }

  export type AIInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    embedding?: AIInsightUpdateembeddingInput | number[]
    metadata?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    actioned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    embedding?: AIInsightUpdateembeddingInput | number[]
    metadata?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    actioned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightCreateManyInput = {
    id?: string
    type: string
    category: string
    title: string
    content: string
    confidence: number
    priority: string
    embedding?: AIInsightCreateembeddingInput | number[]
    metadata: JsonNullValueInput | InputJsonValue
    actionable?: boolean
    actioned?: boolean
    createdAt?: Date | string
  }

  export type AIInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    embedding?: AIInsightUpdateembeddingInput | number[]
    metadata?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    actioned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    priority?: StringFieldUpdateOperationsInput | string
    embedding?: AIInsightUpdateembeddingInput | number[]
    metadata?: JsonNullValueInput | InputJsonValue
    actionable?: BoolFieldUpdateOperationsInput | boolean
    actioned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardCreateInput = {
    id?: string
    name: string
    type: string
    layout: JsonNullValueInput | InputJsonValue
    widgets: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDashboardsInput
  }

  export type DashboardUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    type: string
    layout: JsonNullValueInput | InputJsonValue
    widgets: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    layout?: JsonNullValueInput | InputJsonValue
    widgets?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDashboardsNestedInput
  }

  export type DashboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    layout?: JsonNullValueInput | InputJsonValue
    widgets?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardCreateManyInput = {
    id?: string
    userId: string
    name: string
    type: string
    layout: JsonNullValueInput | InputJsonValue
    widgets: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    layout?: JsonNullValueInput | InputJsonValue
    widgets?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    layout?: JsonNullValueInput | InputJsonValue
    widgets?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateInput = {
    id?: string
    date: Date | string
    metric: string
    value: number
    dimension?: string | null
    forecast?: number | null
    actual?: number | null
    variance?: number | null
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUncheckedCreateInput = {
    id?: string
    date: Date | string
    metric: string
    value: number
    dimension?: string | null
    forecast?: number | null
    actual?: number | null
    variance?: number | null
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    metric?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    forecast?: NullableFloatFieldUpdateOperationsInput | number | null
    actual?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    metric?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    forecast?: NullableFloatFieldUpdateOperationsInput | number | null
    actual?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateManyInput = {
    id?: string
    date: Date | string
    metric: string
    value: number
    dimension?: string | null
    forecast?: number | null
    actual?: number | null
    variance?: number | null
    metadata: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    metric?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    forecast?: NullableFloatFieldUpdateOperationsInput | number | null
    actual?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    metric?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    dimension?: NullableStringFieldUpdateOperationsInput | string | null
    forecast?: NullableFloatFieldUpdateOperationsInput | number | null
    actual?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPRequestCreateInput = {
    id?: string
    tool: string
    request: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    status: string
    processingTime?: number | null
    error?: string | null
    createdAt?: Date | string
  }

  export type MCPRequestUncheckedCreateInput = {
    id?: string
    tool: string
    request: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    status: string
    processingTime?: number | null
    error?: string | null
    createdAt?: Date | string
  }

  export type MCPRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tool?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tool?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPRequestCreateManyInput = {
    id?: string
    tool: string
    request: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    status: string
    processingTime?: number | null
    error?: string | null
    createdAt?: Date | string
  }

  export type MCPRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tool?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tool?: StringFieldUpdateOperationsInput | string
    request?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashLedgerCreateInput = {
    id?: string
    date?: Date | string
    description: string
    category: string
    subCategory?: string | null
    amount: number
    balance: number
    source: string
    sourceId?: string | null
    reconciledStatus?: string
    tags?: CashLedgerCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashLedgerUncheckedCreateInput = {
    id?: string
    date?: Date | string
    description: string
    category: string
    subCategory?: string | null
    amount: number
    balance: number
    source: string
    sourceId?: string | null
    reconciledStatus?: string
    tags?: CashLedgerCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledStatus?: StringFieldUpdateOperationsInput | string
    tags?: CashLedgerUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledStatus?: StringFieldUpdateOperationsInput | string
    tags?: CashLedgerUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashLedgerCreateManyInput = {
    id?: string
    date?: Date | string
    description: string
    category: string
    subCategory?: string | null
    amount: number
    balance: number
    source: string
    sourceId?: string | null
    reconciledStatus?: string
    tags?: CashLedgerCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledStatus?: StringFieldUpdateOperationsInput | string
    tags?: CashLedgerUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    reconciledStatus?: StringFieldUpdateOperationsInput | string
    tags?: CashLedgerUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashProjectionCreateInput = {
    id?: string
    projectionDate: Date | string
    projectedAmount: number
    actualAmount?: number | null
    variance?: number | null
    confidenceLevel: number
    scenarioType?: string
    assumptions: JsonNullValueInput | InputJsonValue
    projectionMethod: string
    dataSource: string
    isAdjusted?: boolean
    adjustmentReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashProjectionUncheckedCreateInput = {
    id?: string
    projectionDate: Date | string
    projectedAmount: number
    actualAmount?: number | null
    variance?: number | null
    confidenceLevel: number
    scenarioType?: string
    assumptions: JsonNullValueInput | InputJsonValue
    projectionMethod: string
    dataSource: string
    isAdjusted?: boolean
    adjustmentReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashProjectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    scenarioType?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    projectionMethod?: StringFieldUpdateOperationsInput | string
    dataSource?: StringFieldUpdateOperationsInput | string
    isAdjusted?: BoolFieldUpdateOperationsInput | boolean
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashProjectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    scenarioType?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    projectionMethod?: StringFieldUpdateOperationsInput | string
    dataSource?: StringFieldUpdateOperationsInput | string
    isAdjusted?: BoolFieldUpdateOperationsInput | boolean
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashProjectionCreateManyInput = {
    id?: string
    projectionDate: Date | string
    projectedAmount: number
    actualAmount?: number | null
    variance?: number | null
    confidenceLevel: number
    scenarioType?: string
    assumptions: JsonNullValueInput | InputJsonValue
    projectionMethod: string
    dataSource: string
    isAdjusted?: boolean
    adjustmentReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashProjectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    scenarioType?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    projectionMethod?: StringFieldUpdateOperationsInput | string
    dataSource?: StringFieldUpdateOperationsInput | string
    isAdjusted?: BoolFieldUpdateOperationsInput | boolean
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashProjectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectedAmount?: FloatFieldUpdateOperationsInput | number
    actualAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    variance?: NullableFloatFieldUpdateOperationsInput | number | null
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    scenarioType?: StringFieldUpdateOperationsInput | string
    assumptions?: JsonNullValueInput | InputJsonValue
    projectionMethod?: StringFieldUpdateOperationsInput | string
    dataSource?: StringFieldUpdateOperationsInput | string
    isAdjusted?: BoolFieldUpdateOperationsInput | boolean
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    date?: Date | string
    vendor: string
    category: string
    subCategory?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    invoiceNumber?: string | null
    approvedBy?: string | null
    department?: string | null
    project?: string | null
    isRecurring?: boolean
    recurringPeriod?: string | null
    taxAmount?: number | null
    tags?: ExpenseCreatetagsInput | string[]
    attachments?: ExpenseCreateattachmentsInput | string[]
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    date?: Date | string
    vendor: string
    category: string
    subCategory?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    invoiceNumber?: string | null
    approvedBy?: string | null
    department?: string | null
    project?: string | null
    isRecurring?: boolean
    recurringPeriod?: string | null
    taxAmount?: number | null
    tags?: ExpenseCreatetagsInput | string[]
    attachments?: ExpenseCreateattachmentsInput | string[]
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: ExpenseUpdatetagsInput | string[]
    attachments?: ExpenseUpdateattachmentsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: ExpenseUpdatetagsInput | string[]
    attachments?: ExpenseUpdateattachmentsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    date?: Date | string
    vendor: string
    category: string
    subCategory?: string | null
    amount: number
    currency?: string
    paymentMethod: string
    invoiceNumber?: string | null
    approvedBy?: string | null
    department?: string | null
    project?: string | null
    isRecurring?: boolean
    recurringPeriod?: string | null
    taxAmount?: number | null
    tags?: ExpenseCreatetagsInput | string[]
    attachments?: ExpenseCreateattachmentsInput | string[]
    notes?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: ExpenseUpdatetagsInput | string[]
    attachments?: ExpenseUpdateattachmentsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    project?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringPeriod?: NullableStringFieldUpdateOperationsInput | string | null
    taxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: ExpenseUpdatetagsInput | string[]
    attachments?: ExpenseUpdateattachmentsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveMetricCreateInput = {
    id?: string
    date?: Date | string
    revenue: number
    revenueTarget: number
    revenueTrend: number
    cashFlow: number
    cashFlowTarget: number
    cashFlowTrend: number
    currentRatio: number
    currentRatioTarget?: number
    currentRatioTrend: number
    quickRatio: number
    quickRatioTarget?: number
    quickRatioTrend: number
    oee: number
    oeeTarget?: number
    oeeTrend: number
    throughput: number
    throughputTarget: number
    throughputTrend: number
    marketShare: number
    marketShareTarget: number
    marketShareTrend: number
    customerSatisfaction: number
    customerSatisfactionTarget?: number
    customerSatisfactionTrend: number
    currentAssets: number
    currentLiabilities: number
    inventory: number
    daysInventory: number
    daysReceivables: number
    daysPayables: number
    cashUnlock: number
    isActual?: boolean
    confidence?: number
    dataSource?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutiveMetricUncheckedCreateInput = {
    id?: string
    date?: Date | string
    revenue: number
    revenueTarget: number
    revenueTrend: number
    cashFlow: number
    cashFlowTarget: number
    cashFlowTrend: number
    currentRatio: number
    currentRatioTarget?: number
    currentRatioTrend: number
    quickRatio: number
    quickRatioTarget?: number
    quickRatioTrend: number
    oee: number
    oeeTarget?: number
    oeeTrend: number
    throughput: number
    throughputTarget: number
    throughputTrend: number
    marketShare: number
    marketShareTarget: number
    marketShareTrend: number
    customerSatisfaction: number
    customerSatisfactionTarget?: number
    customerSatisfactionTrend: number
    currentAssets: number
    currentLiabilities: number
    inventory: number
    daysInventory: number
    daysReceivables: number
    daysPayables: number
    cashUnlock: number
    isActual?: boolean
    confidence?: number
    dataSource?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutiveMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: FloatFieldUpdateOperationsInput | number
    revenueTarget?: FloatFieldUpdateOperationsInput | number
    revenueTrend?: FloatFieldUpdateOperationsInput | number
    cashFlow?: FloatFieldUpdateOperationsInput | number
    cashFlowTarget?: FloatFieldUpdateOperationsInput | number
    cashFlowTrend?: FloatFieldUpdateOperationsInput | number
    currentRatio?: FloatFieldUpdateOperationsInput | number
    currentRatioTarget?: FloatFieldUpdateOperationsInput | number
    currentRatioTrend?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    quickRatioTarget?: FloatFieldUpdateOperationsInput | number
    quickRatioTrend?: FloatFieldUpdateOperationsInput | number
    oee?: FloatFieldUpdateOperationsInput | number
    oeeTarget?: FloatFieldUpdateOperationsInput | number
    oeeTrend?: FloatFieldUpdateOperationsInput | number
    throughput?: FloatFieldUpdateOperationsInput | number
    throughputTarget?: FloatFieldUpdateOperationsInput | number
    throughputTrend?: FloatFieldUpdateOperationsInput | number
    marketShare?: FloatFieldUpdateOperationsInput | number
    marketShareTarget?: FloatFieldUpdateOperationsInput | number
    marketShareTrend?: FloatFieldUpdateOperationsInput | number
    customerSatisfaction?: FloatFieldUpdateOperationsInput | number
    customerSatisfactionTarget?: FloatFieldUpdateOperationsInput | number
    customerSatisfactionTrend?: FloatFieldUpdateOperationsInput | number
    currentAssets?: FloatFieldUpdateOperationsInput | number
    currentLiabilities?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    daysInventory?: FloatFieldUpdateOperationsInput | number
    daysReceivables?: FloatFieldUpdateOperationsInput | number
    daysPayables?: FloatFieldUpdateOperationsInput | number
    cashUnlock?: FloatFieldUpdateOperationsInput | number
    isActual?: BoolFieldUpdateOperationsInput | boolean
    confidence?: FloatFieldUpdateOperationsInput | number
    dataSource?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: FloatFieldUpdateOperationsInput | number
    revenueTarget?: FloatFieldUpdateOperationsInput | number
    revenueTrend?: FloatFieldUpdateOperationsInput | number
    cashFlow?: FloatFieldUpdateOperationsInput | number
    cashFlowTarget?: FloatFieldUpdateOperationsInput | number
    cashFlowTrend?: FloatFieldUpdateOperationsInput | number
    currentRatio?: FloatFieldUpdateOperationsInput | number
    currentRatioTarget?: FloatFieldUpdateOperationsInput | number
    currentRatioTrend?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    quickRatioTarget?: FloatFieldUpdateOperationsInput | number
    quickRatioTrend?: FloatFieldUpdateOperationsInput | number
    oee?: FloatFieldUpdateOperationsInput | number
    oeeTarget?: FloatFieldUpdateOperationsInput | number
    oeeTrend?: FloatFieldUpdateOperationsInput | number
    throughput?: FloatFieldUpdateOperationsInput | number
    throughputTarget?: FloatFieldUpdateOperationsInput | number
    throughputTrend?: FloatFieldUpdateOperationsInput | number
    marketShare?: FloatFieldUpdateOperationsInput | number
    marketShareTarget?: FloatFieldUpdateOperationsInput | number
    marketShareTrend?: FloatFieldUpdateOperationsInput | number
    customerSatisfaction?: FloatFieldUpdateOperationsInput | number
    customerSatisfactionTarget?: FloatFieldUpdateOperationsInput | number
    customerSatisfactionTrend?: FloatFieldUpdateOperationsInput | number
    currentAssets?: FloatFieldUpdateOperationsInput | number
    currentLiabilities?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    daysInventory?: FloatFieldUpdateOperationsInput | number
    daysReceivables?: FloatFieldUpdateOperationsInput | number
    daysPayables?: FloatFieldUpdateOperationsInput | number
    cashUnlock?: FloatFieldUpdateOperationsInput | number
    isActual?: BoolFieldUpdateOperationsInput | boolean
    confidence?: FloatFieldUpdateOperationsInput | number
    dataSource?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveMetricCreateManyInput = {
    id?: string
    date?: Date | string
    revenue: number
    revenueTarget: number
    revenueTrend: number
    cashFlow: number
    cashFlowTarget: number
    cashFlowTrend: number
    currentRatio: number
    currentRatioTarget?: number
    currentRatioTrend: number
    quickRatio: number
    quickRatioTarget?: number
    quickRatioTrend: number
    oee: number
    oeeTarget?: number
    oeeTrend: number
    throughput: number
    throughputTarget: number
    throughputTrend: number
    marketShare: number
    marketShareTarget: number
    marketShareTrend: number
    customerSatisfaction: number
    customerSatisfactionTarget?: number
    customerSatisfactionTrend: number
    currentAssets: number
    currentLiabilities: number
    inventory: number
    daysInventory: number
    daysReceivables: number
    daysPayables: number
    cashUnlock: number
    isActual?: boolean
    confidence?: number
    dataSource?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutiveMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: FloatFieldUpdateOperationsInput | number
    revenueTarget?: FloatFieldUpdateOperationsInput | number
    revenueTrend?: FloatFieldUpdateOperationsInput | number
    cashFlow?: FloatFieldUpdateOperationsInput | number
    cashFlowTarget?: FloatFieldUpdateOperationsInput | number
    cashFlowTrend?: FloatFieldUpdateOperationsInput | number
    currentRatio?: FloatFieldUpdateOperationsInput | number
    currentRatioTarget?: FloatFieldUpdateOperationsInput | number
    currentRatioTrend?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    quickRatioTarget?: FloatFieldUpdateOperationsInput | number
    quickRatioTrend?: FloatFieldUpdateOperationsInput | number
    oee?: FloatFieldUpdateOperationsInput | number
    oeeTarget?: FloatFieldUpdateOperationsInput | number
    oeeTrend?: FloatFieldUpdateOperationsInput | number
    throughput?: FloatFieldUpdateOperationsInput | number
    throughputTarget?: FloatFieldUpdateOperationsInput | number
    throughputTrend?: FloatFieldUpdateOperationsInput | number
    marketShare?: FloatFieldUpdateOperationsInput | number
    marketShareTarget?: FloatFieldUpdateOperationsInput | number
    marketShareTrend?: FloatFieldUpdateOperationsInput | number
    customerSatisfaction?: FloatFieldUpdateOperationsInput | number
    customerSatisfactionTarget?: FloatFieldUpdateOperationsInput | number
    customerSatisfactionTrend?: FloatFieldUpdateOperationsInput | number
    currentAssets?: FloatFieldUpdateOperationsInput | number
    currentLiabilities?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    daysInventory?: FloatFieldUpdateOperationsInput | number
    daysReceivables?: FloatFieldUpdateOperationsInput | number
    daysPayables?: FloatFieldUpdateOperationsInput | number
    cashUnlock?: FloatFieldUpdateOperationsInput | number
    isActual?: BoolFieldUpdateOperationsInput | boolean
    confidence?: FloatFieldUpdateOperationsInput | number
    dataSource?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: FloatFieldUpdateOperationsInput | number
    revenueTarget?: FloatFieldUpdateOperationsInput | number
    revenueTrend?: FloatFieldUpdateOperationsInput | number
    cashFlow?: FloatFieldUpdateOperationsInput | number
    cashFlowTarget?: FloatFieldUpdateOperationsInput | number
    cashFlowTrend?: FloatFieldUpdateOperationsInput | number
    currentRatio?: FloatFieldUpdateOperationsInput | number
    currentRatioTarget?: FloatFieldUpdateOperationsInput | number
    currentRatioTrend?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    quickRatioTarget?: FloatFieldUpdateOperationsInput | number
    quickRatioTrend?: FloatFieldUpdateOperationsInput | number
    oee?: FloatFieldUpdateOperationsInput | number
    oeeTarget?: FloatFieldUpdateOperationsInput | number
    oeeTrend?: FloatFieldUpdateOperationsInput | number
    throughput?: FloatFieldUpdateOperationsInput | number
    throughputTarget?: FloatFieldUpdateOperationsInput | number
    throughputTrend?: FloatFieldUpdateOperationsInput | number
    marketShare?: FloatFieldUpdateOperationsInput | number
    marketShareTarget?: FloatFieldUpdateOperationsInput | number
    marketShareTrend?: FloatFieldUpdateOperationsInput | number
    customerSatisfaction?: FloatFieldUpdateOperationsInput | number
    customerSatisfactionTarget?: FloatFieldUpdateOperationsInput | number
    customerSatisfactionTrend?: FloatFieldUpdateOperationsInput | number
    currentAssets?: FloatFieldUpdateOperationsInput | number
    currentLiabilities?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    daysInventory?: FloatFieldUpdateOperationsInput | number
    daysReceivables?: FloatFieldUpdateOperationsInput | number
    daysPayables?: FloatFieldUpdateOperationsInput | number
    cashUnlock?: FloatFieldUpdateOperationsInput | number
    isActual?: BoolFieldUpdateOperationsInput | boolean
    confidence?: FloatFieldUpdateOperationsInput | number
    dataSource?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveAlertCreateInput = {
    id?: string
    severity: string
    type: string
    category: string
    title: string
    description: string
    impact?: string | null
    action?: string | null
    source: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isDismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutiveAlertUncheckedCreateInput = {
    id?: string
    severity: string
    type: string
    category: string
    title: string
    description: string
    impact?: string | null
    action?: string | null
    source: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isDismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutiveAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveAlertCreateManyInput = {
    id?: string
    severity: string
    type: string
    category: string
    title: string
    description: string
    impact?: string | null
    action?: string | null
    source: string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isDismissed?: boolean
    dismissedBy?: string | null
    dismissedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExecutiveAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExecutiveAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    metrics?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    dismissedBy?: NullableStringFieldUpdateOperationsInput | string | null
    dismissedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseCashCoverageCreateInput = {
    id?: string
    period: Date | string
    startingCash?: number
    endingCash?: number
    salesRevenue?: number
    subscriptionRevenue?: number
    serviceRevenue?: number
    otherRevenue?: number
    totalRevenue?: number
    payrollExpenses?: number
    rentExpenses?: number
    utilitiesExpenses?: number
    marketingExpenses?: number
    suppliesExpenses?: number
    maintenanceExpenses?: number
    insuranceExpenses?: number
    professionalFees?: number
    otherOperatingExpenses?: number
    totalOperatingExpenses?: number
    capitalExpenses?: number
    loanPayments?: number
    taxPayments?: number
    dividendPayments?: number
    otherNonOperatingExpenses?: number
    netCashFlow?: number
    operatingCashFlow?: number
    financingCashFlow?: number
    investingCashFlow?: number
    cashCoverageRatio?: number
    quickRatio?: number
    currentRatio?: number
    debtServiceCoverageRatio?: number
    accountsReceivable?: number
    accountsPayable?: number
    inventory?: number
    prepaidExpenses?: number
    accruedLiabilities?: number
    daysOfCashOnHand?: number
    burnRate?: number
    runwayMonths?: number
    isActual?: boolean
    isForecast?: boolean
    confidenceScore?: number
    dataSource?: string
    importedFrom?: string | null
    notes?: string | null
    adjustments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnterpriseCashCoverageUncheckedCreateInput = {
    id?: string
    period: Date | string
    startingCash?: number
    endingCash?: number
    salesRevenue?: number
    subscriptionRevenue?: number
    serviceRevenue?: number
    otherRevenue?: number
    totalRevenue?: number
    payrollExpenses?: number
    rentExpenses?: number
    utilitiesExpenses?: number
    marketingExpenses?: number
    suppliesExpenses?: number
    maintenanceExpenses?: number
    insuranceExpenses?: number
    professionalFees?: number
    otherOperatingExpenses?: number
    totalOperatingExpenses?: number
    capitalExpenses?: number
    loanPayments?: number
    taxPayments?: number
    dividendPayments?: number
    otherNonOperatingExpenses?: number
    netCashFlow?: number
    operatingCashFlow?: number
    financingCashFlow?: number
    investingCashFlow?: number
    cashCoverageRatio?: number
    quickRatio?: number
    currentRatio?: number
    debtServiceCoverageRatio?: number
    accountsReceivable?: number
    accountsPayable?: number
    inventory?: number
    prepaidExpenses?: number
    accruedLiabilities?: number
    daysOfCashOnHand?: number
    burnRate?: number
    runwayMonths?: number
    isActual?: boolean
    isForecast?: boolean
    confidenceScore?: number
    dataSource?: string
    importedFrom?: string | null
    notes?: string | null
    adjustments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnterpriseCashCoverageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    startingCash?: FloatFieldUpdateOperationsInput | number
    endingCash?: FloatFieldUpdateOperationsInput | number
    salesRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    otherRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    payrollExpenses?: FloatFieldUpdateOperationsInput | number
    rentExpenses?: FloatFieldUpdateOperationsInput | number
    utilitiesExpenses?: FloatFieldUpdateOperationsInput | number
    marketingExpenses?: FloatFieldUpdateOperationsInput | number
    suppliesExpenses?: FloatFieldUpdateOperationsInput | number
    maintenanceExpenses?: FloatFieldUpdateOperationsInput | number
    insuranceExpenses?: FloatFieldUpdateOperationsInput | number
    professionalFees?: FloatFieldUpdateOperationsInput | number
    otherOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    totalOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    capitalExpenses?: FloatFieldUpdateOperationsInput | number
    loanPayments?: FloatFieldUpdateOperationsInput | number
    taxPayments?: FloatFieldUpdateOperationsInput | number
    dividendPayments?: FloatFieldUpdateOperationsInput | number
    otherNonOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    netCashFlow?: FloatFieldUpdateOperationsInput | number
    operatingCashFlow?: FloatFieldUpdateOperationsInput | number
    financingCashFlow?: FloatFieldUpdateOperationsInput | number
    investingCashFlow?: FloatFieldUpdateOperationsInput | number
    cashCoverageRatio?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    currentRatio?: FloatFieldUpdateOperationsInput | number
    debtServiceCoverageRatio?: FloatFieldUpdateOperationsInput | number
    accountsReceivable?: FloatFieldUpdateOperationsInput | number
    accountsPayable?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    prepaidExpenses?: FloatFieldUpdateOperationsInput | number
    accruedLiabilities?: FloatFieldUpdateOperationsInput | number
    daysOfCashOnHand?: FloatFieldUpdateOperationsInput | number
    burnRate?: FloatFieldUpdateOperationsInput | number
    runwayMonths?: FloatFieldUpdateOperationsInput | number
    isActual?: BoolFieldUpdateOperationsInput | boolean
    isForecast?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    dataSource?: StringFieldUpdateOperationsInput | string
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseCashCoverageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    startingCash?: FloatFieldUpdateOperationsInput | number
    endingCash?: FloatFieldUpdateOperationsInput | number
    salesRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    otherRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    payrollExpenses?: FloatFieldUpdateOperationsInput | number
    rentExpenses?: FloatFieldUpdateOperationsInput | number
    utilitiesExpenses?: FloatFieldUpdateOperationsInput | number
    marketingExpenses?: FloatFieldUpdateOperationsInput | number
    suppliesExpenses?: FloatFieldUpdateOperationsInput | number
    maintenanceExpenses?: FloatFieldUpdateOperationsInput | number
    insuranceExpenses?: FloatFieldUpdateOperationsInput | number
    professionalFees?: FloatFieldUpdateOperationsInput | number
    otherOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    totalOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    capitalExpenses?: FloatFieldUpdateOperationsInput | number
    loanPayments?: FloatFieldUpdateOperationsInput | number
    taxPayments?: FloatFieldUpdateOperationsInput | number
    dividendPayments?: FloatFieldUpdateOperationsInput | number
    otherNonOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    netCashFlow?: FloatFieldUpdateOperationsInput | number
    operatingCashFlow?: FloatFieldUpdateOperationsInput | number
    financingCashFlow?: FloatFieldUpdateOperationsInput | number
    investingCashFlow?: FloatFieldUpdateOperationsInput | number
    cashCoverageRatio?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    currentRatio?: FloatFieldUpdateOperationsInput | number
    debtServiceCoverageRatio?: FloatFieldUpdateOperationsInput | number
    accountsReceivable?: FloatFieldUpdateOperationsInput | number
    accountsPayable?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    prepaidExpenses?: FloatFieldUpdateOperationsInput | number
    accruedLiabilities?: FloatFieldUpdateOperationsInput | number
    daysOfCashOnHand?: FloatFieldUpdateOperationsInput | number
    burnRate?: FloatFieldUpdateOperationsInput | number
    runwayMonths?: FloatFieldUpdateOperationsInput | number
    isActual?: BoolFieldUpdateOperationsInput | boolean
    isForecast?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    dataSource?: StringFieldUpdateOperationsInput | string
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseCashCoverageCreateManyInput = {
    id?: string
    period: Date | string
    startingCash?: number
    endingCash?: number
    salesRevenue?: number
    subscriptionRevenue?: number
    serviceRevenue?: number
    otherRevenue?: number
    totalRevenue?: number
    payrollExpenses?: number
    rentExpenses?: number
    utilitiesExpenses?: number
    marketingExpenses?: number
    suppliesExpenses?: number
    maintenanceExpenses?: number
    insuranceExpenses?: number
    professionalFees?: number
    otherOperatingExpenses?: number
    totalOperatingExpenses?: number
    capitalExpenses?: number
    loanPayments?: number
    taxPayments?: number
    dividendPayments?: number
    otherNonOperatingExpenses?: number
    netCashFlow?: number
    operatingCashFlow?: number
    financingCashFlow?: number
    investingCashFlow?: number
    cashCoverageRatio?: number
    quickRatio?: number
    currentRatio?: number
    debtServiceCoverageRatio?: number
    accountsReceivable?: number
    accountsPayable?: number
    inventory?: number
    prepaidExpenses?: number
    accruedLiabilities?: number
    daysOfCashOnHand?: number
    burnRate?: number
    runwayMonths?: number
    isActual?: boolean
    isForecast?: boolean
    confidenceScore?: number
    dataSource?: string
    importedFrom?: string | null
    notes?: string | null
    adjustments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnterpriseCashCoverageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    startingCash?: FloatFieldUpdateOperationsInput | number
    endingCash?: FloatFieldUpdateOperationsInput | number
    salesRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    otherRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    payrollExpenses?: FloatFieldUpdateOperationsInput | number
    rentExpenses?: FloatFieldUpdateOperationsInput | number
    utilitiesExpenses?: FloatFieldUpdateOperationsInput | number
    marketingExpenses?: FloatFieldUpdateOperationsInput | number
    suppliesExpenses?: FloatFieldUpdateOperationsInput | number
    maintenanceExpenses?: FloatFieldUpdateOperationsInput | number
    insuranceExpenses?: FloatFieldUpdateOperationsInput | number
    professionalFees?: FloatFieldUpdateOperationsInput | number
    otherOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    totalOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    capitalExpenses?: FloatFieldUpdateOperationsInput | number
    loanPayments?: FloatFieldUpdateOperationsInput | number
    taxPayments?: FloatFieldUpdateOperationsInput | number
    dividendPayments?: FloatFieldUpdateOperationsInput | number
    otherNonOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    netCashFlow?: FloatFieldUpdateOperationsInput | number
    operatingCashFlow?: FloatFieldUpdateOperationsInput | number
    financingCashFlow?: FloatFieldUpdateOperationsInput | number
    investingCashFlow?: FloatFieldUpdateOperationsInput | number
    cashCoverageRatio?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    currentRatio?: FloatFieldUpdateOperationsInput | number
    debtServiceCoverageRatio?: FloatFieldUpdateOperationsInput | number
    accountsReceivable?: FloatFieldUpdateOperationsInput | number
    accountsPayable?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    prepaidExpenses?: FloatFieldUpdateOperationsInput | number
    accruedLiabilities?: FloatFieldUpdateOperationsInput | number
    daysOfCashOnHand?: FloatFieldUpdateOperationsInput | number
    burnRate?: FloatFieldUpdateOperationsInput | number
    runwayMonths?: FloatFieldUpdateOperationsInput | number
    isActual?: BoolFieldUpdateOperationsInput | boolean
    isForecast?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    dataSource?: StringFieldUpdateOperationsInput | string
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnterpriseCashCoverageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: DateTimeFieldUpdateOperationsInput | Date | string
    startingCash?: FloatFieldUpdateOperationsInput | number
    endingCash?: FloatFieldUpdateOperationsInput | number
    salesRevenue?: FloatFieldUpdateOperationsInput | number
    subscriptionRevenue?: FloatFieldUpdateOperationsInput | number
    serviceRevenue?: FloatFieldUpdateOperationsInput | number
    otherRevenue?: FloatFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    payrollExpenses?: FloatFieldUpdateOperationsInput | number
    rentExpenses?: FloatFieldUpdateOperationsInput | number
    utilitiesExpenses?: FloatFieldUpdateOperationsInput | number
    marketingExpenses?: FloatFieldUpdateOperationsInput | number
    suppliesExpenses?: FloatFieldUpdateOperationsInput | number
    maintenanceExpenses?: FloatFieldUpdateOperationsInput | number
    insuranceExpenses?: FloatFieldUpdateOperationsInput | number
    professionalFees?: FloatFieldUpdateOperationsInput | number
    otherOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    totalOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    capitalExpenses?: FloatFieldUpdateOperationsInput | number
    loanPayments?: FloatFieldUpdateOperationsInput | number
    taxPayments?: FloatFieldUpdateOperationsInput | number
    dividendPayments?: FloatFieldUpdateOperationsInput | number
    otherNonOperatingExpenses?: FloatFieldUpdateOperationsInput | number
    netCashFlow?: FloatFieldUpdateOperationsInput | number
    operatingCashFlow?: FloatFieldUpdateOperationsInput | number
    financingCashFlow?: FloatFieldUpdateOperationsInput | number
    investingCashFlow?: FloatFieldUpdateOperationsInput | number
    cashCoverageRatio?: FloatFieldUpdateOperationsInput | number
    quickRatio?: FloatFieldUpdateOperationsInput | number
    currentRatio?: FloatFieldUpdateOperationsInput | number
    debtServiceCoverageRatio?: FloatFieldUpdateOperationsInput | number
    accountsReceivable?: FloatFieldUpdateOperationsInput | number
    accountsPayable?: FloatFieldUpdateOperationsInput | number
    inventory?: FloatFieldUpdateOperationsInput | number
    prepaidExpenses?: FloatFieldUpdateOperationsInput | number
    accruedLiabilities?: FloatFieldUpdateOperationsInput | number
    daysOfCashOnHand?: FloatFieldUpdateOperationsInput | number
    burnRate?: FloatFieldUpdateOperationsInput | number
    runwayMonths?: FloatFieldUpdateOperationsInput | number
    isActual?: BoolFieldUpdateOperationsInput | boolean
    isForecast?: BoolFieldUpdateOperationsInput | boolean
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    dataSource?: StringFieldUpdateOperationsInput | string
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroAccountCreateInput = {
    id?: string
    xeroId: string
    code?: string | null
    name: string
    type: string
    bankAccountNumber?: string | null
    status: string
    description?: string | null
    class?: string | null
    systemAccount?: string | null
    enablePaymentsToAccount?: boolean
    showInExpenseClaims?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroAccountUncheckedCreateInput = {
    id?: string
    xeroId: string
    code?: string | null
    name: string
    type: string
    bankAccountNumber?: string | null
    status: string
    description?: string | null
    class?: string | null
    systemAccount?: string | null
    enablePaymentsToAccount?: boolean
    showInExpenseClaims?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    systemAccount?: NullableStringFieldUpdateOperationsInput | string | null
    enablePaymentsToAccount?: BoolFieldUpdateOperationsInput | boolean
    showInExpenseClaims?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    systemAccount?: NullableStringFieldUpdateOperationsInput | string | null
    enablePaymentsToAccount?: BoolFieldUpdateOperationsInput | boolean
    showInExpenseClaims?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroAccountCreateManyInput = {
    id?: string
    xeroId: string
    code?: string | null
    name: string
    type: string
    bankAccountNumber?: string | null
    status: string
    description?: string | null
    class?: string | null
    systemAccount?: string | null
    enablePaymentsToAccount?: boolean
    showInExpenseClaims?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    systemAccount?: NullableStringFieldUpdateOperationsInput | string | null
    enablePaymentsToAccount?: BoolFieldUpdateOperationsInput | boolean
    showInExpenseClaims?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bankAccountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    class?: NullableStringFieldUpdateOperationsInput | string | null
    systemAccount?: NullableStringFieldUpdateOperationsInput | string | null
    enablePaymentsToAccount?: BoolFieldUpdateOperationsInput | boolean
    showInExpenseClaims?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroContactCreateInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: XeroInvoiceCreateNestedManyWithoutContactInput
    bills?: XeroBillCreateNestedManyWithoutContactInput
    payments?: XeroPaymentCreateNestedManyWithoutContactInput
  }

  export type XeroContactUncheckedCreateInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: XeroInvoiceUncheckedCreateNestedManyWithoutContactInput
    bills?: XeroBillUncheckedCreateNestedManyWithoutContactInput
    payments?: XeroPaymentUncheckedCreateNestedManyWithoutContactInput
  }

  export type XeroContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: XeroInvoiceUpdateManyWithoutContactNestedInput
    bills?: XeroBillUpdateManyWithoutContactNestedInput
    payments?: XeroPaymentUpdateManyWithoutContactNestedInput
  }

  export type XeroContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: XeroInvoiceUncheckedUpdateManyWithoutContactNestedInput
    bills?: XeroBillUncheckedUpdateManyWithoutContactNestedInput
    payments?: XeroPaymentUncheckedUpdateManyWithoutContactNestedInput
  }

  export type XeroContactCreateManyInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroInvoiceCreateInput = {
    id?: string
    xeroId: string
    invoiceNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: XeroContactCreateNestedOneWithoutInvoicesInput
    payments?: XeroPaymentCreateNestedManyWithoutInvoiceInput
  }

  export type XeroInvoiceUncheckedCreateInput = {
    id?: string
    xeroId: string
    invoiceNumber?: string | null
    reference?: string | null
    type: string
    contactId: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: XeroPaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type XeroInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: XeroContactUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: XeroPaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type XeroInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: XeroPaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type XeroInvoiceCreateManyInput = {
    id?: string
    xeroId: string
    invoiceNumber?: string | null
    reference?: string | null
    type: string
    contactId: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroBillCreateInput = {
    id?: string
    xeroId: string
    billNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: XeroContactCreateNestedOneWithoutBillsInput
    payments?: XeroPaymentCreateNestedManyWithoutBillInput
  }

  export type XeroBillUncheckedCreateInput = {
    id?: string
    xeroId: string
    billNumber?: string | null
    reference?: string | null
    type: string
    contactId: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: XeroPaymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type XeroBillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: XeroContactUpdateOneRequiredWithoutBillsNestedInput
    payments?: XeroPaymentUpdateManyWithoutBillNestedInput
  }

  export type XeroBillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: XeroPaymentUncheckedUpdateManyWithoutBillNestedInput
  }

  export type XeroBillCreateManyInput = {
    id?: string
    xeroId: string
    billNumber?: string | null
    reference?: string | null
    type: string
    contactId: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroBillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroBillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentCreateInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: XeroContactCreateNestedOneWithoutPaymentsInput
    invoice?: XeroInvoiceCreateNestedOneWithoutPaymentsInput
    bill?: XeroBillCreateNestedOneWithoutPaymentsInput
  }

  export type XeroPaymentUncheckedCreateInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    contactId?: string | null
    invoiceId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: XeroContactUpdateOneWithoutPaymentsNestedInput
    invoice?: XeroInvoiceUpdateOneWithoutPaymentsNestedInput
    bill?: XeroBillUpdateOneWithoutPaymentsNestedInput
  }

  export type XeroPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentCreateManyInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    contactId?: string | null
    invoiceId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroBankTransactionCreateInput = {
    id?: string
    xeroId: string
    bankAccountId?: string | null
    type: string
    date?: Date | string | null
    reference?: string | null
    amount?: number | null
    currencyCode?: string
    status?: string | null
    isReconciled?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroBankTransactionUncheckedCreateInput = {
    id?: string
    xeroId: string
    bankAccountId?: string | null
    type: string
    date?: Date | string | null
    reference?: string | null
    amount?: number | null
    currencyCode?: string
    status?: string | null
    isReconciled?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroBankTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroBankTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroBankTransactionCreateManyInput = {
    id?: string
    xeroId: string
    bankAccountId?: string | null
    type: string
    date?: Date | string | null
    reference?: string | null
    amount?: number | null
    currencyCode?: string
    status?: string | null
    isReconciled?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroBankTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroBankTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroItemCreateInput = {
    id?: string
    xeroId: string
    code?: string | null
    name: string
    description?: string | null
    salesDetails?: NullableJsonNullValueInput | InputJsonValue
    purchaseDetails?: NullableJsonNullValueInput | InputJsonValue
    isTrackedAsInventory?: boolean
    isSold?: boolean
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroItemUncheckedCreateInput = {
    id?: string
    xeroId: string
    code?: string | null
    name: string
    description?: string | null
    salesDetails?: NullableJsonNullValueInput | InputJsonValue
    purchaseDetails?: NullableJsonNullValueInput | InputJsonValue
    isTrackedAsInventory?: boolean
    isSold?: boolean
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salesDetails?: NullableJsonNullValueInput | InputJsonValue
    purchaseDetails?: NullableJsonNullValueInput | InputJsonValue
    isTrackedAsInventory?: BoolFieldUpdateOperationsInput | boolean
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salesDetails?: NullableJsonNullValueInput | InputJsonValue
    purchaseDetails?: NullableJsonNullValueInput | InputJsonValue
    isTrackedAsInventory?: BoolFieldUpdateOperationsInput | boolean
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroItemCreateManyInput = {
    id?: string
    xeroId: string
    code?: string | null
    name: string
    description?: string | null
    salesDetails?: NullableJsonNullValueInput | InputJsonValue
    purchaseDetails?: NullableJsonNullValueInput | InputJsonValue
    isTrackedAsInventory?: boolean
    isSold?: boolean
    isPurchased?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salesDetails?: NullableJsonNullValueInput | InputJsonValue
    purchaseDetails?: NullableJsonNullValueInput | InputJsonValue
    isTrackedAsInventory?: BoolFieldUpdateOperationsInput | boolean
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salesDetails?: NullableJsonNullValueInput | InputJsonValue
    purchaseDetails?: NullableJsonNullValueInput | InputJsonValue
    isTrackedAsInventory?: BoolFieldUpdateOperationsInput | boolean
    isSold?: BoolFieldUpdateOperationsInput | boolean
    isPurchased?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderCreateInput = {
    id?: string
    amazonOrderId: string
    marketplace: string
    orderStatus: string
    fulfillmentChannel?: string | null
    salesChannel?: string | null
    orderType?: string | null
    purchaseDate?: Date | string | null
    lastUpdateDate?: Date | string | null
    orderTotal?: number | null
    currency?: string
    numberOfItemsShipped?: number
    numberOfItemsUnshipped?: number
    buyerEmail?: string | null
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: AmazonOrderItemCreateNestedManyWithoutOrderInput
  }

  export type AmazonOrderUncheckedCreateInput = {
    id?: string
    amazonOrderId: string
    marketplace: string
    orderStatus: string
    fulfillmentChannel?: string | null
    salesChannel?: string | null
    orderType?: string | null
    purchaseDate?: Date | string | null
    lastUpdateDate?: Date | string | null
    orderTotal?: number | null
    currency?: string
    numberOfItemsShipped?: number
    numberOfItemsUnshipped?: number
    buyerEmail?: string | null
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: AmazonOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type AmazonOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amazonOrderId?: StringFieldUpdateOperationsInput | string
    marketplace?: StringFieldUpdateOperationsInput | string
    orderStatus?: StringFieldUpdateOperationsInput | string
    fulfillmentChannel?: NullableStringFieldUpdateOperationsInput | string | null
    salesChannel?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    numberOfItemsShipped?: IntFieldUpdateOperationsInput | number
    numberOfItemsUnshipped?: IntFieldUpdateOperationsInput | number
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessOrder?: BoolFieldUpdateOperationsInput | boolean
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    isGlobalExpressEnabled?: BoolFieldUpdateOperationsInput | boolean
    isReplacementOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: AmazonOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type AmazonOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amazonOrderId?: StringFieldUpdateOperationsInput | string
    marketplace?: StringFieldUpdateOperationsInput | string
    orderStatus?: StringFieldUpdateOperationsInput | string
    fulfillmentChannel?: NullableStringFieldUpdateOperationsInput | string | null
    salesChannel?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    numberOfItemsShipped?: IntFieldUpdateOperationsInput | number
    numberOfItemsUnshipped?: IntFieldUpdateOperationsInput | number
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessOrder?: BoolFieldUpdateOperationsInput | boolean
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    isGlobalExpressEnabled?: BoolFieldUpdateOperationsInput | boolean
    isReplacementOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: AmazonOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AmazonOrderCreateManyInput = {
    id?: string
    amazonOrderId: string
    marketplace: string
    orderStatus: string
    fulfillmentChannel?: string | null
    salesChannel?: string | null
    orderType?: string | null
    purchaseDate?: Date | string | null
    lastUpdateDate?: Date | string | null
    orderTotal?: number | null
    currency?: string
    numberOfItemsShipped?: number
    numberOfItemsUnshipped?: number
    buyerEmail?: string | null
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amazonOrderId?: StringFieldUpdateOperationsInput | string
    marketplace?: StringFieldUpdateOperationsInput | string
    orderStatus?: StringFieldUpdateOperationsInput | string
    fulfillmentChannel?: NullableStringFieldUpdateOperationsInput | string | null
    salesChannel?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    numberOfItemsShipped?: IntFieldUpdateOperationsInput | number
    numberOfItemsUnshipped?: IntFieldUpdateOperationsInput | number
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessOrder?: BoolFieldUpdateOperationsInput | boolean
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    isGlobalExpressEnabled?: BoolFieldUpdateOperationsInput | boolean
    isReplacementOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amazonOrderId?: StringFieldUpdateOperationsInput | string
    marketplace?: StringFieldUpdateOperationsInput | string
    orderStatus?: StringFieldUpdateOperationsInput | string
    fulfillmentChannel?: NullableStringFieldUpdateOperationsInput | string | null
    salesChannel?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    numberOfItemsShipped?: IntFieldUpdateOperationsInput | number
    numberOfItemsUnshipped?: IntFieldUpdateOperationsInput | number
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessOrder?: BoolFieldUpdateOperationsInput | boolean
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    isGlobalExpressEnabled?: BoolFieldUpdateOperationsInput | boolean
    isReplacementOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderItemCreateInput = {
    id?: string
    orderItemId: string
    asin: string
    sellerSKU?: string | null
    title?: string | null
    quantityOrdered: number
    quantityShipped?: number
    itemPrice?: number | null
    itemTax?: number | null
    shippingPrice?: number | null
    shippingTax?: number | null
    giftWrapPrice?: number | null
    giftWrapTax?: number | null
    itemPromotionDiscount?: number | null
    shipPromotionDiscount?: number | null
    currency?: string
    conditionNote?: string | null
    conditionId?: string | null
    conditionSubtypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: AmazonOrderCreateNestedOneWithoutOrderItemsInput
  }

  export type AmazonOrderItemUncheckedCreateInput = {
    id?: string
    orderItemId: string
    amazonOrderId: string
    asin: string
    sellerSKU?: string | null
    title?: string | null
    quantityOrdered: number
    quantityShipped?: number
    itemPrice?: number | null
    itemTax?: number | null
    shippingPrice?: number | null
    shippingTax?: number | null
    giftWrapPrice?: number | null
    giftWrapTax?: number | null
    itemPromotionDiscount?: number | null
    shipPromotionDiscount?: number | null
    currency?: string
    conditionNote?: string | null
    conditionId?: string | null
    conditionSubtypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    asin?: StringFieldUpdateOperationsInput | string
    sellerSKU?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityShipped?: IntFieldUpdateOperationsInput | number
    itemPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    itemTax?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingTax?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapTax?: NullableFloatFieldUpdateOperationsInput | number | null
    itemPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    shipPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    conditionNote?: NullableStringFieldUpdateOperationsInput | string | null
    conditionId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionSubtypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: AmazonOrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type AmazonOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    amazonOrderId?: StringFieldUpdateOperationsInput | string
    asin?: StringFieldUpdateOperationsInput | string
    sellerSKU?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityShipped?: IntFieldUpdateOperationsInput | number
    itemPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    itemTax?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingTax?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapTax?: NullableFloatFieldUpdateOperationsInput | number | null
    itemPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    shipPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    conditionNote?: NullableStringFieldUpdateOperationsInput | string | null
    conditionId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionSubtypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderItemCreateManyInput = {
    id?: string
    orderItemId: string
    amazonOrderId: string
    asin: string
    sellerSKU?: string | null
    title?: string | null
    quantityOrdered: number
    quantityShipped?: number
    itemPrice?: number | null
    itemTax?: number | null
    shippingPrice?: number | null
    shippingTax?: number | null
    giftWrapPrice?: number | null
    giftWrapTax?: number | null
    itemPromotionDiscount?: number | null
    shipPromotionDiscount?: number | null
    currency?: string
    conditionNote?: string | null
    conditionId?: string | null
    conditionSubtypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    asin?: StringFieldUpdateOperationsInput | string
    sellerSKU?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityShipped?: IntFieldUpdateOperationsInput | number
    itemPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    itemTax?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingTax?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapTax?: NullableFloatFieldUpdateOperationsInput | number | null
    itemPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    shipPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    conditionNote?: NullableStringFieldUpdateOperationsInput | string | null
    conditionId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionSubtypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    amazonOrderId?: StringFieldUpdateOperationsInput | string
    asin?: StringFieldUpdateOperationsInput | string
    sellerSKU?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityShipped?: IntFieldUpdateOperationsInput | number
    itemPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    itemTax?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingTax?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapTax?: NullableFloatFieldUpdateOperationsInput | number | null
    itemPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    shipPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    conditionNote?: NullableStringFieldUpdateOperationsInput | string | null
    conditionId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionSubtypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonInventoryCreateInput = {
    id?: string
    sellerSKU: string
    asin?: string | null
    fnSKU?: string | null
    productName?: string | null
    condition?: string | null
    totalQuantity?: number
    inStockQuantity?: number
    availableQuantity?: number
    fulfillableQuantity?: number
    inboundWorkingQuantity?: number
    inboundShippedQuantity?: number
    inboundReceivingQuantity?: number
    reservedQuantity?: number
    unfulfillableQuantity?: number
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonInventoryUncheckedCreateInput = {
    id?: string
    sellerSKU: string
    asin?: string | null
    fnSKU?: string | null
    productName?: string | null
    condition?: string | null
    totalQuantity?: number
    inStockQuantity?: number
    availableQuantity?: number
    fulfillableQuantity?: number
    inboundWorkingQuantity?: number
    inboundShippedQuantity?: number
    inboundReceivingQuantity?: number
    reservedQuantity?: number
    unfulfillableQuantity?: number
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonInventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerSKU?: StringFieldUpdateOperationsInput | string
    asin?: NullableStringFieldUpdateOperationsInput | string | null
    fnSKU?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    inStockQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    fulfillableQuantity?: IntFieldUpdateOperationsInput | number
    inboundWorkingQuantity?: IntFieldUpdateOperationsInput | number
    inboundShippedQuantity?: IntFieldUpdateOperationsInput | number
    inboundReceivingQuantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    unfulfillableQuantity?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonInventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerSKU?: StringFieldUpdateOperationsInput | string
    asin?: NullableStringFieldUpdateOperationsInput | string | null
    fnSKU?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    inStockQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    fulfillableQuantity?: IntFieldUpdateOperationsInput | number
    inboundWorkingQuantity?: IntFieldUpdateOperationsInput | number
    inboundShippedQuantity?: IntFieldUpdateOperationsInput | number
    inboundReceivingQuantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    unfulfillableQuantity?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonInventoryCreateManyInput = {
    id?: string
    sellerSKU: string
    asin?: string | null
    fnSKU?: string | null
    productName?: string | null
    condition?: string | null
    totalQuantity?: number
    inStockQuantity?: number
    availableQuantity?: number
    fulfillableQuantity?: number
    inboundWorkingQuantity?: number
    inboundShippedQuantity?: number
    inboundReceivingQuantity?: number
    reservedQuantity?: number
    unfulfillableQuantity?: number
    lastUpdated?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonInventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerSKU?: StringFieldUpdateOperationsInput | string
    asin?: NullableStringFieldUpdateOperationsInput | string | null
    fnSKU?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    inStockQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    fulfillableQuantity?: IntFieldUpdateOperationsInput | number
    inboundWorkingQuantity?: IntFieldUpdateOperationsInput | number
    inboundShippedQuantity?: IntFieldUpdateOperationsInput | number
    inboundReceivingQuantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    unfulfillableQuantity?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonInventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerSKU?: StringFieldUpdateOperationsInput | string
    asin?: NullableStringFieldUpdateOperationsInput | string | null
    fnSKU?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    inStockQuantity?: IntFieldUpdateOperationsInput | number
    availableQuantity?: IntFieldUpdateOperationsInput | number
    fulfillableQuantity?: IntFieldUpdateOperationsInput | number
    inboundWorkingQuantity?: IntFieldUpdateOperationsInput | number
    inboundShippedQuantity?: IntFieldUpdateOperationsInput | number
    inboundReceivingQuantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    unfulfillableQuantity?: IntFieldUpdateOperationsInput | number
    lastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyOrderCreateInput = {
    id?: string
    shopifyOrderId: string
    orderNumber?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    financialStatus?: string | null
    fulfillmentStatus?: string | null
    tags?: string | null
    totalPrice?: number | null
    totalTax?: number | null
    totalDiscounts?: number | null
    totalWeight?: number | null
    currency?: string
    processedAt?: Date | string | null
    closedAt?: Date | string | null
    cancelledAt?: Date | string | null
    test?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: ShopifyLineItemCreateNestedManyWithoutOrderInput
  }

  export type ShopifyOrderUncheckedCreateInput = {
    id?: string
    shopifyOrderId: string
    orderNumber?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    financialStatus?: string | null
    fulfillmentStatus?: string | null
    tags?: string | null
    totalPrice?: number | null
    totalTax?: number | null
    totalDiscounts?: number | null
    totalWeight?: number | null
    currency?: string
    processedAt?: Date | string | null
    closedAt?: Date | string | null
    cancelledAt?: Date | string | null
    test?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: ShopifyLineItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ShopifyOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscounts?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: ShopifyLineItemUpdateManyWithoutOrderNestedInput
  }

  export type ShopifyOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscounts?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: ShopifyLineItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ShopifyOrderCreateManyInput = {
    id?: string
    shopifyOrderId: string
    orderNumber?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    financialStatus?: string | null
    fulfillmentStatus?: string | null
    tags?: string | null
    totalPrice?: number | null
    totalTax?: number | null
    totalDiscounts?: number | null
    totalWeight?: number | null
    currency?: string
    processedAt?: Date | string | null
    closedAt?: Date | string | null
    cancelledAt?: Date | string | null
    test?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscounts?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscounts?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyLineItemCreateInput = {
    id?: string
    lineItemId: string
    productId?: string | null
    variantId?: string | null
    title?: string | null
    variantTitle?: string | null
    sku?: string | null
    vendor?: string | null
    quantity: number
    price?: number | null
    totalDiscount?: number | null
    grams?: number | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    fulfillmentStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: ShopifyOrderCreateNestedOneWithoutLineItemsInput
  }

  export type ShopifyLineItemUncheckedCreateInput = {
    id?: string
    lineItemId: string
    shopifyOrderId: string
    productId?: string | null
    variantId?: string | null
    title?: string | null
    variantTitle?: string | null
    sku?: string | null
    vendor?: string | null
    quantity: number
    price?: number | null
    totalDiscount?: number | null
    grams?: number | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    fulfillmentStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyLineItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineItemId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    variantTitle?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: ShopifyOrderUpdateOneRequiredWithoutLineItemsNestedInput
  }

  export type ShopifyLineItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineItemId?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    variantTitle?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyLineItemCreateManyInput = {
    id?: string
    lineItemId: string
    shopifyOrderId: string
    productId?: string | null
    variantId?: string | null
    title?: string | null
    variantTitle?: string | null
    sku?: string | null
    vendor?: string | null
    quantity: number
    price?: number | null
    totalDiscount?: number | null
    grams?: number | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    fulfillmentStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyLineItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineItemId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    variantTitle?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyLineItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineItemId?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    variantTitle?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyProductCreateInput = {
    id?: string
    shopifyProductId: string
    title: string
    handle?: string | null
    vendor?: string | null
    productType?: string | null
    tags?: string | null
    status?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ShopifyVariantCreateNestedManyWithoutProductInput
  }

  export type ShopifyProductUncheckedCreateInput = {
    id?: string
    shopifyProductId: string
    title: string
    handle?: string | null
    vendor?: string | null
    productType?: string | null
    tags?: string | null
    status?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ShopifyVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ShopifyProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyProductId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ShopifyVariantUpdateManyWithoutProductNestedInput
  }

  export type ShopifyProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyProductId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ShopifyVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ShopifyProductCreateManyInput = {
    id?: string
    shopifyProductId: string
    title: string
    handle?: string | null
    vendor?: string | null
    productType?: string | null
    tags?: string | null
    status?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyProductId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyProductId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyVariantCreateInput = {
    id?: string
    shopifyVariantId: string
    title?: string | null
    price?: number | null
    compareAtPrice?: number | null
    sku?: string | null
    barcode?: string | null
    grams?: number | null
    weight?: number | null
    weightUnit?: string | null
    inventoryQuantity?: number
    inventoryPolicy?: string | null
    inventoryTracking?: string | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ShopifyProductCreateNestedOneWithoutVariantsInput
  }

  export type ShopifyVariantUncheckedCreateInput = {
    id?: string
    shopifyVariantId: string
    shopifyProductId: string
    title?: string | null
    price?: number | null
    compareAtPrice?: number | null
    sku?: string | null
    barcode?: string | null
    grams?: number | null
    weight?: number | null
    weightUnit?: string | null
    inventoryQuantity?: number
    inventoryPolicy?: string | null
    inventoryTracking?: string | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyVariantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryQuantity?: IntFieldUpdateOperationsInput | number
    inventoryPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryTracking?: NullableStringFieldUpdateOperationsInput | string | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ShopifyProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type ShopifyVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyVariantId?: StringFieldUpdateOperationsInput | string
    shopifyProductId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryQuantity?: IntFieldUpdateOperationsInput | number
    inventoryPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryTracking?: NullableStringFieldUpdateOperationsInput | string | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyVariantCreateManyInput = {
    id?: string
    shopifyVariantId: string
    shopifyProductId: string
    title?: string | null
    price?: number | null
    compareAtPrice?: number | null
    sku?: string | null
    barcode?: string | null
    grams?: number | null
    weight?: number | null
    weightUnit?: string | null
    inventoryQuantity?: number
    inventoryPolicy?: string | null
    inventoryTracking?: string | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyVariantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryQuantity?: IntFieldUpdateOperationsInput | number
    inventoryPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryTracking?: NullableStringFieldUpdateOperationsInput | string | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyVariantId?: StringFieldUpdateOperationsInput | string
    shopifyProductId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryQuantity?: IntFieldUpdateOperationsInput | number
    inventoryPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryTracking?: NullableStringFieldUpdateOperationsInput | string | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sensors?: MachineSensorCreateNestedManyWithoutMachineInput
    alerts?: MachineAlertCreateNestedManyWithoutMachineInput
    maintenanceRecords?: MachineMaintenanceRecordCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sensors?: MachineSensorUncheckedCreateNestedManyWithoutMachineInput
    alerts?: MachineAlertUncheckedCreateNestedManyWithoutMachineInput
    maintenanceRecords?: MachineMaintenanceRecordUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sensors?: MachineSensorUpdateManyWithoutMachineNestedInput
    alerts?: MachineAlertUpdateManyWithoutMachineNestedInput
    maintenanceRecords?: MachineMaintenanceRecordUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sensors?: MachineSensorUncheckedUpdateManyWithoutMachineNestedInput
    alerts?: MachineAlertUncheckedUpdateManyWithoutMachineNestedInput
    maintenanceRecords?: MachineMaintenanceRecordUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type MachineCreateManyInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSensorCreateInput = {
    id?: string
    sensorType: string
    sensorName: string
    value: number
    unit?: string | null
    threshold?: number | null
    minValue?: number | null
    maxValue?: number | null
    status?: string
    timestamp?: Date | string
    createdAt?: Date | string
    machine: MachineCreateNestedOneWithoutSensorsInput
  }

  export type MachineSensorUncheckedCreateInput = {
    id?: string
    machineId: string
    sensorType: string
    sensorName: string
    value: number
    unit?: string | null
    threshold?: number | null
    minValue?: number | null
    maxValue?: number | null
    status?: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type MachineSensorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sensorType?: StringFieldUpdateOperationsInput | string
    sensorName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: MachineUpdateOneRequiredWithoutSensorsNestedInput
  }

  export type MachineSensorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    sensorType?: StringFieldUpdateOperationsInput | string
    sensorName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSensorCreateManyInput = {
    id?: string
    machineId: string
    sensorType: string
    sensorName: string
    value: number
    unit?: string | null
    threshold?: number | null
    minValue?: number | null
    maxValue?: number | null
    status?: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type MachineSensorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sensorType?: StringFieldUpdateOperationsInput | string
    sensorName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSensorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    sensorType?: StringFieldUpdateOperationsInput | string
    sensorName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineAlertCreateInput = {
    id?: string
    severity: string
    type: string
    title: string
    description?: string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    machine: MachineCreateNestedOneWithoutAlertsInput
  }

  export type MachineAlertUncheckedCreateInput = {
    id?: string
    machineId: string
    severity: string
    type: string
    title: string
    description?: string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MachineAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: MachineUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type MachineAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineAlertCreateManyInput = {
    id?: string
    machineId: string
    severity: string
    type: string
    title: string
    description?: string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MachineAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMaintenanceRecordCreateInput = {
    id?: string
    type: string
    description: string
    performedBy?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    cost?: number | null
    status?: string
    notes?: string | null
    attachments?: MachineMaintenanceRecordCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    machine: MachineCreateNestedOneWithoutMaintenanceRecordsInput
  }

  export type MachineMaintenanceRecordUncheckedCreateInput = {
    id?: string
    machineId: string
    type: string
    description: string
    performedBy?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    cost?: number | null
    status?: string
    notes?: string | null
    attachments?: MachineMaintenanceRecordCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineMaintenanceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: MachineMaintenanceRecordUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: MachineUpdateOneRequiredWithoutMaintenanceRecordsNestedInput
  }

  export type MachineMaintenanceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: MachineMaintenanceRecordUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMaintenanceRecordCreateManyInput = {
    id?: string
    machineId: string
    type: string
    description: string
    performedBy?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    cost?: number | null
    status?: string
    notes?: string | null
    attachments?: MachineMaintenanceRecordCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineMaintenanceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: MachineMaintenanceRecordUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMaintenanceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: MachineMaintenanceRecordUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityCheckCreateInput = {
    id?: string
    checkType: string
    checkDate?: Date | string
    inspector?: string | null
    passed: boolean
    score?: number | null
    defectCount?: number
    sampleSize?: number | null
    notes?: string | null
    corrective?: string | null
    attachments?: QualityCheckCreateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    production?: ProductionCreateNestedOneWithoutQualityChecksInput
  }

  export type QualityCheckUncheckedCreateInput = {
    id?: string
    productionId?: string | null
    checkType: string
    checkDate?: Date | string
    inspector?: string | null
    passed: boolean
    score?: number | null
    defectCount?: number
    sampleSize?: number | null
    notes?: string | null
    corrective?: string | null
    attachments?: QualityCheckCreateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QualityCheckUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    checkDate?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    defectCount?: IntFieldUpdateOperationsInput | number
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    corrective?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: QualityCheckUpdateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    production?: ProductionUpdateOneWithoutQualityChecksNestedInput
  }

  export type QualityCheckUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productionId?: NullableStringFieldUpdateOperationsInput | string | null
    checkType?: StringFieldUpdateOperationsInput | string
    checkDate?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    defectCount?: IntFieldUpdateOperationsInput | number
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    corrective?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: QualityCheckUpdateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityCheckCreateManyInput = {
    id?: string
    productionId?: string | null
    checkType: string
    checkDate?: Date | string
    inspector?: string | null
    passed: boolean
    score?: number | null
    defectCount?: number
    sampleSize?: number | null
    notes?: string | null
    corrective?: string | null
    attachments?: QualityCheckCreateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QualityCheckUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    checkDate?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    defectCount?: IntFieldUpdateOperationsInput | number
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    corrective?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: QualityCheckUpdateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityCheckUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productionId?: NullableStringFieldUpdateOperationsInput | string | null
    checkType?: StringFieldUpdateOperationsInput | string
    checkDate?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    defectCount?: IntFieldUpdateOperationsInput | number
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    corrective?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: QualityCheckUpdateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOrderCreateInput = {
    id?: string
    orderNumber: string
    productSKU: string
    quantity: number
    priority?: $Enums.Priority
    status?: $Enums.ProductionStatus
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    assignedMachine?: string | null
    assignedOperator?: string | null
    batchNumber?: string | null
    qualityGrade?: string | null
    yield?: number | null
    efficiency?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    productSKU: string
    quantity: number
    priority?: $Enums.Priority
    status?: $Enums.ProductionStatus
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    assignedMachine?: string | null
    assignedOperator?: string | null
    batchNumber?: string | null
    qualityGrade?: string | null
    yield?: number | null
    efficiency?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    productSKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedMachine?: NullableStringFieldUpdateOperationsInput | string | null
    assignedOperator?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    yield?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    productSKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedMachine?: NullableStringFieldUpdateOperationsInput | string | null
    assignedOperator?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    yield?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOrderCreateManyInput = {
    id?: string
    orderNumber: string
    productSKU: string
    quantity: number
    priority?: $Enums.Priority
    status?: $Enums.ProductionStatus
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    assignedMachine?: string | null
    assignedOperator?: string | null
    batchNumber?: string | null
    qualityGrade?: string | null
    yield?: number | null
    efficiency?: number | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    productSKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedMachine?: NullableStringFieldUpdateOperationsInput | string | null
    assignedOperator?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    yield?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    productSKU?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedMachine?: NullableStringFieldUpdateOperationsInput | string | null
    assignedOperator?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    qualityGrade?: NullableStringFieldUpdateOperationsInput | string | null
    yield?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DashboardListRelationFilter = {
    every?: DashboardWhereInput
    some?: DashboardWhereInput
    none?: DashboardWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DashboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type WorkingCapitalCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    cash?: SortOrder
    dso?: SortOrder
    dpo?: SortOrder
    dio?: SortOrder
    cashConversionCycle?: SortOrder
    workingCapitalRatio?: SortOrder
    quickRatio?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkingCapitalAvgOrderByAggregateInput = {
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    cash?: SortOrder
    dso?: SortOrder
    dpo?: SortOrder
    dio?: SortOrder
    cashConversionCycle?: SortOrder
    workingCapitalRatio?: SortOrder
    quickRatio?: SortOrder
  }

  export type WorkingCapitalMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    cash?: SortOrder
    dso?: SortOrder
    dpo?: SortOrder
    dio?: SortOrder
    cashConversionCycle?: SortOrder
    workingCapitalRatio?: SortOrder
    quickRatio?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkingCapitalMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    cash?: SortOrder
    dso?: SortOrder
    dpo?: SortOrder
    dio?: SortOrder
    cashConversionCycle?: SortOrder
    workingCapitalRatio?: SortOrder
    quickRatio?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkingCapitalSumOrderByAggregateInput = {
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    cash?: SortOrder
    dso?: SortOrder
    dpo?: SortOrder
    dio?: SortOrder
    cashConversionCycle?: SortOrder
    workingCapitalRatio?: SortOrder
    quickRatio?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CashRunwayCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    cashBalance?: SortOrder
    monthlyBurnRate?: SortOrder
    monthlyRevenue?: SortOrder
    netBurnRate?: SortOrder
    runwayMonths?: SortOrder
    coverageDay30?: SortOrder
    coverageDay60?: SortOrder
    coverageDay90?: SortOrder
    coverageDay120?: SortOrder
    coverageDay180?: SortOrder
    createdAt?: SortOrder
  }

  export type CashRunwayAvgOrderByAggregateInput = {
    cashBalance?: SortOrder
    monthlyBurnRate?: SortOrder
    monthlyRevenue?: SortOrder
    netBurnRate?: SortOrder
    runwayMonths?: SortOrder
    coverageDay30?: SortOrder
    coverageDay60?: SortOrder
    coverageDay90?: SortOrder
    coverageDay120?: SortOrder
    coverageDay180?: SortOrder
  }

  export type CashRunwayMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    cashBalance?: SortOrder
    monthlyBurnRate?: SortOrder
    monthlyRevenue?: SortOrder
    netBurnRate?: SortOrder
    runwayMonths?: SortOrder
    coverageDay30?: SortOrder
    coverageDay60?: SortOrder
    coverageDay90?: SortOrder
    coverageDay120?: SortOrder
    coverageDay180?: SortOrder
    createdAt?: SortOrder
  }

  export type CashRunwayMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    cashBalance?: SortOrder
    monthlyBurnRate?: SortOrder
    monthlyRevenue?: SortOrder
    netBurnRate?: SortOrder
    runwayMonths?: SortOrder
    coverageDay30?: SortOrder
    coverageDay60?: SortOrder
    coverageDay90?: SortOrder
    coverageDay120?: SortOrder
    coverageDay180?: SortOrder
    createdAt?: SortOrder
  }

  export type CashRunwaySumOrderByAggregateInput = {
    cashBalance?: SortOrder
    monthlyBurnRate?: SortOrder
    monthlyRevenue?: SortOrder
    netBurnRate?: SortOrder
    runwayMonths?: SortOrder
    coverageDay30?: SortOrder
    coverageDay60?: SortOrder
    coverageDay90?: SortOrder
    coverageDay120?: SortOrder
    coverageDay180?: SortOrder
  }

  export type EnumProductionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusFilter<$PrismaModel> | $Enums.ProductionStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type QualityCheckListRelationFilter = {
    every?: QualityCheckWhereInput
    some?: QualityCheckWhereInput
    none?: QualityCheckWhereInput
  }

  export type QualityCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionCountOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    productName?: SortOrder
    productSKU?: SortOrder
    quantity?: SortOrder
    targetQuantity?: SortOrder
    completedQuantity?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completionDate?: SortOrder
    qualityScore?: SortOrder
    defectRate?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    targetQuantity?: SortOrder
    completedQuantity?: SortOrder
    qualityScore?: SortOrder
    defectRate?: SortOrder
    efficiency?: SortOrder
  }

  export type ProductionMaxOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    productName?: SortOrder
    productSKU?: SortOrder
    quantity?: SortOrder
    targetQuantity?: SortOrder
    completedQuantity?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completionDate?: SortOrder
    qualityScore?: SortOrder
    defectRate?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionMinOrderByAggregateInput = {
    id?: SortOrder
    jobNumber?: SortOrder
    productName?: SortOrder
    productSKU?: SortOrder
    quantity?: SortOrder
    targetQuantity?: SortOrder
    completedQuantity?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    targetDate?: SortOrder
    completionDate?: SortOrder
    qualityScore?: SortOrder
    defectRate?: SortOrder
    efficiency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionSumOrderByAggregateInput = {
    quantity?: SortOrder
    targetQuantity?: SortOrder
    completedQuantity?: SortOrder
    qualityScore?: SortOrder
    defectRate?: SortOrder
    efficiency?: SortOrder
  }

  export type EnumProductionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductionStatusFilter<$PrismaModel>
    _max?: NestedEnumProductionStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    location?: SortOrder
    warehouse?: SortOrder
    unitCost?: SortOrder
    totalValue?: SortOrder
    lastMovement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    unitCost?: SortOrder
    totalValue?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    location?: SortOrder
    warehouse?: SortOrder
    unitCost?: SortOrder
    totalValue?: SortOrder
    lastMovement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    location?: SortOrder
    warehouse?: SortOrder
    unitCost?: SortOrder
    totalValue?: SortOrder
    lastMovement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    quantity?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    unitCost?: SortOrder
    totalValue?: SortOrder
  }

  export type EnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type InventoryScalarRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    reason?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    reason?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    reason?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type FloatNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    has?: number | FloatFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListFloatFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListFloatFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AIInsightCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    confidence?: SortOrder
    priority?: SortOrder
    embedding?: SortOrder
    metadata?: SortOrder
    actionable?: SortOrder
    actioned?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightAvgOrderByAggregateInput = {
    confidence?: SortOrder
    embedding?: SortOrder
  }

  export type AIInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    confidence?: SortOrder
    priority?: SortOrder
    actionable?: SortOrder
    actioned?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    confidence?: SortOrder
    priority?: SortOrder
    actionable?: SortOrder
    actioned?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInsightSumOrderByAggregateInput = {
    confidence?: SortOrder
    embedding?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DashboardUix_dashboard_user_nameCompoundUniqueInput = {
    userId: string
    name: string
  }

  export type DashboardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    layout?: SortOrder
    widgets?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    dimension?: SortOrder
    forecast?: SortOrder
    actual?: SortOrder
    variance?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAvgOrderByAggregateInput = {
    value?: SortOrder
    forecast?: SortOrder
    actual?: SortOrder
    variance?: SortOrder
  }

  export type AnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    dimension?: SortOrder
    forecast?: SortOrder
    actual?: SortOrder
    variance?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    metric?: SortOrder
    value?: SortOrder
    dimension?: SortOrder
    forecast?: SortOrder
    actual?: SortOrder
    variance?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSumOrderByAggregateInput = {
    value?: SortOrder
    forecast?: SortOrder
    actual?: SortOrder
    variance?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MCPRequestCountOrderByAggregateInput = {
    id?: SortOrder
    tool?: SortOrder
    request?: SortOrder
    response?: SortOrder
    status?: SortOrder
    processingTime?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type MCPRequestAvgOrderByAggregateInput = {
    processingTime?: SortOrder
  }

  export type MCPRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    tool?: SortOrder
    status?: SortOrder
    processingTime?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type MCPRequestMinOrderByAggregateInput = {
    id?: SortOrder
    tool?: SortOrder
    status?: SortOrder
    processingTime?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type MCPRequestSumOrderByAggregateInput = {
    processingTime?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CashLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    reconciledStatus?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashLedgerAvgOrderByAggregateInput = {
    amount?: SortOrder
    balance?: SortOrder
  }

  export type CashLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    reconciledStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    reconciledStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashLedgerSumOrderByAggregateInput = {
    amount?: SortOrder
    balance?: SortOrder
  }

  export type CashProjectionCountOrderByAggregateInput = {
    id?: SortOrder
    projectionDate?: SortOrder
    projectedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
    confidenceLevel?: SortOrder
    scenarioType?: SortOrder
    assumptions?: SortOrder
    projectionMethod?: SortOrder
    dataSource?: SortOrder
    isAdjusted?: SortOrder
    adjustmentReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashProjectionAvgOrderByAggregateInput = {
    projectedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type CashProjectionMaxOrderByAggregateInput = {
    id?: SortOrder
    projectionDate?: SortOrder
    projectedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
    confidenceLevel?: SortOrder
    scenarioType?: SortOrder
    projectionMethod?: SortOrder
    dataSource?: SortOrder
    isAdjusted?: SortOrder
    adjustmentReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashProjectionMinOrderByAggregateInput = {
    id?: SortOrder
    projectionDate?: SortOrder
    projectedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
    confidenceLevel?: SortOrder
    scenarioType?: SortOrder
    projectionMethod?: SortOrder
    dataSource?: SortOrder
    isAdjusted?: SortOrder
    adjustmentReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashProjectionSumOrderByAggregateInput = {
    projectedAmount?: SortOrder
    actualAmount?: SortOrder
    variance?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    vendor?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    invoiceNumber?: SortOrder
    approvedBy?: SortOrder
    department?: SortOrder
    project?: SortOrder
    isRecurring?: SortOrder
    recurringPeriod?: SortOrder
    taxAmount?: SortOrder
    tags?: SortOrder
    attachments?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
    taxAmount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    vendor?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    invoiceNumber?: SortOrder
    approvedBy?: SortOrder
    department?: SortOrder
    project?: SortOrder
    isRecurring?: SortOrder
    recurringPeriod?: SortOrder
    taxAmount?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    vendor?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    invoiceNumber?: SortOrder
    approvedBy?: SortOrder
    department?: SortOrder
    project?: SortOrder
    isRecurring?: SortOrder
    recurringPeriod?: SortOrder
    taxAmount?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
    taxAmount?: SortOrder
  }

  export type ExecutiveMetricCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    revenueTarget?: SortOrder
    revenueTrend?: SortOrder
    cashFlow?: SortOrder
    cashFlowTarget?: SortOrder
    cashFlowTrend?: SortOrder
    currentRatio?: SortOrder
    currentRatioTarget?: SortOrder
    currentRatioTrend?: SortOrder
    quickRatio?: SortOrder
    quickRatioTarget?: SortOrder
    quickRatioTrend?: SortOrder
    oee?: SortOrder
    oeeTarget?: SortOrder
    oeeTrend?: SortOrder
    throughput?: SortOrder
    throughputTarget?: SortOrder
    throughputTrend?: SortOrder
    marketShare?: SortOrder
    marketShareTarget?: SortOrder
    marketShareTrend?: SortOrder
    customerSatisfaction?: SortOrder
    customerSatisfactionTarget?: SortOrder
    customerSatisfactionTrend?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    daysInventory?: SortOrder
    daysReceivables?: SortOrder
    daysPayables?: SortOrder
    cashUnlock?: SortOrder
    isActual?: SortOrder
    confidence?: SortOrder
    dataSource?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutiveMetricAvgOrderByAggregateInput = {
    revenue?: SortOrder
    revenueTarget?: SortOrder
    revenueTrend?: SortOrder
    cashFlow?: SortOrder
    cashFlowTarget?: SortOrder
    cashFlowTrend?: SortOrder
    currentRatio?: SortOrder
    currentRatioTarget?: SortOrder
    currentRatioTrend?: SortOrder
    quickRatio?: SortOrder
    quickRatioTarget?: SortOrder
    quickRatioTrend?: SortOrder
    oee?: SortOrder
    oeeTarget?: SortOrder
    oeeTrend?: SortOrder
    throughput?: SortOrder
    throughputTarget?: SortOrder
    throughputTrend?: SortOrder
    marketShare?: SortOrder
    marketShareTarget?: SortOrder
    marketShareTrend?: SortOrder
    customerSatisfaction?: SortOrder
    customerSatisfactionTarget?: SortOrder
    customerSatisfactionTrend?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    daysInventory?: SortOrder
    daysReceivables?: SortOrder
    daysPayables?: SortOrder
    cashUnlock?: SortOrder
    confidence?: SortOrder
  }

  export type ExecutiveMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    revenueTarget?: SortOrder
    revenueTrend?: SortOrder
    cashFlow?: SortOrder
    cashFlowTarget?: SortOrder
    cashFlowTrend?: SortOrder
    currentRatio?: SortOrder
    currentRatioTarget?: SortOrder
    currentRatioTrend?: SortOrder
    quickRatio?: SortOrder
    quickRatioTarget?: SortOrder
    quickRatioTrend?: SortOrder
    oee?: SortOrder
    oeeTarget?: SortOrder
    oeeTrend?: SortOrder
    throughput?: SortOrder
    throughputTarget?: SortOrder
    throughputTrend?: SortOrder
    marketShare?: SortOrder
    marketShareTarget?: SortOrder
    marketShareTrend?: SortOrder
    customerSatisfaction?: SortOrder
    customerSatisfactionTarget?: SortOrder
    customerSatisfactionTrend?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    daysInventory?: SortOrder
    daysReceivables?: SortOrder
    daysPayables?: SortOrder
    cashUnlock?: SortOrder
    isActual?: SortOrder
    confidence?: SortOrder
    dataSource?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutiveMetricMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    revenueTarget?: SortOrder
    revenueTrend?: SortOrder
    cashFlow?: SortOrder
    cashFlowTarget?: SortOrder
    cashFlowTrend?: SortOrder
    currentRatio?: SortOrder
    currentRatioTarget?: SortOrder
    currentRatioTrend?: SortOrder
    quickRatio?: SortOrder
    quickRatioTarget?: SortOrder
    quickRatioTrend?: SortOrder
    oee?: SortOrder
    oeeTarget?: SortOrder
    oeeTrend?: SortOrder
    throughput?: SortOrder
    throughputTarget?: SortOrder
    throughputTrend?: SortOrder
    marketShare?: SortOrder
    marketShareTarget?: SortOrder
    marketShareTrend?: SortOrder
    customerSatisfaction?: SortOrder
    customerSatisfactionTarget?: SortOrder
    customerSatisfactionTrend?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    daysInventory?: SortOrder
    daysReceivables?: SortOrder
    daysPayables?: SortOrder
    cashUnlock?: SortOrder
    isActual?: SortOrder
    confidence?: SortOrder
    dataSource?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutiveMetricSumOrderByAggregateInput = {
    revenue?: SortOrder
    revenueTarget?: SortOrder
    revenueTrend?: SortOrder
    cashFlow?: SortOrder
    cashFlowTarget?: SortOrder
    cashFlowTrend?: SortOrder
    currentRatio?: SortOrder
    currentRatioTarget?: SortOrder
    currentRatioTrend?: SortOrder
    quickRatio?: SortOrder
    quickRatioTarget?: SortOrder
    quickRatioTrend?: SortOrder
    oee?: SortOrder
    oeeTarget?: SortOrder
    oeeTrend?: SortOrder
    throughput?: SortOrder
    throughputTarget?: SortOrder
    throughputTrend?: SortOrder
    marketShare?: SortOrder
    marketShareTarget?: SortOrder
    marketShareTrend?: SortOrder
    customerSatisfaction?: SortOrder
    customerSatisfactionTarget?: SortOrder
    customerSatisfactionTrend?: SortOrder
    currentAssets?: SortOrder
    currentLiabilities?: SortOrder
    inventory?: SortOrder
    daysInventory?: SortOrder
    daysReceivables?: SortOrder
    daysPayables?: SortOrder
    cashUnlock?: SortOrder
    confidence?: SortOrder
  }

  export type ExecutiveAlertCountOrderByAggregateInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    impact?: SortOrder
    action?: SortOrder
    source?: SortOrder
    metrics?: SortOrder
    isActive?: SortOrder
    isDismissed?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutiveAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    impact?: SortOrder
    action?: SortOrder
    source?: SortOrder
    isActive?: SortOrder
    isDismissed?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExecutiveAlertMinOrderByAggregateInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    impact?: SortOrder
    action?: SortOrder
    source?: SortOrder
    isActive?: SortOrder
    isDismissed?: SortOrder
    dismissedBy?: SortOrder
    dismissedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnterpriseCashCoverageCountOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    startingCash?: SortOrder
    endingCash?: SortOrder
    salesRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    serviceRevenue?: SortOrder
    otherRevenue?: SortOrder
    totalRevenue?: SortOrder
    payrollExpenses?: SortOrder
    rentExpenses?: SortOrder
    utilitiesExpenses?: SortOrder
    marketingExpenses?: SortOrder
    suppliesExpenses?: SortOrder
    maintenanceExpenses?: SortOrder
    insuranceExpenses?: SortOrder
    professionalFees?: SortOrder
    otherOperatingExpenses?: SortOrder
    totalOperatingExpenses?: SortOrder
    capitalExpenses?: SortOrder
    loanPayments?: SortOrder
    taxPayments?: SortOrder
    dividendPayments?: SortOrder
    otherNonOperatingExpenses?: SortOrder
    netCashFlow?: SortOrder
    operatingCashFlow?: SortOrder
    financingCashFlow?: SortOrder
    investingCashFlow?: SortOrder
    cashCoverageRatio?: SortOrder
    quickRatio?: SortOrder
    currentRatio?: SortOrder
    debtServiceCoverageRatio?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    inventory?: SortOrder
    prepaidExpenses?: SortOrder
    accruedLiabilities?: SortOrder
    daysOfCashOnHand?: SortOrder
    burnRate?: SortOrder
    runwayMonths?: SortOrder
    isActual?: SortOrder
    isForecast?: SortOrder
    confidenceScore?: SortOrder
    dataSource?: SortOrder
    importedFrom?: SortOrder
    notes?: SortOrder
    adjustments?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnterpriseCashCoverageAvgOrderByAggregateInput = {
    startingCash?: SortOrder
    endingCash?: SortOrder
    salesRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    serviceRevenue?: SortOrder
    otherRevenue?: SortOrder
    totalRevenue?: SortOrder
    payrollExpenses?: SortOrder
    rentExpenses?: SortOrder
    utilitiesExpenses?: SortOrder
    marketingExpenses?: SortOrder
    suppliesExpenses?: SortOrder
    maintenanceExpenses?: SortOrder
    insuranceExpenses?: SortOrder
    professionalFees?: SortOrder
    otherOperatingExpenses?: SortOrder
    totalOperatingExpenses?: SortOrder
    capitalExpenses?: SortOrder
    loanPayments?: SortOrder
    taxPayments?: SortOrder
    dividendPayments?: SortOrder
    otherNonOperatingExpenses?: SortOrder
    netCashFlow?: SortOrder
    operatingCashFlow?: SortOrder
    financingCashFlow?: SortOrder
    investingCashFlow?: SortOrder
    cashCoverageRatio?: SortOrder
    quickRatio?: SortOrder
    currentRatio?: SortOrder
    debtServiceCoverageRatio?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    inventory?: SortOrder
    prepaidExpenses?: SortOrder
    accruedLiabilities?: SortOrder
    daysOfCashOnHand?: SortOrder
    burnRate?: SortOrder
    runwayMonths?: SortOrder
    confidenceScore?: SortOrder
  }

  export type EnterpriseCashCoverageMaxOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    startingCash?: SortOrder
    endingCash?: SortOrder
    salesRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    serviceRevenue?: SortOrder
    otherRevenue?: SortOrder
    totalRevenue?: SortOrder
    payrollExpenses?: SortOrder
    rentExpenses?: SortOrder
    utilitiesExpenses?: SortOrder
    marketingExpenses?: SortOrder
    suppliesExpenses?: SortOrder
    maintenanceExpenses?: SortOrder
    insuranceExpenses?: SortOrder
    professionalFees?: SortOrder
    otherOperatingExpenses?: SortOrder
    totalOperatingExpenses?: SortOrder
    capitalExpenses?: SortOrder
    loanPayments?: SortOrder
    taxPayments?: SortOrder
    dividendPayments?: SortOrder
    otherNonOperatingExpenses?: SortOrder
    netCashFlow?: SortOrder
    operatingCashFlow?: SortOrder
    financingCashFlow?: SortOrder
    investingCashFlow?: SortOrder
    cashCoverageRatio?: SortOrder
    quickRatio?: SortOrder
    currentRatio?: SortOrder
    debtServiceCoverageRatio?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    inventory?: SortOrder
    prepaidExpenses?: SortOrder
    accruedLiabilities?: SortOrder
    daysOfCashOnHand?: SortOrder
    burnRate?: SortOrder
    runwayMonths?: SortOrder
    isActual?: SortOrder
    isForecast?: SortOrder
    confidenceScore?: SortOrder
    dataSource?: SortOrder
    importedFrom?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnterpriseCashCoverageMinOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    startingCash?: SortOrder
    endingCash?: SortOrder
    salesRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    serviceRevenue?: SortOrder
    otherRevenue?: SortOrder
    totalRevenue?: SortOrder
    payrollExpenses?: SortOrder
    rentExpenses?: SortOrder
    utilitiesExpenses?: SortOrder
    marketingExpenses?: SortOrder
    suppliesExpenses?: SortOrder
    maintenanceExpenses?: SortOrder
    insuranceExpenses?: SortOrder
    professionalFees?: SortOrder
    otherOperatingExpenses?: SortOrder
    totalOperatingExpenses?: SortOrder
    capitalExpenses?: SortOrder
    loanPayments?: SortOrder
    taxPayments?: SortOrder
    dividendPayments?: SortOrder
    otherNonOperatingExpenses?: SortOrder
    netCashFlow?: SortOrder
    operatingCashFlow?: SortOrder
    financingCashFlow?: SortOrder
    investingCashFlow?: SortOrder
    cashCoverageRatio?: SortOrder
    quickRatio?: SortOrder
    currentRatio?: SortOrder
    debtServiceCoverageRatio?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    inventory?: SortOrder
    prepaidExpenses?: SortOrder
    accruedLiabilities?: SortOrder
    daysOfCashOnHand?: SortOrder
    burnRate?: SortOrder
    runwayMonths?: SortOrder
    isActual?: SortOrder
    isForecast?: SortOrder
    confidenceScore?: SortOrder
    dataSource?: SortOrder
    importedFrom?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnterpriseCashCoverageSumOrderByAggregateInput = {
    startingCash?: SortOrder
    endingCash?: SortOrder
    salesRevenue?: SortOrder
    subscriptionRevenue?: SortOrder
    serviceRevenue?: SortOrder
    otherRevenue?: SortOrder
    totalRevenue?: SortOrder
    payrollExpenses?: SortOrder
    rentExpenses?: SortOrder
    utilitiesExpenses?: SortOrder
    marketingExpenses?: SortOrder
    suppliesExpenses?: SortOrder
    maintenanceExpenses?: SortOrder
    insuranceExpenses?: SortOrder
    professionalFees?: SortOrder
    otherOperatingExpenses?: SortOrder
    totalOperatingExpenses?: SortOrder
    capitalExpenses?: SortOrder
    loanPayments?: SortOrder
    taxPayments?: SortOrder
    dividendPayments?: SortOrder
    otherNonOperatingExpenses?: SortOrder
    netCashFlow?: SortOrder
    operatingCashFlow?: SortOrder
    financingCashFlow?: SortOrder
    investingCashFlow?: SortOrder
    cashCoverageRatio?: SortOrder
    quickRatio?: SortOrder
    currentRatio?: SortOrder
    debtServiceCoverageRatio?: SortOrder
    accountsReceivable?: SortOrder
    accountsPayable?: SortOrder
    inventory?: SortOrder
    prepaidExpenses?: SortOrder
    accruedLiabilities?: SortOrder
    daysOfCashOnHand?: SortOrder
    burnRate?: SortOrder
    runwayMonths?: SortOrder
    confidenceScore?: SortOrder
  }

  export type XeroAccountCountOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    bankAccountNumber?: SortOrder
    status?: SortOrder
    description?: SortOrder
    class?: SortOrder
    systemAccount?: SortOrder
    enablePaymentsToAccount?: SortOrder
    showInExpenseClaims?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    bankAccountNumber?: SortOrder
    status?: SortOrder
    description?: SortOrder
    class?: SortOrder
    systemAccount?: SortOrder
    enablePaymentsToAccount?: SortOrder
    showInExpenseClaims?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroAccountMinOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    bankAccountNumber?: SortOrder
    status?: SortOrder
    description?: SortOrder
    class?: SortOrder
    systemAccount?: SortOrder
    enablePaymentsToAccount?: SortOrder
    showInExpenseClaims?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroInvoiceListRelationFilter = {
    every?: XeroInvoiceWhereInput
    some?: XeroInvoiceWhereInput
    none?: XeroInvoiceWhereInput
  }

  export type XeroBillListRelationFilter = {
    every?: XeroBillWhereInput
    some?: XeroBillWhereInput
    none?: XeroBillWhereInput
  }

  export type XeroPaymentListRelationFilter = {
    every?: XeroPaymentWhereInput
    some?: XeroPaymentWhereInput
    none?: XeroPaymentWhereInput
  }

  export type XeroInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XeroBillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XeroPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type XeroContactCountOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    emailAddress?: SortOrder
    contactStatus?: SortOrder
    isSupplier?: SortOrder
    isCustomer?: SortOrder
    defaultCurrency?: SortOrder
    accountNumber?: SortOrder
    companyNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroContactMaxOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    emailAddress?: SortOrder
    contactStatus?: SortOrder
    isSupplier?: SortOrder
    isCustomer?: SortOrder
    defaultCurrency?: SortOrder
    accountNumber?: SortOrder
    companyNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroContactMinOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    emailAddress?: SortOrder
    contactStatus?: SortOrder
    isSupplier?: SortOrder
    isCustomer?: SortOrder
    defaultCurrency?: SortOrder
    accountNumber?: SortOrder
    companyNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroContactScalarRelationFilter = {
    is?: XeroContactWhereInput
    isNot?: XeroContactWhereInput
  }

  export type XeroInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    invoiceNumber?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrder
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroInvoiceAvgOrderByAggregateInput = {
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
  }

  export type XeroInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    invoiceNumber?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrder
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    invoiceNumber?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrder
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroInvoiceSumOrderByAggregateInput = {
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
  }

  export type XeroBillCountOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    billNumber?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrder
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroBillAvgOrderByAggregateInput = {
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
  }

  export type XeroBillMaxOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    billNumber?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrder
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroBillMinOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    billNumber?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    lineAmountTypes?: SortOrder
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
    currencyCode?: SortOrder
    fullyPaidOnDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroBillSumOrderByAggregateInput = {
    subTotal?: SortOrder
    totalTax?: SortOrder
    total?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    amountCredited?: SortOrder
  }

  export type XeroContactNullableScalarRelationFilter = {
    is?: XeroContactWhereInput | null
    isNot?: XeroContactWhereInput | null
  }

  export type XeroInvoiceNullableScalarRelationFilter = {
    is?: XeroInvoiceWhereInput | null
    isNot?: XeroInvoiceWhereInput | null
  }

  export type XeroBillNullableScalarRelationFilter = {
    is?: XeroBillWhereInput | null
    isNot?: XeroBillWhereInput | null
  }

  export type XeroPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    isReconciled?: SortOrder
    reference?: SortOrder
    batchPaymentId?: SortOrder
    contactId?: SortOrder
    invoiceId?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type XeroPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    isReconciled?: SortOrder
    reference?: SortOrder
    batchPaymentId?: SortOrder
    contactId?: SortOrder
    invoiceId?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    paymentType?: SortOrder
    status?: SortOrder
    isReconciled?: SortOrder
    reference?: SortOrder
    batchPaymentId?: SortOrder
    contactId?: SortOrder
    invoiceId?: SortOrder
    billId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type XeroBankTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    bankAccountId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    status?: SortOrder
    isReconciled?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroBankTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type XeroBankTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    bankAccountId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    status?: SortOrder
    isReconciled?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroBankTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    bankAccountId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    currencyCode?: SortOrder
    status?: SortOrder
    isReconciled?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroBankTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type XeroItemCountOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    salesDetails?: SortOrder
    purchaseDetails?: SortOrder
    isTrackedAsInventory?: SortOrder
    isSold?: SortOrder
    isPurchased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroItemMaxOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isTrackedAsInventory?: SortOrder
    isSold?: SortOrder
    isPurchased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type XeroItemMinOrderByAggregateInput = {
    id?: SortOrder
    xeroId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isTrackedAsInventory?: SortOrder
    isSold?: SortOrder
    isPurchased?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonOrderItemListRelationFilter = {
    every?: AmazonOrderItemWhereInput
    some?: AmazonOrderItemWhereInput
    none?: AmazonOrderItemWhereInput
  }

  export type AmazonOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmazonOrderCountOrderByAggregateInput = {
    id?: SortOrder
    amazonOrderId?: SortOrder
    marketplace?: SortOrder
    orderStatus?: SortOrder
    fulfillmentChannel?: SortOrder
    salesChannel?: SortOrder
    orderType?: SortOrder
    purchaseDate?: SortOrder
    lastUpdateDate?: SortOrder
    orderTotal?: SortOrder
    currency?: SortOrder
    numberOfItemsShipped?: SortOrder
    numberOfItemsUnshipped?: SortOrder
    buyerEmail?: SortOrder
    isBusinessOrder?: SortOrder
    isPrime?: SortOrder
    isGlobalExpressEnabled?: SortOrder
    isReplacementOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonOrderAvgOrderByAggregateInput = {
    orderTotal?: SortOrder
    numberOfItemsShipped?: SortOrder
    numberOfItemsUnshipped?: SortOrder
  }

  export type AmazonOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    amazonOrderId?: SortOrder
    marketplace?: SortOrder
    orderStatus?: SortOrder
    fulfillmentChannel?: SortOrder
    salesChannel?: SortOrder
    orderType?: SortOrder
    purchaseDate?: SortOrder
    lastUpdateDate?: SortOrder
    orderTotal?: SortOrder
    currency?: SortOrder
    numberOfItemsShipped?: SortOrder
    numberOfItemsUnshipped?: SortOrder
    buyerEmail?: SortOrder
    isBusinessOrder?: SortOrder
    isPrime?: SortOrder
    isGlobalExpressEnabled?: SortOrder
    isReplacementOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonOrderMinOrderByAggregateInput = {
    id?: SortOrder
    amazonOrderId?: SortOrder
    marketplace?: SortOrder
    orderStatus?: SortOrder
    fulfillmentChannel?: SortOrder
    salesChannel?: SortOrder
    orderType?: SortOrder
    purchaseDate?: SortOrder
    lastUpdateDate?: SortOrder
    orderTotal?: SortOrder
    currency?: SortOrder
    numberOfItemsShipped?: SortOrder
    numberOfItemsUnshipped?: SortOrder
    buyerEmail?: SortOrder
    isBusinessOrder?: SortOrder
    isPrime?: SortOrder
    isGlobalExpressEnabled?: SortOrder
    isReplacementOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonOrderSumOrderByAggregateInput = {
    orderTotal?: SortOrder
    numberOfItemsShipped?: SortOrder
    numberOfItemsUnshipped?: SortOrder
  }

  export type AmazonOrderScalarRelationFilter = {
    is?: AmazonOrderWhereInput
    isNot?: AmazonOrderWhereInput
  }

  export type AmazonOrderItemOrderItemIdAmazonOrderIdCompoundUniqueInput = {
    orderItemId: string
    amazonOrderId: string
  }

  export type AmazonOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    amazonOrderId?: SortOrder
    asin?: SortOrder
    sellerSKU?: SortOrder
    title?: SortOrder
    quantityOrdered?: SortOrder
    quantityShipped?: SortOrder
    itemPrice?: SortOrder
    itemTax?: SortOrder
    shippingPrice?: SortOrder
    shippingTax?: SortOrder
    giftWrapPrice?: SortOrder
    giftWrapTax?: SortOrder
    itemPromotionDiscount?: SortOrder
    shipPromotionDiscount?: SortOrder
    currency?: SortOrder
    conditionNote?: SortOrder
    conditionId?: SortOrder
    conditionSubtypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonOrderItemAvgOrderByAggregateInput = {
    quantityOrdered?: SortOrder
    quantityShipped?: SortOrder
    itemPrice?: SortOrder
    itemTax?: SortOrder
    shippingPrice?: SortOrder
    shippingTax?: SortOrder
    giftWrapPrice?: SortOrder
    giftWrapTax?: SortOrder
    itemPromotionDiscount?: SortOrder
    shipPromotionDiscount?: SortOrder
  }

  export type AmazonOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    amazonOrderId?: SortOrder
    asin?: SortOrder
    sellerSKU?: SortOrder
    title?: SortOrder
    quantityOrdered?: SortOrder
    quantityShipped?: SortOrder
    itemPrice?: SortOrder
    itemTax?: SortOrder
    shippingPrice?: SortOrder
    shippingTax?: SortOrder
    giftWrapPrice?: SortOrder
    giftWrapTax?: SortOrder
    itemPromotionDiscount?: SortOrder
    shipPromotionDiscount?: SortOrder
    currency?: SortOrder
    conditionNote?: SortOrder
    conditionId?: SortOrder
    conditionSubtypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    amazonOrderId?: SortOrder
    asin?: SortOrder
    sellerSKU?: SortOrder
    title?: SortOrder
    quantityOrdered?: SortOrder
    quantityShipped?: SortOrder
    itemPrice?: SortOrder
    itemTax?: SortOrder
    shippingPrice?: SortOrder
    shippingTax?: SortOrder
    giftWrapPrice?: SortOrder
    giftWrapTax?: SortOrder
    itemPromotionDiscount?: SortOrder
    shipPromotionDiscount?: SortOrder
    currency?: SortOrder
    conditionNote?: SortOrder
    conditionId?: SortOrder
    conditionSubtypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonOrderItemSumOrderByAggregateInput = {
    quantityOrdered?: SortOrder
    quantityShipped?: SortOrder
    itemPrice?: SortOrder
    itemTax?: SortOrder
    shippingPrice?: SortOrder
    shippingTax?: SortOrder
    giftWrapPrice?: SortOrder
    giftWrapTax?: SortOrder
    itemPromotionDiscount?: SortOrder
    shipPromotionDiscount?: SortOrder
  }

  export type AmazonInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    sellerSKU?: SortOrder
    asin?: SortOrder
    fnSKU?: SortOrder
    productName?: SortOrder
    condition?: SortOrder
    totalQuantity?: SortOrder
    inStockQuantity?: SortOrder
    availableQuantity?: SortOrder
    fulfillableQuantity?: SortOrder
    inboundWorkingQuantity?: SortOrder
    inboundShippedQuantity?: SortOrder
    inboundReceivingQuantity?: SortOrder
    reservedQuantity?: SortOrder
    unfulfillableQuantity?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonInventoryAvgOrderByAggregateInput = {
    totalQuantity?: SortOrder
    inStockQuantity?: SortOrder
    availableQuantity?: SortOrder
    fulfillableQuantity?: SortOrder
    inboundWorkingQuantity?: SortOrder
    inboundShippedQuantity?: SortOrder
    inboundReceivingQuantity?: SortOrder
    reservedQuantity?: SortOrder
    unfulfillableQuantity?: SortOrder
  }

  export type AmazonInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerSKU?: SortOrder
    asin?: SortOrder
    fnSKU?: SortOrder
    productName?: SortOrder
    condition?: SortOrder
    totalQuantity?: SortOrder
    inStockQuantity?: SortOrder
    availableQuantity?: SortOrder
    fulfillableQuantity?: SortOrder
    inboundWorkingQuantity?: SortOrder
    inboundShippedQuantity?: SortOrder
    inboundReceivingQuantity?: SortOrder
    reservedQuantity?: SortOrder
    unfulfillableQuantity?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    sellerSKU?: SortOrder
    asin?: SortOrder
    fnSKU?: SortOrder
    productName?: SortOrder
    condition?: SortOrder
    totalQuantity?: SortOrder
    inStockQuantity?: SortOrder
    availableQuantity?: SortOrder
    fulfillableQuantity?: SortOrder
    inboundWorkingQuantity?: SortOrder
    inboundShippedQuantity?: SortOrder
    inboundReceivingQuantity?: SortOrder
    reservedQuantity?: SortOrder
    unfulfillableQuantity?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmazonInventorySumOrderByAggregateInput = {
    totalQuantity?: SortOrder
    inStockQuantity?: SortOrder
    availableQuantity?: SortOrder
    fulfillableQuantity?: SortOrder
    inboundWorkingQuantity?: SortOrder
    inboundShippedQuantity?: SortOrder
    inboundReceivingQuantity?: SortOrder
    reservedQuantity?: SortOrder
    unfulfillableQuantity?: SortOrder
  }

  export type ShopifyLineItemListRelationFilter = {
    every?: ShopifyLineItemWhereInput
    some?: ShopifyLineItemWhereInput
    none?: ShopifyLineItemWhereInput
  }

  export type ShopifyLineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopifyOrderCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyOrderId?: SortOrder
    orderNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    financialStatus?: SortOrder
    fulfillmentStatus?: SortOrder
    tags?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscounts?: SortOrder
    totalWeight?: SortOrder
    currency?: SortOrder
    processedAt?: SortOrder
    closedAt?: SortOrder
    cancelledAt?: SortOrder
    test?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyOrderAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscounts?: SortOrder
    totalWeight?: SortOrder
  }

  export type ShopifyOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyOrderId?: SortOrder
    orderNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    financialStatus?: SortOrder
    fulfillmentStatus?: SortOrder
    tags?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscounts?: SortOrder
    totalWeight?: SortOrder
    currency?: SortOrder
    processedAt?: SortOrder
    closedAt?: SortOrder
    cancelledAt?: SortOrder
    test?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyOrderMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyOrderId?: SortOrder
    orderNumber?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    financialStatus?: SortOrder
    fulfillmentStatus?: SortOrder
    tags?: SortOrder
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscounts?: SortOrder
    totalWeight?: SortOrder
    currency?: SortOrder
    processedAt?: SortOrder
    closedAt?: SortOrder
    cancelledAt?: SortOrder
    test?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyOrderSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    totalTax?: SortOrder
    totalDiscounts?: SortOrder
    totalWeight?: SortOrder
  }

  export type ShopifyOrderScalarRelationFilter = {
    is?: ShopifyOrderWhereInput
    isNot?: ShopifyOrderWhereInput
  }

  export type ShopifyLineItemLineItemIdShopifyOrderIdCompoundUniqueInput = {
    lineItemId: string
    shopifyOrderId: string
  }

  export type ShopifyLineItemCountOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
    shopifyOrderId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    title?: SortOrder
    variantTitle?: SortOrder
    sku?: SortOrder
    vendor?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalDiscount?: SortOrder
    grams?: SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrder
    fulfillmentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyLineItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    totalDiscount?: SortOrder
    grams?: SortOrder
  }

  export type ShopifyLineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
    shopifyOrderId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    title?: SortOrder
    variantTitle?: SortOrder
    sku?: SortOrder
    vendor?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalDiscount?: SortOrder
    grams?: SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrder
    fulfillmentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyLineItemMinOrderByAggregateInput = {
    id?: SortOrder
    lineItemId?: SortOrder
    shopifyOrderId?: SortOrder
    productId?: SortOrder
    variantId?: SortOrder
    title?: SortOrder
    variantTitle?: SortOrder
    sku?: SortOrder
    vendor?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    totalDiscount?: SortOrder
    grams?: SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrder
    fulfillmentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyLineItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    totalDiscount?: SortOrder
    grams?: SortOrder
  }

  export type ShopifyVariantListRelationFilter = {
    every?: ShopifyVariantWhereInput
    some?: ShopifyVariantWhereInput
    none?: ShopifyVariantWhereInput
  }

  export type ShopifyVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopifyProductCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrder
    handle?: SortOrder
    vendor?: SortOrder
    productType?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    description?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyProductMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrder
    handle?: SortOrder
    vendor?: SortOrder
    productType?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    description?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyProductMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrder
    handle?: SortOrder
    vendor?: SortOrder
    productType?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    description?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyProductScalarRelationFilter = {
    is?: ShopifyProductWhereInput
    isNot?: ShopifyProductWhereInput
  }

  export type ShopifyVariantCountOrderByAggregateInput = {
    id?: SortOrder
    shopifyVariantId?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    grams?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    inventoryQuantity?: SortOrder
    inventoryPolicy?: SortOrder
    inventoryTracking?: SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyVariantAvgOrderByAggregateInput = {
    price?: SortOrder
    compareAtPrice?: SortOrder
    grams?: SortOrder
    weight?: SortOrder
    inventoryQuantity?: SortOrder
    position?: SortOrder
  }

  export type ShopifyVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    shopifyVariantId?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    grams?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    inventoryQuantity?: SortOrder
    inventoryPolicy?: SortOrder
    inventoryTracking?: SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyVariantMinOrderByAggregateInput = {
    id?: SortOrder
    shopifyVariantId?: SortOrder
    shopifyProductId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    grams?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    inventoryQuantity?: SortOrder
    inventoryPolicy?: SortOrder
    inventoryTracking?: SortOrder
    requiresShipping?: SortOrder
    taxable?: SortOrder
    fulfillmentService?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopifyVariantSumOrderByAggregateInput = {
    price?: SortOrder
    compareAtPrice?: SortOrder
    grams?: SortOrder
    weight?: SortOrder
    inventoryQuantity?: SortOrder
    position?: SortOrder
  }

  export type MachineSensorListRelationFilter = {
    every?: MachineSensorWhereInput
    some?: MachineSensorWhereInput
    none?: MachineSensorWhereInput
  }

  export type MachineAlertListRelationFilter = {
    every?: MachineAlertWhereInput
    some?: MachineAlertWhereInput
    none?: MachineAlertWhereInput
  }

  export type MachineMaintenanceRecordListRelationFilter = {
    every?: MachineMaintenanceRecordWhereInput
    some?: MachineMaintenanceRecordWhereInput
    none?: MachineMaintenanceRecordWhereInput
  }

  export type MachineSensorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineMaintenanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    installDate?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    configuration?: SortOrder
    specifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    installDate?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    location?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    installDate?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineScalarRelationFilter = {
    is?: MachineWhereInput
    isNot?: MachineWhereInput
  }

  export type MachineSensorCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    sensorType?: SortOrder
    sensorName?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    threshold?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineSensorAvgOrderByAggregateInput = {
    value?: SortOrder
    threshold?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
  }

  export type MachineSensorMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    sensorType?: SortOrder
    sensorName?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    threshold?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineSensorMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    sensorType?: SortOrder
    sensorName?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    threshold?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineSensorSumOrderByAggregateInput = {
    value?: SortOrder
    threshold?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
  }

  export type MachineAlertCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    resolvedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineAlertMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    acknowledged?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MachineMaintenanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    duration?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineMaintenanceRecordAvgOrderByAggregateInput = {
    duration?: SortOrder
    cost?: SortOrder
  }

  export type MachineMaintenanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    duration?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineMaintenanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    machineId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    performedBy?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    duration?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineMaintenanceRecordSumOrderByAggregateInput = {
    duration?: SortOrder
    cost?: SortOrder
  }

  export type ProductionNullableScalarRelationFilter = {
    is?: ProductionWhereInput | null
    isNot?: ProductionWhereInput | null
  }

  export type QualityCheckCountOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    checkType?: SortOrder
    checkDate?: SortOrder
    inspector?: SortOrder
    passed?: SortOrder
    score?: SortOrder
    defectCount?: SortOrder
    sampleSize?: SortOrder
    notes?: SortOrder
    corrective?: SortOrder
    attachments?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type QualityCheckAvgOrderByAggregateInput = {
    score?: SortOrder
    defectCount?: SortOrder
    sampleSize?: SortOrder
  }

  export type QualityCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    checkType?: SortOrder
    checkDate?: SortOrder
    inspector?: SortOrder
    passed?: SortOrder
    score?: SortOrder
    defectCount?: SortOrder
    sampleSize?: SortOrder
    notes?: SortOrder
    corrective?: SortOrder
    createdAt?: SortOrder
  }

  export type QualityCheckMinOrderByAggregateInput = {
    id?: SortOrder
    productionId?: SortOrder
    checkType?: SortOrder
    checkDate?: SortOrder
    inspector?: SortOrder
    passed?: SortOrder
    score?: SortOrder
    defectCount?: SortOrder
    sampleSize?: SortOrder
    notes?: SortOrder
    corrective?: SortOrder
    createdAt?: SortOrder
  }

  export type QualityCheckSumOrderByAggregateInput = {
    score?: SortOrder
    defectCount?: SortOrder
    sampleSize?: SortOrder
  }

  export type ProductionOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    productSKU?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    assignedMachine?: SortOrder
    assignedOperator?: SortOrder
    batchNumber?: SortOrder
    qualityGrade?: SortOrder
    yield?: SortOrder
    efficiency?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOrderAvgOrderByAggregateInput = {
    quantity?: SortOrder
    yield?: SortOrder
    efficiency?: SortOrder
  }

  export type ProductionOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    productSKU?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    assignedMachine?: SortOrder
    assignedOperator?: SortOrder
    batchNumber?: SortOrder
    qualityGrade?: SortOrder
    yield?: SortOrder
    efficiency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    productSKU?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    assignedMachine?: SortOrder
    assignedOperator?: SortOrder
    batchNumber?: SortOrder
    qualityGrade?: SortOrder
    yield?: SortOrder
    efficiency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOrderSumOrderByAggregateInput = {
    quantity?: SortOrder
    yield?: SortOrder
    efficiency?: SortOrder
  }

  export type DashboardCreateNestedManyWithoutUserInput = {
    create?: XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput> | DashboardCreateWithoutUserInput[] | DashboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardCreateOrConnectWithoutUserInput | DashboardCreateOrConnectWithoutUserInput[]
    createMany?: DashboardCreateManyUserInputEnvelope
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
  }

  export type DashboardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput> | DashboardCreateWithoutUserInput[] | DashboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardCreateOrConnectWithoutUserInput | DashboardCreateOrConnectWithoutUserInput[]
    createMany?: DashboardCreateManyUserInputEnvelope
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DashboardUpdateManyWithoutUserNestedInput = {
    create?: XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput> | DashboardCreateWithoutUserInput[] | DashboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardCreateOrConnectWithoutUserInput | DashboardCreateOrConnectWithoutUserInput[]
    upsert?: DashboardUpsertWithWhereUniqueWithoutUserInput | DashboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DashboardCreateManyUserInputEnvelope
    set?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    disconnect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    delete?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    update?: DashboardUpdateWithWhereUniqueWithoutUserInput | DashboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DashboardUpdateManyWithWhereWithoutUserInput | DashboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DashboardScalarWhereInput | DashboardScalarWhereInput[]
  }

  export type DashboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput> | DashboardCreateWithoutUserInput[] | DashboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DashboardCreateOrConnectWithoutUserInput | DashboardCreateOrConnectWithoutUserInput[]
    upsert?: DashboardUpsertWithWhereUniqueWithoutUserInput | DashboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DashboardCreateManyUserInputEnvelope
    set?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    disconnect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    delete?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[]
    update?: DashboardUpdateWithWhereUniqueWithoutUserInput | DashboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DashboardUpdateManyWithWhereWithoutUserInput | DashboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DashboardScalarWhereInput | DashboardScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QualityCheckCreateNestedManyWithoutProductionInput = {
    create?: XOR<QualityCheckCreateWithoutProductionInput, QualityCheckUncheckedCreateWithoutProductionInput> | QualityCheckCreateWithoutProductionInput[] | QualityCheckUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: QualityCheckCreateOrConnectWithoutProductionInput | QualityCheckCreateOrConnectWithoutProductionInput[]
    createMany?: QualityCheckCreateManyProductionInputEnvelope
    connect?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
  }

  export type QualityCheckUncheckedCreateNestedManyWithoutProductionInput = {
    create?: XOR<QualityCheckCreateWithoutProductionInput, QualityCheckUncheckedCreateWithoutProductionInput> | QualityCheckCreateWithoutProductionInput[] | QualityCheckUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: QualityCheckCreateOrConnectWithoutProductionInput | QualityCheckCreateOrConnectWithoutProductionInput[]
    createMany?: QualityCheckCreateManyProductionInputEnvelope
    connect?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
  }

  export type EnumProductionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductionStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QualityCheckUpdateManyWithoutProductionNestedInput = {
    create?: XOR<QualityCheckCreateWithoutProductionInput, QualityCheckUncheckedCreateWithoutProductionInput> | QualityCheckCreateWithoutProductionInput[] | QualityCheckUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: QualityCheckCreateOrConnectWithoutProductionInput | QualityCheckCreateOrConnectWithoutProductionInput[]
    upsert?: QualityCheckUpsertWithWhereUniqueWithoutProductionInput | QualityCheckUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: QualityCheckCreateManyProductionInputEnvelope
    set?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
    disconnect?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
    delete?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
    connect?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
    update?: QualityCheckUpdateWithWhereUniqueWithoutProductionInput | QualityCheckUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: QualityCheckUpdateManyWithWhereWithoutProductionInput | QualityCheckUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: QualityCheckScalarWhereInput | QualityCheckScalarWhereInput[]
  }

  export type QualityCheckUncheckedUpdateManyWithoutProductionNestedInput = {
    create?: XOR<QualityCheckCreateWithoutProductionInput, QualityCheckUncheckedCreateWithoutProductionInput> | QualityCheckCreateWithoutProductionInput[] | QualityCheckUncheckedCreateWithoutProductionInput[]
    connectOrCreate?: QualityCheckCreateOrConnectWithoutProductionInput | QualityCheckCreateOrConnectWithoutProductionInput[]
    upsert?: QualityCheckUpsertWithWhereUniqueWithoutProductionInput | QualityCheckUpsertWithWhereUniqueWithoutProductionInput[]
    createMany?: QualityCheckCreateManyProductionInputEnvelope
    set?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
    disconnect?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
    delete?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
    connect?: QualityCheckWhereUniqueInput | QualityCheckWhereUniqueInput[]
    update?: QualityCheckUpdateWithWhereUniqueWithoutProductionInput | QualityCheckUpdateWithWhereUniqueWithoutProductionInput[]
    updateMany?: QualityCheckUpdateManyWithWhereWithoutProductionInput | QualityCheckUpdateManyWithWhereWithoutProductionInput[]
    deleteMany?: QualityCheckScalarWhereInput | QualityCheckScalarWhereInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput> | InventoryMovementCreateWithoutInventoryInput[] | InventoryMovementUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutInventoryInput | InventoryMovementCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryMovementCreateManyInventoryInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput> | InventoryMovementCreateWithoutInventoryInput[] | InventoryMovementUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutInventoryInput | InventoryMovementCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryMovementCreateManyInventoryInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput> | InventoryMovementCreateWithoutInventoryInput[] | InventoryMovementUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutInventoryInput | InventoryMovementCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput | InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryMovementCreateManyInventoryInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput | InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutInventoryInput | InventoryMovementUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput> | InventoryMovementCreateWithoutInventoryInput[] | InventoryMovementUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutInventoryInput | InventoryMovementCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput | InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryMovementCreateManyInventoryInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput | InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutInventoryInput | InventoryMovementUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryCreateNestedOneWithoutMovementsInput = {
    create?: XOR<InventoryCreateWithoutMovementsInput, InventoryUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutMovementsInput
    connect?: InventoryWhereUniqueInput
  }

  export type EnumMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.MovementType
  }

  export type InventoryUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<InventoryCreateWithoutMovementsInput, InventoryUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutMovementsInput
    upsert?: InventoryUpsertWithoutMovementsInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutMovementsInput, InventoryUpdateWithoutMovementsInput>, InventoryUncheckedUpdateWithoutMovementsInput>
  }

  export type AIInsightCreateembeddingInput = {
    set: number[]
  }

  export type AIInsightUpdateembeddingInput = {
    set?: number[]
    push?: number | number[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCreateNestedOneWithoutDashboardsInput = {
    create?: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDashboardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDashboardsNestedInput = {
    create?: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDashboardsInput
    upsert?: UserUpsertWithoutDashboardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDashboardsInput, UserUpdateWithoutDashboardsInput>, UserUncheckedUpdateWithoutDashboardsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CashLedgerCreatetagsInput = {
    set: string[]
  }

  export type CashLedgerUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExpenseCreatetagsInput = {
    set: string[]
  }

  export type ExpenseCreateattachmentsInput = {
    set: string[]
  }

  export type ExpenseUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ExpenseUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type XeroInvoiceCreateNestedManyWithoutContactInput = {
    create?: XOR<XeroInvoiceCreateWithoutContactInput, XeroInvoiceUncheckedCreateWithoutContactInput> | XeroInvoiceCreateWithoutContactInput[] | XeroInvoiceUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroInvoiceCreateOrConnectWithoutContactInput | XeroInvoiceCreateOrConnectWithoutContactInput[]
    createMany?: XeroInvoiceCreateManyContactInputEnvelope
    connect?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
  }

  export type XeroBillCreateNestedManyWithoutContactInput = {
    create?: XOR<XeroBillCreateWithoutContactInput, XeroBillUncheckedCreateWithoutContactInput> | XeroBillCreateWithoutContactInput[] | XeroBillUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroBillCreateOrConnectWithoutContactInput | XeroBillCreateOrConnectWithoutContactInput[]
    createMany?: XeroBillCreateManyContactInputEnvelope
    connect?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
  }

  export type XeroPaymentCreateNestedManyWithoutContactInput = {
    create?: XOR<XeroPaymentCreateWithoutContactInput, XeroPaymentUncheckedCreateWithoutContactInput> | XeroPaymentCreateWithoutContactInput[] | XeroPaymentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutContactInput | XeroPaymentCreateOrConnectWithoutContactInput[]
    createMany?: XeroPaymentCreateManyContactInputEnvelope
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
  }

  export type XeroInvoiceUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<XeroInvoiceCreateWithoutContactInput, XeroInvoiceUncheckedCreateWithoutContactInput> | XeroInvoiceCreateWithoutContactInput[] | XeroInvoiceUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroInvoiceCreateOrConnectWithoutContactInput | XeroInvoiceCreateOrConnectWithoutContactInput[]
    createMany?: XeroInvoiceCreateManyContactInputEnvelope
    connect?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
  }

  export type XeroBillUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<XeroBillCreateWithoutContactInput, XeroBillUncheckedCreateWithoutContactInput> | XeroBillCreateWithoutContactInput[] | XeroBillUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroBillCreateOrConnectWithoutContactInput | XeroBillCreateOrConnectWithoutContactInput[]
    createMany?: XeroBillCreateManyContactInputEnvelope
    connect?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
  }

  export type XeroPaymentUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<XeroPaymentCreateWithoutContactInput, XeroPaymentUncheckedCreateWithoutContactInput> | XeroPaymentCreateWithoutContactInput[] | XeroPaymentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutContactInput | XeroPaymentCreateOrConnectWithoutContactInput[]
    createMany?: XeroPaymentCreateManyContactInputEnvelope
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
  }

  export type XeroInvoiceUpdateManyWithoutContactNestedInput = {
    create?: XOR<XeroInvoiceCreateWithoutContactInput, XeroInvoiceUncheckedCreateWithoutContactInput> | XeroInvoiceCreateWithoutContactInput[] | XeroInvoiceUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroInvoiceCreateOrConnectWithoutContactInput | XeroInvoiceCreateOrConnectWithoutContactInput[]
    upsert?: XeroInvoiceUpsertWithWhereUniqueWithoutContactInput | XeroInvoiceUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: XeroInvoiceCreateManyContactInputEnvelope
    set?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
    disconnect?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
    delete?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
    connect?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
    update?: XeroInvoiceUpdateWithWhereUniqueWithoutContactInput | XeroInvoiceUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: XeroInvoiceUpdateManyWithWhereWithoutContactInput | XeroInvoiceUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: XeroInvoiceScalarWhereInput | XeroInvoiceScalarWhereInput[]
  }

  export type XeroBillUpdateManyWithoutContactNestedInput = {
    create?: XOR<XeroBillCreateWithoutContactInput, XeroBillUncheckedCreateWithoutContactInput> | XeroBillCreateWithoutContactInput[] | XeroBillUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroBillCreateOrConnectWithoutContactInput | XeroBillCreateOrConnectWithoutContactInput[]
    upsert?: XeroBillUpsertWithWhereUniqueWithoutContactInput | XeroBillUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: XeroBillCreateManyContactInputEnvelope
    set?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
    disconnect?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
    delete?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
    connect?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
    update?: XeroBillUpdateWithWhereUniqueWithoutContactInput | XeroBillUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: XeroBillUpdateManyWithWhereWithoutContactInput | XeroBillUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: XeroBillScalarWhereInput | XeroBillScalarWhereInput[]
  }

  export type XeroPaymentUpdateManyWithoutContactNestedInput = {
    create?: XOR<XeroPaymentCreateWithoutContactInput, XeroPaymentUncheckedCreateWithoutContactInput> | XeroPaymentCreateWithoutContactInput[] | XeroPaymentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutContactInput | XeroPaymentCreateOrConnectWithoutContactInput[]
    upsert?: XeroPaymentUpsertWithWhereUniqueWithoutContactInput | XeroPaymentUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: XeroPaymentCreateManyContactInputEnvelope
    set?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    disconnect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    delete?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    update?: XeroPaymentUpdateWithWhereUniqueWithoutContactInput | XeroPaymentUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: XeroPaymentUpdateManyWithWhereWithoutContactInput | XeroPaymentUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: XeroPaymentScalarWhereInput | XeroPaymentScalarWhereInput[]
  }

  export type XeroInvoiceUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<XeroInvoiceCreateWithoutContactInput, XeroInvoiceUncheckedCreateWithoutContactInput> | XeroInvoiceCreateWithoutContactInput[] | XeroInvoiceUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroInvoiceCreateOrConnectWithoutContactInput | XeroInvoiceCreateOrConnectWithoutContactInput[]
    upsert?: XeroInvoiceUpsertWithWhereUniqueWithoutContactInput | XeroInvoiceUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: XeroInvoiceCreateManyContactInputEnvelope
    set?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
    disconnect?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
    delete?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
    connect?: XeroInvoiceWhereUniqueInput | XeroInvoiceWhereUniqueInput[]
    update?: XeroInvoiceUpdateWithWhereUniqueWithoutContactInput | XeroInvoiceUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: XeroInvoiceUpdateManyWithWhereWithoutContactInput | XeroInvoiceUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: XeroInvoiceScalarWhereInput | XeroInvoiceScalarWhereInput[]
  }

  export type XeroBillUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<XeroBillCreateWithoutContactInput, XeroBillUncheckedCreateWithoutContactInput> | XeroBillCreateWithoutContactInput[] | XeroBillUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroBillCreateOrConnectWithoutContactInput | XeroBillCreateOrConnectWithoutContactInput[]
    upsert?: XeroBillUpsertWithWhereUniqueWithoutContactInput | XeroBillUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: XeroBillCreateManyContactInputEnvelope
    set?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
    disconnect?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
    delete?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
    connect?: XeroBillWhereUniqueInput | XeroBillWhereUniqueInput[]
    update?: XeroBillUpdateWithWhereUniqueWithoutContactInput | XeroBillUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: XeroBillUpdateManyWithWhereWithoutContactInput | XeroBillUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: XeroBillScalarWhereInput | XeroBillScalarWhereInput[]
  }

  export type XeroPaymentUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<XeroPaymentCreateWithoutContactInput, XeroPaymentUncheckedCreateWithoutContactInput> | XeroPaymentCreateWithoutContactInput[] | XeroPaymentUncheckedCreateWithoutContactInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutContactInput | XeroPaymentCreateOrConnectWithoutContactInput[]
    upsert?: XeroPaymentUpsertWithWhereUniqueWithoutContactInput | XeroPaymentUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: XeroPaymentCreateManyContactInputEnvelope
    set?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    disconnect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    delete?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    update?: XeroPaymentUpdateWithWhereUniqueWithoutContactInput | XeroPaymentUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: XeroPaymentUpdateManyWithWhereWithoutContactInput | XeroPaymentUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: XeroPaymentScalarWhereInput | XeroPaymentScalarWhereInput[]
  }

  export type XeroContactCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<XeroContactCreateWithoutInvoicesInput, XeroContactUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: XeroContactCreateOrConnectWithoutInvoicesInput
    connect?: XeroContactWhereUniqueInput
  }

  export type XeroPaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<XeroPaymentCreateWithoutInvoiceInput, XeroPaymentUncheckedCreateWithoutInvoiceInput> | XeroPaymentCreateWithoutInvoiceInput[] | XeroPaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutInvoiceInput | XeroPaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: XeroPaymentCreateManyInvoiceInputEnvelope
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
  }

  export type XeroPaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<XeroPaymentCreateWithoutInvoiceInput, XeroPaymentUncheckedCreateWithoutInvoiceInput> | XeroPaymentCreateWithoutInvoiceInput[] | XeroPaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutInvoiceInput | XeroPaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: XeroPaymentCreateManyInvoiceInputEnvelope
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
  }

  export type XeroContactUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<XeroContactCreateWithoutInvoicesInput, XeroContactUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: XeroContactCreateOrConnectWithoutInvoicesInput
    upsert?: XeroContactUpsertWithoutInvoicesInput
    connect?: XeroContactWhereUniqueInput
    update?: XOR<XOR<XeroContactUpdateToOneWithWhereWithoutInvoicesInput, XeroContactUpdateWithoutInvoicesInput>, XeroContactUncheckedUpdateWithoutInvoicesInput>
  }

  export type XeroPaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<XeroPaymentCreateWithoutInvoiceInput, XeroPaymentUncheckedCreateWithoutInvoiceInput> | XeroPaymentCreateWithoutInvoiceInput[] | XeroPaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutInvoiceInput | XeroPaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: XeroPaymentUpsertWithWhereUniqueWithoutInvoiceInput | XeroPaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: XeroPaymentCreateManyInvoiceInputEnvelope
    set?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    disconnect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    delete?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    update?: XeroPaymentUpdateWithWhereUniqueWithoutInvoiceInput | XeroPaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: XeroPaymentUpdateManyWithWhereWithoutInvoiceInput | XeroPaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: XeroPaymentScalarWhereInput | XeroPaymentScalarWhereInput[]
  }

  export type XeroPaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<XeroPaymentCreateWithoutInvoiceInput, XeroPaymentUncheckedCreateWithoutInvoiceInput> | XeroPaymentCreateWithoutInvoiceInput[] | XeroPaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutInvoiceInput | XeroPaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: XeroPaymentUpsertWithWhereUniqueWithoutInvoiceInput | XeroPaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: XeroPaymentCreateManyInvoiceInputEnvelope
    set?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    disconnect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    delete?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    update?: XeroPaymentUpdateWithWhereUniqueWithoutInvoiceInput | XeroPaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: XeroPaymentUpdateManyWithWhereWithoutInvoiceInput | XeroPaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: XeroPaymentScalarWhereInput | XeroPaymentScalarWhereInput[]
  }

  export type XeroContactCreateNestedOneWithoutBillsInput = {
    create?: XOR<XeroContactCreateWithoutBillsInput, XeroContactUncheckedCreateWithoutBillsInput>
    connectOrCreate?: XeroContactCreateOrConnectWithoutBillsInput
    connect?: XeroContactWhereUniqueInput
  }

  export type XeroPaymentCreateNestedManyWithoutBillInput = {
    create?: XOR<XeroPaymentCreateWithoutBillInput, XeroPaymentUncheckedCreateWithoutBillInput> | XeroPaymentCreateWithoutBillInput[] | XeroPaymentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutBillInput | XeroPaymentCreateOrConnectWithoutBillInput[]
    createMany?: XeroPaymentCreateManyBillInputEnvelope
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
  }

  export type XeroPaymentUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<XeroPaymentCreateWithoutBillInput, XeroPaymentUncheckedCreateWithoutBillInput> | XeroPaymentCreateWithoutBillInput[] | XeroPaymentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutBillInput | XeroPaymentCreateOrConnectWithoutBillInput[]
    createMany?: XeroPaymentCreateManyBillInputEnvelope
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
  }

  export type XeroContactUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<XeroContactCreateWithoutBillsInput, XeroContactUncheckedCreateWithoutBillsInput>
    connectOrCreate?: XeroContactCreateOrConnectWithoutBillsInput
    upsert?: XeroContactUpsertWithoutBillsInput
    connect?: XeroContactWhereUniqueInput
    update?: XOR<XOR<XeroContactUpdateToOneWithWhereWithoutBillsInput, XeroContactUpdateWithoutBillsInput>, XeroContactUncheckedUpdateWithoutBillsInput>
  }

  export type XeroPaymentUpdateManyWithoutBillNestedInput = {
    create?: XOR<XeroPaymentCreateWithoutBillInput, XeroPaymentUncheckedCreateWithoutBillInput> | XeroPaymentCreateWithoutBillInput[] | XeroPaymentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutBillInput | XeroPaymentCreateOrConnectWithoutBillInput[]
    upsert?: XeroPaymentUpsertWithWhereUniqueWithoutBillInput | XeroPaymentUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: XeroPaymentCreateManyBillInputEnvelope
    set?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    disconnect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    delete?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    update?: XeroPaymentUpdateWithWhereUniqueWithoutBillInput | XeroPaymentUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: XeroPaymentUpdateManyWithWhereWithoutBillInput | XeroPaymentUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: XeroPaymentScalarWhereInput | XeroPaymentScalarWhereInput[]
  }

  export type XeroPaymentUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<XeroPaymentCreateWithoutBillInput, XeroPaymentUncheckedCreateWithoutBillInput> | XeroPaymentCreateWithoutBillInput[] | XeroPaymentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: XeroPaymentCreateOrConnectWithoutBillInput | XeroPaymentCreateOrConnectWithoutBillInput[]
    upsert?: XeroPaymentUpsertWithWhereUniqueWithoutBillInput | XeroPaymentUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: XeroPaymentCreateManyBillInputEnvelope
    set?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    disconnect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    delete?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    connect?: XeroPaymentWhereUniqueInput | XeroPaymentWhereUniqueInput[]
    update?: XeroPaymentUpdateWithWhereUniqueWithoutBillInput | XeroPaymentUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: XeroPaymentUpdateManyWithWhereWithoutBillInput | XeroPaymentUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: XeroPaymentScalarWhereInput | XeroPaymentScalarWhereInput[]
  }

  export type XeroContactCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<XeroContactCreateWithoutPaymentsInput, XeroContactUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: XeroContactCreateOrConnectWithoutPaymentsInput
    connect?: XeroContactWhereUniqueInput
  }

  export type XeroInvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<XeroInvoiceCreateWithoutPaymentsInput, XeroInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: XeroInvoiceCreateOrConnectWithoutPaymentsInput
    connect?: XeroInvoiceWhereUniqueInput
  }

  export type XeroBillCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<XeroBillCreateWithoutPaymentsInput, XeroBillUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: XeroBillCreateOrConnectWithoutPaymentsInput
    connect?: XeroBillWhereUniqueInput
  }

  export type XeroContactUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<XeroContactCreateWithoutPaymentsInput, XeroContactUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: XeroContactCreateOrConnectWithoutPaymentsInput
    upsert?: XeroContactUpsertWithoutPaymentsInput
    disconnect?: XeroContactWhereInput | boolean
    delete?: XeroContactWhereInput | boolean
    connect?: XeroContactWhereUniqueInput
    update?: XOR<XOR<XeroContactUpdateToOneWithWhereWithoutPaymentsInput, XeroContactUpdateWithoutPaymentsInput>, XeroContactUncheckedUpdateWithoutPaymentsInput>
  }

  export type XeroInvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<XeroInvoiceCreateWithoutPaymentsInput, XeroInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: XeroInvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: XeroInvoiceUpsertWithoutPaymentsInput
    disconnect?: XeroInvoiceWhereInput | boolean
    delete?: XeroInvoiceWhereInput | boolean
    connect?: XeroInvoiceWhereUniqueInput
    update?: XOR<XOR<XeroInvoiceUpdateToOneWithWhereWithoutPaymentsInput, XeroInvoiceUpdateWithoutPaymentsInput>, XeroInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type XeroBillUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<XeroBillCreateWithoutPaymentsInput, XeroBillUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: XeroBillCreateOrConnectWithoutPaymentsInput
    upsert?: XeroBillUpsertWithoutPaymentsInput
    disconnect?: XeroBillWhereInput | boolean
    delete?: XeroBillWhereInput | boolean
    connect?: XeroBillWhereUniqueInput
    update?: XOR<XOR<XeroBillUpdateToOneWithWhereWithoutPaymentsInput, XeroBillUpdateWithoutPaymentsInput>, XeroBillUncheckedUpdateWithoutPaymentsInput>
  }

  export type AmazonOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<AmazonOrderItemCreateWithoutOrderInput, AmazonOrderItemUncheckedCreateWithoutOrderInput> | AmazonOrderItemCreateWithoutOrderInput[] | AmazonOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AmazonOrderItemCreateOrConnectWithoutOrderInput | AmazonOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: AmazonOrderItemCreateManyOrderInputEnvelope
    connect?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
  }

  export type AmazonOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<AmazonOrderItemCreateWithoutOrderInput, AmazonOrderItemUncheckedCreateWithoutOrderInput> | AmazonOrderItemCreateWithoutOrderInput[] | AmazonOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AmazonOrderItemCreateOrConnectWithoutOrderInput | AmazonOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: AmazonOrderItemCreateManyOrderInputEnvelope
    connect?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
  }

  export type AmazonOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AmazonOrderItemCreateWithoutOrderInput, AmazonOrderItemUncheckedCreateWithoutOrderInput> | AmazonOrderItemCreateWithoutOrderInput[] | AmazonOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AmazonOrderItemCreateOrConnectWithoutOrderInput | AmazonOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: AmazonOrderItemUpsertWithWhereUniqueWithoutOrderInput | AmazonOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AmazonOrderItemCreateManyOrderInputEnvelope
    set?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
    disconnect?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
    delete?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
    connect?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
    update?: AmazonOrderItemUpdateWithWhereUniqueWithoutOrderInput | AmazonOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AmazonOrderItemUpdateManyWithWhereWithoutOrderInput | AmazonOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AmazonOrderItemScalarWhereInput | AmazonOrderItemScalarWhereInput[]
  }

  export type AmazonOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AmazonOrderItemCreateWithoutOrderInput, AmazonOrderItemUncheckedCreateWithoutOrderInput> | AmazonOrderItemCreateWithoutOrderInput[] | AmazonOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AmazonOrderItemCreateOrConnectWithoutOrderInput | AmazonOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: AmazonOrderItemUpsertWithWhereUniqueWithoutOrderInput | AmazonOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AmazonOrderItemCreateManyOrderInputEnvelope
    set?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
    disconnect?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
    delete?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
    connect?: AmazonOrderItemWhereUniqueInput | AmazonOrderItemWhereUniqueInput[]
    update?: AmazonOrderItemUpdateWithWhereUniqueWithoutOrderInput | AmazonOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AmazonOrderItemUpdateManyWithWhereWithoutOrderInput | AmazonOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AmazonOrderItemScalarWhereInput | AmazonOrderItemScalarWhereInput[]
  }

  export type AmazonOrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<AmazonOrderCreateWithoutOrderItemsInput, AmazonOrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: AmazonOrderCreateOrConnectWithoutOrderItemsInput
    connect?: AmazonOrderWhereUniqueInput
  }

  export type AmazonOrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<AmazonOrderCreateWithoutOrderItemsInput, AmazonOrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: AmazonOrderCreateOrConnectWithoutOrderItemsInput
    upsert?: AmazonOrderUpsertWithoutOrderItemsInput
    connect?: AmazonOrderWhereUniqueInput
    update?: XOR<XOR<AmazonOrderUpdateToOneWithWhereWithoutOrderItemsInput, AmazonOrderUpdateWithoutOrderItemsInput>, AmazonOrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ShopifyLineItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<ShopifyLineItemCreateWithoutOrderInput, ShopifyLineItemUncheckedCreateWithoutOrderInput> | ShopifyLineItemCreateWithoutOrderInput[] | ShopifyLineItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShopifyLineItemCreateOrConnectWithoutOrderInput | ShopifyLineItemCreateOrConnectWithoutOrderInput[]
    createMany?: ShopifyLineItemCreateManyOrderInputEnvelope
    connect?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
  }

  export type ShopifyLineItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ShopifyLineItemCreateWithoutOrderInput, ShopifyLineItemUncheckedCreateWithoutOrderInput> | ShopifyLineItemCreateWithoutOrderInput[] | ShopifyLineItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShopifyLineItemCreateOrConnectWithoutOrderInput | ShopifyLineItemCreateOrConnectWithoutOrderInput[]
    createMany?: ShopifyLineItemCreateManyOrderInputEnvelope
    connect?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
  }

  export type ShopifyLineItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ShopifyLineItemCreateWithoutOrderInput, ShopifyLineItemUncheckedCreateWithoutOrderInput> | ShopifyLineItemCreateWithoutOrderInput[] | ShopifyLineItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShopifyLineItemCreateOrConnectWithoutOrderInput | ShopifyLineItemCreateOrConnectWithoutOrderInput[]
    upsert?: ShopifyLineItemUpsertWithWhereUniqueWithoutOrderInput | ShopifyLineItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ShopifyLineItemCreateManyOrderInputEnvelope
    set?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
    disconnect?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
    delete?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
    connect?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
    update?: ShopifyLineItemUpdateWithWhereUniqueWithoutOrderInput | ShopifyLineItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ShopifyLineItemUpdateManyWithWhereWithoutOrderInput | ShopifyLineItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ShopifyLineItemScalarWhereInput | ShopifyLineItemScalarWhereInput[]
  }

  export type ShopifyLineItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ShopifyLineItemCreateWithoutOrderInput, ShopifyLineItemUncheckedCreateWithoutOrderInput> | ShopifyLineItemCreateWithoutOrderInput[] | ShopifyLineItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShopifyLineItemCreateOrConnectWithoutOrderInput | ShopifyLineItemCreateOrConnectWithoutOrderInput[]
    upsert?: ShopifyLineItemUpsertWithWhereUniqueWithoutOrderInput | ShopifyLineItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ShopifyLineItemCreateManyOrderInputEnvelope
    set?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
    disconnect?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
    delete?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
    connect?: ShopifyLineItemWhereUniqueInput | ShopifyLineItemWhereUniqueInput[]
    update?: ShopifyLineItemUpdateWithWhereUniqueWithoutOrderInput | ShopifyLineItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ShopifyLineItemUpdateManyWithWhereWithoutOrderInput | ShopifyLineItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ShopifyLineItemScalarWhereInput | ShopifyLineItemScalarWhereInput[]
  }

  export type ShopifyOrderCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<ShopifyOrderCreateWithoutLineItemsInput, ShopifyOrderUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: ShopifyOrderCreateOrConnectWithoutLineItemsInput
    connect?: ShopifyOrderWhereUniqueInput
  }

  export type ShopifyOrderUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<ShopifyOrderCreateWithoutLineItemsInput, ShopifyOrderUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: ShopifyOrderCreateOrConnectWithoutLineItemsInput
    upsert?: ShopifyOrderUpsertWithoutLineItemsInput
    connect?: ShopifyOrderWhereUniqueInput
    update?: XOR<XOR<ShopifyOrderUpdateToOneWithWhereWithoutLineItemsInput, ShopifyOrderUpdateWithoutLineItemsInput>, ShopifyOrderUncheckedUpdateWithoutLineItemsInput>
  }

  export type ShopifyVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<ShopifyVariantCreateWithoutProductInput, ShopifyVariantUncheckedCreateWithoutProductInput> | ShopifyVariantCreateWithoutProductInput[] | ShopifyVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ShopifyVariantCreateOrConnectWithoutProductInput | ShopifyVariantCreateOrConnectWithoutProductInput[]
    createMany?: ShopifyVariantCreateManyProductInputEnvelope
    connect?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
  }

  export type ShopifyVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ShopifyVariantCreateWithoutProductInput, ShopifyVariantUncheckedCreateWithoutProductInput> | ShopifyVariantCreateWithoutProductInput[] | ShopifyVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ShopifyVariantCreateOrConnectWithoutProductInput | ShopifyVariantCreateOrConnectWithoutProductInput[]
    createMany?: ShopifyVariantCreateManyProductInputEnvelope
    connect?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
  }

  export type ShopifyVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<ShopifyVariantCreateWithoutProductInput, ShopifyVariantUncheckedCreateWithoutProductInput> | ShopifyVariantCreateWithoutProductInput[] | ShopifyVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ShopifyVariantCreateOrConnectWithoutProductInput | ShopifyVariantCreateOrConnectWithoutProductInput[]
    upsert?: ShopifyVariantUpsertWithWhereUniqueWithoutProductInput | ShopifyVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ShopifyVariantCreateManyProductInputEnvelope
    set?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
    disconnect?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
    delete?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
    connect?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
    update?: ShopifyVariantUpdateWithWhereUniqueWithoutProductInput | ShopifyVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ShopifyVariantUpdateManyWithWhereWithoutProductInput | ShopifyVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ShopifyVariantScalarWhereInput | ShopifyVariantScalarWhereInput[]
  }

  export type ShopifyVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ShopifyVariantCreateWithoutProductInput, ShopifyVariantUncheckedCreateWithoutProductInput> | ShopifyVariantCreateWithoutProductInput[] | ShopifyVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ShopifyVariantCreateOrConnectWithoutProductInput | ShopifyVariantCreateOrConnectWithoutProductInput[]
    upsert?: ShopifyVariantUpsertWithWhereUniqueWithoutProductInput | ShopifyVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ShopifyVariantCreateManyProductInputEnvelope
    set?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
    disconnect?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
    delete?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
    connect?: ShopifyVariantWhereUniqueInput | ShopifyVariantWhereUniqueInput[]
    update?: ShopifyVariantUpdateWithWhereUniqueWithoutProductInput | ShopifyVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ShopifyVariantUpdateManyWithWhereWithoutProductInput | ShopifyVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ShopifyVariantScalarWhereInput | ShopifyVariantScalarWhereInput[]
  }

  export type ShopifyProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ShopifyProductCreateWithoutVariantsInput, ShopifyProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ShopifyProductCreateOrConnectWithoutVariantsInput
    connect?: ShopifyProductWhereUniqueInput
  }

  export type ShopifyProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ShopifyProductCreateWithoutVariantsInput, ShopifyProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ShopifyProductCreateOrConnectWithoutVariantsInput
    upsert?: ShopifyProductUpsertWithoutVariantsInput
    connect?: ShopifyProductWhereUniqueInput
    update?: XOR<XOR<ShopifyProductUpdateToOneWithWhereWithoutVariantsInput, ShopifyProductUpdateWithoutVariantsInput>, ShopifyProductUncheckedUpdateWithoutVariantsInput>
  }

  export type MachineSensorCreateNestedManyWithoutMachineInput = {
    create?: XOR<MachineSensorCreateWithoutMachineInput, MachineSensorUncheckedCreateWithoutMachineInput> | MachineSensorCreateWithoutMachineInput[] | MachineSensorUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineSensorCreateOrConnectWithoutMachineInput | MachineSensorCreateOrConnectWithoutMachineInput[]
    createMany?: MachineSensorCreateManyMachineInputEnvelope
    connect?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
  }

  export type MachineAlertCreateNestedManyWithoutMachineInput = {
    create?: XOR<MachineAlertCreateWithoutMachineInput, MachineAlertUncheckedCreateWithoutMachineInput> | MachineAlertCreateWithoutMachineInput[] | MachineAlertUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineAlertCreateOrConnectWithoutMachineInput | MachineAlertCreateOrConnectWithoutMachineInput[]
    createMany?: MachineAlertCreateManyMachineInputEnvelope
    connect?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
  }

  export type MachineMaintenanceRecordCreateNestedManyWithoutMachineInput = {
    create?: XOR<MachineMaintenanceRecordCreateWithoutMachineInput, MachineMaintenanceRecordUncheckedCreateWithoutMachineInput> | MachineMaintenanceRecordCreateWithoutMachineInput[] | MachineMaintenanceRecordUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineMaintenanceRecordCreateOrConnectWithoutMachineInput | MachineMaintenanceRecordCreateOrConnectWithoutMachineInput[]
    createMany?: MachineMaintenanceRecordCreateManyMachineInputEnvelope
    connect?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
  }

  export type MachineSensorUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<MachineSensorCreateWithoutMachineInput, MachineSensorUncheckedCreateWithoutMachineInput> | MachineSensorCreateWithoutMachineInput[] | MachineSensorUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineSensorCreateOrConnectWithoutMachineInput | MachineSensorCreateOrConnectWithoutMachineInput[]
    createMany?: MachineSensorCreateManyMachineInputEnvelope
    connect?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
  }

  export type MachineAlertUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<MachineAlertCreateWithoutMachineInput, MachineAlertUncheckedCreateWithoutMachineInput> | MachineAlertCreateWithoutMachineInput[] | MachineAlertUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineAlertCreateOrConnectWithoutMachineInput | MachineAlertCreateOrConnectWithoutMachineInput[]
    createMany?: MachineAlertCreateManyMachineInputEnvelope
    connect?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
  }

  export type MachineMaintenanceRecordUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<MachineMaintenanceRecordCreateWithoutMachineInput, MachineMaintenanceRecordUncheckedCreateWithoutMachineInput> | MachineMaintenanceRecordCreateWithoutMachineInput[] | MachineMaintenanceRecordUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineMaintenanceRecordCreateOrConnectWithoutMachineInput | MachineMaintenanceRecordCreateOrConnectWithoutMachineInput[]
    createMany?: MachineMaintenanceRecordCreateManyMachineInputEnvelope
    connect?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
  }

  export type MachineSensorUpdateManyWithoutMachineNestedInput = {
    create?: XOR<MachineSensorCreateWithoutMachineInput, MachineSensorUncheckedCreateWithoutMachineInput> | MachineSensorCreateWithoutMachineInput[] | MachineSensorUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineSensorCreateOrConnectWithoutMachineInput | MachineSensorCreateOrConnectWithoutMachineInput[]
    upsert?: MachineSensorUpsertWithWhereUniqueWithoutMachineInput | MachineSensorUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: MachineSensorCreateManyMachineInputEnvelope
    set?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
    disconnect?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
    delete?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
    connect?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
    update?: MachineSensorUpdateWithWhereUniqueWithoutMachineInput | MachineSensorUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: MachineSensorUpdateManyWithWhereWithoutMachineInput | MachineSensorUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: MachineSensorScalarWhereInput | MachineSensorScalarWhereInput[]
  }

  export type MachineAlertUpdateManyWithoutMachineNestedInput = {
    create?: XOR<MachineAlertCreateWithoutMachineInput, MachineAlertUncheckedCreateWithoutMachineInput> | MachineAlertCreateWithoutMachineInput[] | MachineAlertUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineAlertCreateOrConnectWithoutMachineInput | MachineAlertCreateOrConnectWithoutMachineInput[]
    upsert?: MachineAlertUpsertWithWhereUniqueWithoutMachineInput | MachineAlertUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: MachineAlertCreateManyMachineInputEnvelope
    set?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
    disconnect?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
    delete?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
    connect?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
    update?: MachineAlertUpdateWithWhereUniqueWithoutMachineInput | MachineAlertUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: MachineAlertUpdateManyWithWhereWithoutMachineInput | MachineAlertUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: MachineAlertScalarWhereInput | MachineAlertScalarWhereInput[]
  }

  export type MachineMaintenanceRecordUpdateManyWithoutMachineNestedInput = {
    create?: XOR<MachineMaintenanceRecordCreateWithoutMachineInput, MachineMaintenanceRecordUncheckedCreateWithoutMachineInput> | MachineMaintenanceRecordCreateWithoutMachineInput[] | MachineMaintenanceRecordUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineMaintenanceRecordCreateOrConnectWithoutMachineInput | MachineMaintenanceRecordCreateOrConnectWithoutMachineInput[]
    upsert?: MachineMaintenanceRecordUpsertWithWhereUniqueWithoutMachineInput | MachineMaintenanceRecordUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: MachineMaintenanceRecordCreateManyMachineInputEnvelope
    set?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
    disconnect?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
    delete?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
    connect?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
    update?: MachineMaintenanceRecordUpdateWithWhereUniqueWithoutMachineInput | MachineMaintenanceRecordUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: MachineMaintenanceRecordUpdateManyWithWhereWithoutMachineInput | MachineMaintenanceRecordUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: MachineMaintenanceRecordScalarWhereInput | MachineMaintenanceRecordScalarWhereInput[]
  }

  export type MachineSensorUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<MachineSensorCreateWithoutMachineInput, MachineSensorUncheckedCreateWithoutMachineInput> | MachineSensorCreateWithoutMachineInput[] | MachineSensorUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineSensorCreateOrConnectWithoutMachineInput | MachineSensorCreateOrConnectWithoutMachineInput[]
    upsert?: MachineSensorUpsertWithWhereUniqueWithoutMachineInput | MachineSensorUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: MachineSensorCreateManyMachineInputEnvelope
    set?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
    disconnect?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
    delete?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
    connect?: MachineSensorWhereUniqueInput | MachineSensorWhereUniqueInput[]
    update?: MachineSensorUpdateWithWhereUniqueWithoutMachineInput | MachineSensorUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: MachineSensorUpdateManyWithWhereWithoutMachineInput | MachineSensorUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: MachineSensorScalarWhereInput | MachineSensorScalarWhereInput[]
  }

  export type MachineAlertUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<MachineAlertCreateWithoutMachineInput, MachineAlertUncheckedCreateWithoutMachineInput> | MachineAlertCreateWithoutMachineInput[] | MachineAlertUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineAlertCreateOrConnectWithoutMachineInput | MachineAlertCreateOrConnectWithoutMachineInput[]
    upsert?: MachineAlertUpsertWithWhereUniqueWithoutMachineInput | MachineAlertUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: MachineAlertCreateManyMachineInputEnvelope
    set?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
    disconnect?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
    delete?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
    connect?: MachineAlertWhereUniqueInput | MachineAlertWhereUniqueInput[]
    update?: MachineAlertUpdateWithWhereUniqueWithoutMachineInput | MachineAlertUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: MachineAlertUpdateManyWithWhereWithoutMachineInput | MachineAlertUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: MachineAlertScalarWhereInput | MachineAlertScalarWhereInput[]
  }

  export type MachineMaintenanceRecordUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<MachineMaintenanceRecordCreateWithoutMachineInput, MachineMaintenanceRecordUncheckedCreateWithoutMachineInput> | MachineMaintenanceRecordCreateWithoutMachineInput[] | MachineMaintenanceRecordUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: MachineMaintenanceRecordCreateOrConnectWithoutMachineInput | MachineMaintenanceRecordCreateOrConnectWithoutMachineInput[]
    upsert?: MachineMaintenanceRecordUpsertWithWhereUniqueWithoutMachineInput | MachineMaintenanceRecordUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: MachineMaintenanceRecordCreateManyMachineInputEnvelope
    set?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
    disconnect?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
    delete?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
    connect?: MachineMaintenanceRecordWhereUniqueInput | MachineMaintenanceRecordWhereUniqueInput[]
    update?: MachineMaintenanceRecordUpdateWithWhereUniqueWithoutMachineInput | MachineMaintenanceRecordUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: MachineMaintenanceRecordUpdateManyWithWhereWithoutMachineInput | MachineMaintenanceRecordUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: MachineMaintenanceRecordScalarWhereInput | MachineMaintenanceRecordScalarWhereInput[]
  }

  export type MachineCreateNestedOneWithoutSensorsInput = {
    create?: XOR<MachineCreateWithoutSensorsInput, MachineUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutSensorsInput
    connect?: MachineWhereUniqueInput
  }

  export type MachineUpdateOneRequiredWithoutSensorsNestedInput = {
    create?: XOR<MachineCreateWithoutSensorsInput, MachineUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutSensorsInput
    upsert?: MachineUpsertWithoutSensorsInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutSensorsInput, MachineUpdateWithoutSensorsInput>, MachineUncheckedUpdateWithoutSensorsInput>
  }

  export type MachineCreateNestedOneWithoutAlertsInput = {
    create?: XOR<MachineCreateWithoutAlertsInput, MachineUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutAlertsInput
    connect?: MachineWhereUniqueInput
  }

  export type MachineUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<MachineCreateWithoutAlertsInput, MachineUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutAlertsInput
    upsert?: MachineUpsertWithoutAlertsInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutAlertsInput, MachineUpdateWithoutAlertsInput>, MachineUncheckedUpdateWithoutAlertsInput>
  }

  export type MachineMaintenanceRecordCreateattachmentsInput = {
    set: string[]
  }

  export type MachineCreateNestedOneWithoutMaintenanceRecordsInput = {
    create?: XOR<MachineCreateWithoutMaintenanceRecordsInput, MachineUncheckedCreateWithoutMaintenanceRecordsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutMaintenanceRecordsInput
    connect?: MachineWhereUniqueInput
  }

  export type MachineMaintenanceRecordUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MachineUpdateOneRequiredWithoutMaintenanceRecordsNestedInput = {
    create?: XOR<MachineCreateWithoutMaintenanceRecordsInput, MachineUncheckedCreateWithoutMaintenanceRecordsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutMaintenanceRecordsInput
    upsert?: MachineUpsertWithoutMaintenanceRecordsInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutMaintenanceRecordsInput, MachineUpdateWithoutMaintenanceRecordsInput>, MachineUncheckedUpdateWithoutMaintenanceRecordsInput>
  }

  export type QualityCheckCreateattachmentsInput = {
    set: string[]
  }

  export type ProductionCreateNestedOneWithoutQualityChecksInput = {
    create?: XOR<ProductionCreateWithoutQualityChecksInput, ProductionUncheckedCreateWithoutQualityChecksInput>
    connectOrCreate?: ProductionCreateOrConnectWithoutQualityChecksInput
    connect?: ProductionWhereUniqueInput
  }

  export type QualityCheckUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProductionUpdateOneWithoutQualityChecksNestedInput = {
    create?: XOR<ProductionCreateWithoutQualityChecksInput, ProductionUncheckedCreateWithoutQualityChecksInput>
    connectOrCreate?: ProductionCreateOrConnectWithoutQualityChecksInput
    upsert?: ProductionUpsertWithoutQualityChecksInput
    disconnect?: ProductionWhereInput | boolean
    delete?: ProductionWhereInput | boolean
    connect?: ProductionWhereUniqueInput
    update?: XOR<XOR<ProductionUpdateToOneWithWhereWithoutQualityChecksInput, ProductionUpdateWithoutQualityChecksInput>, ProductionUncheckedUpdateWithoutQualityChecksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumProductionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusFilter<$PrismaModel> | $Enums.ProductionStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionStatus | EnumProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionStatus[] | ListEnumProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductionStatusFilter<$PrismaModel>
    _max?: NestedEnumProductionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DashboardCreateWithoutUserInput = {
    id?: string
    name: string
    type: string
    layout: JsonNullValueInput | InputJsonValue
    widgets: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    type: string
    layout: JsonNullValueInput | InputJsonValue
    widgets: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardCreateOrConnectWithoutUserInput = {
    where: DashboardWhereUniqueInput
    create: XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput>
  }

  export type DashboardCreateManyUserInputEnvelope = {
    data: DashboardCreateManyUserInput | DashboardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DashboardUpsertWithWhereUniqueWithoutUserInput = {
    where: DashboardWhereUniqueInput
    update: XOR<DashboardUpdateWithoutUserInput, DashboardUncheckedUpdateWithoutUserInput>
    create: XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput>
  }

  export type DashboardUpdateWithWhereUniqueWithoutUserInput = {
    where: DashboardWhereUniqueInput
    data: XOR<DashboardUpdateWithoutUserInput, DashboardUncheckedUpdateWithoutUserInput>
  }

  export type DashboardUpdateManyWithWhereWithoutUserInput = {
    where: DashboardScalarWhereInput
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyWithoutUserInput>
  }

  export type DashboardScalarWhereInput = {
    AND?: DashboardScalarWhereInput | DashboardScalarWhereInput[]
    OR?: DashboardScalarWhereInput[]
    NOT?: DashboardScalarWhereInput | DashboardScalarWhereInput[]
    id?: StringFilter<"Dashboard"> | string
    userId?: StringFilter<"Dashboard"> | string
    name?: StringFilter<"Dashboard"> | string
    type?: StringFilter<"Dashboard"> | string
    layout?: JsonFilter<"Dashboard">
    widgets?: JsonFilter<"Dashboard">
    isDefault?: BoolFilter<"Dashboard"> | boolean
    createdAt?: DateTimeFilter<"Dashboard"> | Date | string
    updatedAt?: DateTimeFilter<"Dashboard"> | Date | string
  }

  export type QualityCheckCreateWithoutProductionInput = {
    id?: string
    checkType: string
    checkDate?: Date | string
    inspector?: string | null
    passed: boolean
    score?: number | null
    defectCount?: number
    sampleSize?: number | null
    notes?: string | null
    corrective?: string | null
    attachments?: QualityCheckCreateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QualityCheckUncheckedCreateWithoutProductionInput = {
    id?: string
    checkType: string
    checkDate?: Date | string
    inspector?: string | null
    passed: boolean
    score?: number | null
    defectCount?: number
    sampleSize?: number | null
    notes?: string | null
    corrective?: string | null
    attachments?: QualityCheckCreateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QualityCheckCreateOrConnectWithoutProductionInput = {
    where: QualityCheckWhereUniqueInput
    create: XOR<QualityCheckCreateWithoutProductionInput, QualityCheckUncheckedCreateWithoutProductionInput>
  }

  export type QualityCheckCreateManyProductionInputEnvelope = {
    data: QualityCheckCreateManyProductionInput | QualityCheckCreateManyProductionInput[]
    skipDuplicates?: boolean
  }

  export type QualityCheckUpsertWithWhereUniqueWithoutProductionInput = {
    where: QualityCheckWhereUniqueInput
    update: XOR<QualityCheckUpdateWithoutProductionInput, QualityCheckUncheckedUpdateWithoutProductionInput>
    create: XOR<QualityCheckCreateWithoutProductionInput, QualityCheckUncheckedCreateWithoutProductionInput>
  }

  export type QualityCheckUpdateWithWhereUniqueWithoutProductionInput = {
    where: QualityCheckWhereUniqueInput
    data: XOR<QualityCheckUpdateWithoutProductionInput, QualityCheckUncheckedUpdateWithoutProductionInput>
  }

  export type QualityCheckUpdateManyWithWhereWithoutProductionInput = {
    where: QualityCheckScalarWhereInput
    data: XOR<QualityCheckUpdateManyMutationInput, QualityCheckUncheckedUpdateManyWithoutProductionInput>
  }

  export type QualityCheckScalarWhereInput = {
    AND?: QualityCheckScalarWhereInput | QualityCheckScalarWhereInput[]
    OR?: QualityCheckScalarWhereInput[]
    NOT?: QualityCheckScalarWhereInput | QualityCheckScalarWhereInput[]
    id?: StringFilter<"QualityCheck"> | string
    productionId?: StringNullableFilter<"QualityCheck"> | string | null
    checkType?: StringFilter<"QualityCheck"> | string
    checkDate?: DateTimeFilter<"QualityCheck"> | Date | string
    inspector?: StringNullableFilter<"QualityCheck"> | string | null
    passed?: BoolFilter<"QualityCheck"> | boolean
    score?: FloatNullableFilter<"QualityCheck"> | number | null
    defectCount?: IntFilter<"QualityCheck"> | number
    sampleSize?: IntNullableFilter<"QualityCheck"> | number | null
    notes?: StringNullableFilter<"QualityCheck"> | string | null
    corrective?: StringNullableFilter<"QualityCheck"> | string | null
    attachments?: StringNullableListFilter<"QualityCheck">
    metadata?: JsonNullableFilter<"QualityCheck">
    createdAt?: DateTimeFilter<"QualityCheck"> | Date | string
  }

  export type InventoryMovementCreateWithoutInventoryInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    reference?: string | null
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUncheckedCreateWithoutInventoryInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    reference?: string | null
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutInventoryInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryMovementCreateManyInventoryInputEnvelope = {
    data: InventoryMovementCreateManyInventoryInput | InventoryMovementCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutInventoryInput, InventoryMovementUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutInventoryInput, InventoryMovementUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutInventoryInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: StringFilter<"InventoryMovement"> | string
    inventoryId?: StringFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    reason?: StringNullableFilter<"InventoryMovement"> | string | null
    performedBy?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
  }

  export type InventoryCreateWithoutMovementsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    reorderPoint: number
    reorderQuantity: number
    location: string
    warehouse: string
    unitCost: number
    totalValue: number
    lastMovement?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUncheckedCreateWithoutMovementsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    reorderPoint: number
    reorderQuantity: number
    location: string
    warehouse: string
    unitCost: number
    totalValue: number
    lastMovement?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutMovementsInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutMovementsInput, InventoryUncheckedCreateWithoutMovementsInput>
  }

  export type InventoryUpsertWithoutMovementsInput = {
    update: XOR<InventoryUpdateWithoutMovementsInput, InventoryUncheckedUpdateWithoutMovementsInput>
    create: XOR<InventoryCreateWithoutMovementsInput, InventoryUncheckedCreateWithoutMovementsInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutMovementsInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutMovementsInput, InventoryUncheckedUpdateWithoutMovementsInput>
  }

  export type InventoryUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    warehouse?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    lastMovement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQuantity?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    warehouse?: StringFieldUpdateOperationsInput | string
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalValue?: FloatFieldUpdateOperationsInput | number
    lastMovement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutDashboardsInput = {
    id?: string
    email: string
    name?: string | null
    role: $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutDashboardsInput = {
    id?: string
    email: string
    name?: string | null
    role: $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutDashboardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>
  }

  export type UserUpsertWithoutDashboardsInput = {
    update: XOR<UserUpdateWithoutDashboardsInput, UserUncheckedUpdateWithoutDashboardsInput>
    create: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDashboardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDashboardsInput, UserUncheckedUpdateWithoutDashboardsInput>
  }

  export type UserUpdateWithoutDashboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutDashboardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroInvoiceCreateWithoutContactInput = {
    id?: string
    xeroId: string
    invoiceNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: XeroPaymentCreateNestedManyWithoutInvoiceInput
  }

  export type XeroInvoiceUncheckedCreateWithoutContactInput = {
    id?: string
    xeroId: string
    invoiceNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: XeroPaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type XeroInvoiceCreateOrConnectWithoutContactInput = {
    where: XeroInvoiceWhereUniqueInput
    create: XOR<XeroInvoiceCreateWithoutContactInput, XeroInvoiceUncheckedCreateWithoutContactInput>
  }

  export type XeroInvoiceCreateManyContactInputEnvelope = {
    data: XeroInvoiceCreateManyContactInput | XeroInvoiceCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type XeroBillCreateWithoutContactInput = {
    id?: string
    xeroId: string
    billNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: XeroPaymentCreateNestedManyWithoutBillInput
  }

  export type XeroBillUncheckedCreateWithoutContactInput = {
    id?: string
    xeroId: string
    billNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: XeroPaymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type XeroBillCreateOrConnectWithoutContactInput = {
    where: XeroBillWhereUniqueInput
    create: XOR<XeroBillCreateWithoutContactInput, XeroBillUncheckedCreateWithoutContactInput>
  }

  export type XeroBillCreateManyContactInputEnvelope = {
    data: XeroBillCreateManyContactInput | XeroBillCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type XeroPaymentCreateWithoutContactInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: XeroInvoiceCreateNestedOneWithoutPaymentsInput
    bill?: XeroBillCreateNestedOneWithoutPaymentsInput
  }

  export type XeroPaymentUncheckedCreateWithoutContactInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    invoiceId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroPaymentCreateOrConnectWithoutContactInput = {
    where: XeroPaymentWhereUniqueInput
    create: XOR<XeroPaymentCreateWithoutContactInput, XeroPaymentUncheckedCreateWithoutContactInput>
  }

  export type XeroPaymentCreateManyContactInputEnvelope = {
    data: XeroPaymentCreateManyContactInput | XeroPaymentCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type XeroInvoiceUpsertWithWhereUniqueWithoutContactInput = {
    where: XeroInvoiceWhereUniqueInput
    update: XOR<XeroInvoiceUpdateWithoutContactInput, XeroInvoiceUncheckedUpdateWithoutContactInput>
    create: XOR<XeroInvoiceCreateWithoutContactInput, XeroInvoiceUncheckedCreateWithoutContactInput>
  }

  export type XeroInvoiceUpdateWithWhereUniqueWithoutContactInput = {
    where: XeroInvoiceWhereUniqueInput
    data: XOR<XeroInvoiceUpdateWithoutContactInput, XeroInvoiceUncheckedUpdateWithoutContactInput>
  }

  export type XeroInvoiceUpdateManyWithWhereWithoutContactInput = {
    where: XeroInvoiceScalarWhereInput
    data: XOR<XeroInvoiceUpdateManyMutationInput, XeroInvoiceUncheckedUpdateManyWithoutContactInput>
  }

  export type XeroInvoiceScalarWhereInput = {
    AND?: XeroInvoiceScalarWhereInput | XeroInvoiceScalarWhereInput[]
    OR?: XeroInvoiceScalarWhereInput[]
    NOT?: XeroInvoiceScalarWhereInput | XeroInvoiceScalarWhereInput[]
    id?: StringFilter<"XeroInvoice"> | string
    xeroId?: StringFilter<"XeroInvoice"> | string
    invoiceNumber?: StringNullableFilter<"XeroInvoice"> | string | null
    reference?: StringNullableFilter<"XeroInvoice"> | string | null
    type?: StringFilter<"XeroInvoice"> | string
    contactId?: StringFilter<"XeroInvoice"> | string
    date?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    status?: StringFilter<"XeroInvoice"> | string
    lineAmountTypes?: StringNullableFilter<"XeroInvoice"> | string | null
    subTotal?: FloatNullableFilter<"XeroInvoice"> | number | null
    totalTax?: FloatNullableFilter<"XeroInvoice"> | number | null
    total?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountDue?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountPaid?: FloatNullableFilter<"XeroInvoice"> | number | null
    amountCredited?: FloatNullableFilter<"XeroInvoice"> | number | null
    currencyCode?: StringFilter<"XeroInvoice"> | string
    fullyPaidOnDate?: DateTimeNullableFilter<"XeroInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"XeroInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"XeroInvoice"> | Date | string
  }

  export type XeroBillUpsertWithWhereUniqueWithoutContactInput = {
    where: XeroBillWhereUniqueInput
    update: XOR<XeroBillUpdateWithoutContactInput, XeroBillUncheckedUpdateWithoutContactInput>
    create: XOR<XeroBillCreateWithoutContactInput, XeroBillUncheckedCreateWithoutContactInput>
  }

  export type XeroBillUpdateWithWhereUniqueWithoutContactInput = {
    where: XeroBillWhereUniqueInput
    data: XOR<XeroBillUpdateWithoutContactInput, XeroBillUncheckedUpdateWithoutContactInput>
  }

  export type XeroBillUpdateManyWithWhereWithoutContactInput = {
    where: XeroBillScalarWhereInput
    data: XOR<XeroBillUpdateManyMutationInput, XeroBillUncheckedUpdateManyWithoutContactInput>
  }

  export type XeroBillScalarWhereInput = {
    AND?: XeroBillScalarWhereInput | XeroBillScalarWhereInput[]
    OR?: XeroBillScalarWhereInput[]
    NOT?: XeroBillScalarWhereInput | XeroBillScalarWhereInput[]
    id?: StringFilter<"XeroBill"> | string
    xeroId?: StringFilter<"XeroBill"> | string
    billNumber?: StringNullableFilter<"XeroBill"> | string | null
    reference?: StringNullableFilter<"XeroBill"> | string | null
    type?: StringFilter<"XeroBill"> | string
    contactId?: StringFilter<"XeroBill"> | string
    date?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    status?: StringFilter<"XeroBill"> | string
    lineAmountTypes?: StringNullableFilter<"XeroBill"> | string | null
    subTotal?: FloatNullableFilter<"XeroBill"> | number | null
    totalTax?: FloatNullableFilter<"XeroBill"> | number | null
    total?: FloatNullableFilter<"XeroBill"> | number | null
    amountDue?: FloatNullableFilter<"XeroBill"> | number | null
    amountPaid?: FloatNullableFilter<"XeroBill"> | number | null
    amountCredited?: FloatNullableFilter<"XeroBill"> | number | null
    currencyCode?: StringFilter<"XeroBill"> | string
    fullyPaidOnDate?: DateTimeNullableFilter<"XeroBill"> | Date | string | null
    createdAt?: DateTimeFilter<"XeroBill"> | Date | string
    updatedAt?: DateTimeFilter<"XeroBill"> | Date | string
  }

  export type XeroPaymentUpsertWithWhereUniqueWithoutContactInput = {
    where: XeroPaymentWhereUniqueInput
    update: XOR<XeroPaymentUpdateWithoutContactInput, XeroPaymentUncheckedUpdateWithoutContactInput>
    create: XOR<XeroPaymentCreateWithoutContactInput, XeroPaymentUncheckedCreateWithoutContactInput>
  }

  export type XeroPaymentUpdateWithWhereUniqueWithoutContactInput = {
    where: XeroPaymentWhereUniqueInput
    data: XOR<XeroPaymentUpdateWithoutContactInput, XeroPaymentUncheckedUpdateWithoutContactInput>
  }

  export type XeroPaymentUpdateManyWithWhereWithoutContactInput = {
    where: XeroPaymentScalarWhereInput
    data: XOR<XeroPaymentUpdateManyMutationInput, XeroPaymentUncheckedUpdateManyWithoutContactInput>
  }

  export type XeroPaymentScalarWhereInput = {
    AND?: XeroPaymentScalarWhereInput | XeroPaymentScalarWhereInput[]
    OR?: XeroPaymentScalarWhereInput[]
    NOT?: XeroPaymentScalarWhereInput | XeroPaymentScalarWhereInput[]
    id?: StringFilter<"XeroPayment"> | string
    xeroId?: StringFilter<"XeroPayment"> | string
    date?: DateTimeNullableFilter<"XeroPayment"> | Date | string | null
    amount?: FloatNullableFilter<"XeroPayment"> | number | null
    currencyCode?: StringFilter<"XeroPayment"> | string
    paymentType?: StringNullableFilter<"XeroPayment"> | string | null
    status?: StringNullableFilter<"XeroPayment"> | string | null
    isReconciled?: BoolFilter<"XeroPayment"> | boolean
    reference?: StringNullableFilter<"XeroPayment"> | string | null
    batchPaymentId?: StringNullableFilter<"XeroPayment"> | string | null
    contactId?: StringNullableFilter<"XeroPayment"> | string | null
    invoiceId?: StringNullableFilter<"XeroPayment"> | string | null
    billId?: StringNullableFilter<"XeroPayment"> | string | null
    createdAt?: DateTimeFilter<"XeroPayment"> | Date | string
    updatedAt?: DateTimeFilter<"XeroPayment"> | Date | string
  }

  export type XeroContactCreateWithoutInvoicesInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: XeroBillCreateNestedManyWithoutContactInput
    payments?: XeroPaymentCreateNestedManyWithoutContactInput
  }

  export type XeroContactUncheckedCreateWithoutInvoicesInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: XeroBillUncheckedCreateNestedManyWithoutContactInput
    payments?: XeroPaymentUncheckedCreateNestedManyWithoutContactInput
  }

  export type XeroContactCreateOrConnectWithoutInvoicesInput = {
    where: XeroContactWhereUniqueInput
    create: XOR<XeroContactCreateWithoutInvoicesInput, XeroContactUncheckedCreateWithoutInvoicesInput>
  }

  export type XeroPaymentCreateWithoutInvoiceInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: XeroContactCreateNestedOneWithoutPaymentsInput
    bill?: XeroBillCreateNestedOneWithoutPaymentsInput
  }

  export type XeroPaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    contactId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroPaymentCreateOrConnectWithoutInvoiceInput = {
    where: XeroPaymentWhereUniqueInput
    create: XOR<XeroPaymentCreateWithoutInvoiceInput, XeroPaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type XeroPaymentCreateManyInvoiceInputEnvelope = {
    data: XeroPaymentCreateManyInvoiceInput | XeroPaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type XeroContactUpsertWithoutInvoicesInput = {
    update: XOR<XeroContactUpdateWithoutInvoicesInput, XeroContactUncheckedUpdateWithoutInvoicesInput>
    create: XOR<XeroContactCreateWithoutInvoicesInput, XeroContactUncheckedCreateWithoutInvoicesInput>
    where?: XeroContactWhereInput
  }

  export type XeroContactUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: XeroContactWhereInput
    data: XOR<XeroContactUpdateWithoutInvoicesInput, XeroContactUncheckedUpdateWithoutInvoicesInput>
  }

  export type XeroContactUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: XeroBillUpdateManyWithoutContactNestedInput
    payments?: XeroPaymentUpdateManyWithoutContactNestedInput
  }

  export type XeroContactUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: XeroBillUncheckedUpdateManyWithoutContactNestedInput
    payments?: XeroPaymentUncheckedUpdateManyWithoutContactNestedInput
  }

  export type XeroPaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: XeroPaymentWhereUniqueInput
    update: XOR<XeroPaymentUpdateWithoutInvoiceInput, XeroPaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<XeroPaymentCreateWithoutInvoiceInput, XeroPaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type XeroPaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: XeroPaymentWhereUniqueInput
    data: XOR<XeroPaymentUpdateWithoutInvoiceInput, XeroPaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type XeroPaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: XeroPaymentScalarWhereInput
    data: XOR<XeroPaymentUpdateManyMutationInput, XeroPaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type XeroContactCreateWithoutBillsInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: XeroInvoiceCreateNestedManyWithoutContactInput
    payments?: XeroPaymentCreateNestedManyWithoutContactInput
  }

  export type XeroContactUncheckedCreateWithoutBillsInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: XeroInvoiceUncheckedCreateNestedManyWithoutContactInput
    payments?: XeroPaymentUncheckedCreateNestedManyWithoutContactInput
  }

  export type XeroContactCreateOrConnectWithoutBillsInput = {
    where: XeroContactWhereUniqueInput
    create: XOR<XeroContactCreateWithoutBillsInput, XeroContactUncheckedCreateWithoutBillsInput>
  }

  export type XeroPaymentCreateWithoutBillInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: XeroContactCreateNestedOneWithoutPaymentsInput
    invoice?: XeroInvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type XeroPaymentUncheckedCreateWithoutBillInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    contactId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroPaymentCreateOrConnectWithoutBillInput = {
    where: XeroPaymentWhereUniqueInput
    create: XOR<XeroPaymentCreateWithoutBillInput, XeroPaymentUncheckedCreateWithoutBillInput>
  }

  export type XeroPaymentCreateManyBillInputEnvelope = {
    data: XeroPaymentCreateManyBillInput | XeroPaymentCreateManyBillInput[]
    skipDuplicates?: boolean
  }

  export type XeroContactUpsertWithoutBillsInput = {
    update: XOR<XeroContactUpdateWithoutBillsInput, XeroContactUncheckedUpdateWithoutBillsInput>
    create: XOR<XeroContactCreateWithoutBillsInput, XeroContactUncheckedCreateWithoutBillsInput>
    where?: XeroContactWhereInput
  }

  export type XeroContactUpdateToOneWithWhereWithoutBillsInput = {
    where?: XeroContactWhereInput
    data: XOR<XeroContactUpdateWithoutBillsInput, XeroContactUncheckedUpdateWithoutBillsInput>
  }

  export type XeroContactUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: XeroInvoiceUpdateManyWithoutContactNestedInput
    payments?: XeroPaymentUpdateManyWithoutContactNestedInput
  }

  export type XeroContactUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: XeroInvoiceUncheckedUpdateManyWithoutContactNestedInput
    payments?: XeroPaymentUncheckedUpdateManyWithoutContactNestedInput
  }

  export type XeroPaymentUpsertWithWhereUniqueWithoutBillInput = {
    where: XeroPaymentWhereUniqueInput
    update: XOR<XeroPaymentUpdateWithoutBillInput, XeroPaymentUncheckedUpdateWithoutBillInput>
    create: XOR<XeroPaymentCreateWithoutBillInput, XeroPaymentUncheckedCreateWithoutBillInput>
  }

  export type XeroPaymentUpdateWithWhereUniqueWithoutBillInput = {
    where: XeroPaymentWhereUniqueInput
    data: XOR<XeroPaymentUpdateWithoutBillInput, XeroPaymentUncheckedUpdateWithoutBillInput>
  }

  export type XeroPaymentUpdateManyWithWhereWithoutBillInput = {
    where: XeroPaymentScalarWhereInput
    data: XOR<XeroPaymentUpdateManyMutationInput, XeroPaymentUncheckedUpdateManyWithoutBillInput>
  }

  export type XeroContactCreateWithoutPaymentsInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: XeroInvoiceCreateNestedManyWithoutContactInput
    bills?: XeroBillCreateNestedManyWithoutContactInput
  }

  export type XeroContactUncheckedCreateWithoutPaymentsInput = {
    id?: string
    xeroId: string
    name: string
    firstName?: string | null
    lastName?: string | null
    emailAddress?: string | null
    contactStatus?: string | null
    isSupplier?: boolean
    isCustomer?: boolean
    defaultCurrency?: string | null
    accountNumber?: string | null
    companyNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: XeroInvoiceUncheckedCreateNestedManyWithoutContactInput
    bills?: XeroBillUncheckedCreateNestedManyWithoutContactInput
  }

  export type XeroContactCreateOrConnectWithoutPaymentsInput = {
    where: XeroContactWhereUniqueInput
    create: XOR<XeroContactCreateWithoutPaymentsInput, XeroContactUncheckedCreateWithoutPaymentsInput>
  }

  export type XeroInvoiceCreateWithoutPaymentsInput = {
    id?: string
    xeroId: string
    invoiceNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: XeroContactCreateNestedOneWithoutInvoicesInput
  }

  export type XeroInvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    xeroId: string
    invoiceNumber?: string | null
    reference?: string | null
    type: string
    contactId: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroInvoiceCreateOrConnectWithoutPaymentsInput = {
    where: XeroInvoiceWhereUniqueInput
    create: XOR<XeroInvoiceCreateWithoutPaymentsInput, XeroInvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type XeroBillCreateWithoutPaymentsInput = {
    id?: string
    xeroId: string
    billNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: XeroContactCreateNestedOneWithoutBillsInput
  }

  export type XeroBillUncheckedCreateWithoutPaymentsInput = {
    id?: string
    xeroId: string
    billNumber?: string | null
    reference?: string | null
    type: string
    contactId: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroBillCreateOrConnectWithoutPaymentsInput = {
    where: XeroBillWhereUniqueInput
    create: XOR<XeroBillCreateWithoutPaymentsInput, XeroBillUncheckedCreateWithoutPaymentsInput>
  }

  export type XeroContactUpsertWithoutPaymentsInput = {
    update: XOR<XeroContactUpdateWithoutPaymentsInput, XeroContactUncheckedUpdateWithoutPaymentsInput>
    create: XOR<XeroContactCreateWithoutPaymentsInput, XeroContactUncheckedCreateWithoutPaymentsInput>
    where?: XeroContactWhereInput
  }

  export type XeroContactUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: XeroContactWhereInput
    data: XOR<XeroContactUpdateWithoutPaymentsInput, XeroContactUncheckedUpdateWithoutPaymentsInput>
  }

  export type XeroContactUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: XeroInvoiceUpdateManyWithoutContactNestedInput
    bills?: XeroBillUpdateManyWithoutContactNestedInput
  }

  export type XeroContactUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    emailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contactStatus?: NullableStringFieldUpdateOperationsInput | string | null
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    defaultCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: XeroInvoiceUncheckedUpdateManyWithoutContactNestedInput
    bills?: XeroBillUncheckedUpdateManyWithoutContactNestedInput
  }

  export type XeroInvoiceUpsertWithoutPaymentsInput = {
    update: XOR<XeroInvoiceUpdateWithoutPaymentsInput, XeroInvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<XeroInvoiceCreateWithoutPaymentsInput, XeroInvoiceUncheckedCreateWithoutPaymentsInput>
    where?: XeroInvoiceWhereInput
  }

  export type XeroInvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: XeroInvoiceWhereInput
    data: XOR<XeroInvoiceUpdateWithoutPaymentsInput, XeroInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type XeroInvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: XeroContactUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type XeroInvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroBillUpsertWithoutPaymentsInput = {
    update: XOR<XeroBillUpdateWithoutPaymentsInput, XeroBillUncheckedUpdateWithoutPaymentsInput>
    create: XOR<XeroBillCreateWithoutPaymentsInput, XeroBillUncheckedCreateWithoutPaymentsInput>
    where?: XeroBillWhereInput
  }

  export type XeroBillUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: XeroBillWhereInput
    data: XOR<XeroBillUpdateWithoutPaymentsInput, XeroBillUncheckedUpdateWithoutPaymentsInput>
  }

  export type XeroBillUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: XeroContactUpdateOneRequiredWithoutBillsNestedInput
  }

  export type XeroBillUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderItemCreateWithoutOrderInput = {
    id?: string
    orderItemId: string
    asin: string
    sellerSKU?: string | null
    title?: string | null
    quantityOrdered: number
    quantityShipped?: number
    itemPrice?: number | null
    itemTax?: number | null
    shippingPrice?: number | null
    shippingTax?: number | null
    giftWrapPrice?: number | null
    giftWrapTax?: number | null
    itemPromotionDiscount?: number | null
    shipPromotionDiscount?: number | null
    currency?: string
    conditionNote?: string | null
    conditionId?: string | null
    conditionSubtypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonOrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    orderItemId: string
    asin: string
    sellerSKU?: string | null
    title?: string | null
    quantityOrdered: number
    quantityShipped?: number
    itemPrice?: number | null
    itemTax?: number | null
    shippingPrice?: number | null
    shippingTax?: number | null
    giftWrapPrice?: number | null
    giftWrapTax?: number | null
    itemPromotionDiscount?: number | null
    shipPromotionDiscount?: number | null
    currency?: string
    conditionNote?: string | null
    conditionId?: string | null
    conditionSubtypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonOrderItemCreateOrConnectWithoutOrderInput = {
    where: AmazonOrderItemWhereUniqueInput
    create: XOR<AmazonOrderItemCreateWithoutOrderInput, AmazonOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type AmazonOrderItemCreateManyOrderInputEnvelope = {
    data: AmazonOrderItemCreateManyOrderInput | AmazonOrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type AmazonOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: AmazonOrderItemWhereUniqueInput
    update: XOR<AmazonOrderItemUpdateWithoutOrderInput, AmazonOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<AmazonOrderItemCreateWithoutOrderInput, AmazonOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type AmazonOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: AmazonOrderItemWhereUniqueInput
    data: XOR<AmazonOrderItemUpdateWithoutOrderInput, AmazonOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type AmazonOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: AmazonOrderItemScalarWhereInput
    data: XOR<AmazonOrderItemUpdateManyMutationInput, AmazonOrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type AmazonOrderItemScalarWhereInput = {
    AND?: AmazonOrderItemScalarWhereInput | AmazonOrderItemScalarWhereInput[]
    OR?: AmazonOrderItemScalarWhereInput[]
    NOT?: AmazonOrderItemScalarWhereInput | AmazonOrderItemScalarWhereInput[]
    id?: StringFilter<"AmazonOrderItem"> | string
    orderItemId?: StringFilter<"AmazonOrderItem"> | string
    amazonOrderId?: StringFilter<"AmazonOrderItem"> | string
    asin?: StringFilter<"AmazonOrderItem"> | string
    sellerSKU?: StringNullableFilter<"AmazonOrderItem"> | string | null
    title?: StringNullableFilter<"AmazonOrderItem"> | string | null
    quantityOrdered?: IntFilter<"AmazonOrderItem"> | number
    quantityShipped?: IntFilter<"AmazonOrderItem"> | number
    itemPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    itemTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shippingPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shippingTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    giftWrapPrice?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    giftWrapTax?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    itemPromotionDiscount?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    shipPromotionDiscount?: FloatNullableFilter<"AmazonOrderItem"> | number | null
    currency?: StringFilter<"AmazonOrderItem"> | string
    conditionNote?: StringNullableFilter<"AmazonOrderItem"> | string | null
    conditionId?: StringNullableFilter<"AmazonOrderItem"> | string | null
    conditionSubtypeId?: StringNullableFilter<"AmazonOrderItem"> | string | null
    createdAt?: DateTimeFilter<"AmazonOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"AmazonOrderItem"> | Date | string
  }

  export type AmazonOrderCreateWithoutOrderItemsInput = {
    id?: string
    amazonOrderId: string
    marketplace: string
    orderStatus: string
    fulfillmentChannel?: string | null
    salesChannel?: string | null
    orderType?: string | null
    purchaseDate?: Date | string | null
    lastUpdateDate?: Date | string | null
    orderTotal?: number | null
    currency?: string
    numberOfItemsShipped?: number
    numberOfItemsUnshipped?: number
    buyerEmail?: string | null
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonOrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    amazonOrderId: string
    marketplace: string
    orderStatus: string
    fulfillmentChannel?: string | null
    salesChannel?: string | null
    orderType?: string | null
    purchaseDate?: Date | string | null
    lastUpdateDate?: Date | string | null
    orderTotal?: number | null
    currency?: string
    numberOfItemsShipped?: number
    numberOfItemsUnshipped?: number
    buyerEmail?: string | null
    isBusinessOrder?: boolean
    isPrime?: boolean
    isGlobalExpressEnabled?: boolean
    isReplacementOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonOrderCreateOrConnectWithoutOrderItemsInput = {
    where: AmazonOrderWhereUniqueInput
    create: XOR<AmazonOrderCreateWithoutOrderItemsInput, AmazonOrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type AmazonOrderUpsertWithoutOrderItemsInput = {
    update: XOR<AmazonOrderUpdateWithoutOrderItemsInput, AmazonOrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<AmazonOrderCreateWithoutOrderItemsInput, AmazonOrderUncheckedCreateWithoutOrderItemsInput>
    where?: AmazonOrderWhereInput
  }

  export type AmazonOrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: AmazonOrderWhereInput
    data: XOR<AmazonOrderUpdateWithoutOrderItemsInput, AmazonOrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type AmazonOrderUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amazonOrderId?: StringFieldUpdateOperationsInput | string
    marketplace?: StringFieldUpdateOperationsInput | string
    orderStatus?: StringFieldUpdateOperationsInput | string
    fulfillmentChannel?: NullableStringFieldUpdateOperationsInput | string | null
    salesChannel?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    numberOfItemsShipped?: IntFieldUpdateOperationsInput | number
    numberOfItemsUnshipped?: IntFieldUpdateOperationsInput | number
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessOrder?: BoolFieldUpdateOperationsInput | boolean
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    isGlobalExpressEnabled?: BoolFieldUpdateOperationsInput | boolean
    isReplacementOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amazonOrderId?: StringFieldUpdateOperationsInput | string
    marketplace?: StringFieldUpdateOperationsInput | string
    orderStatus?: StringFieldUpdateOperationsInput | string
    fulfillmentChannel?: NullableStringFieldUpdateOperationsInput | string | null
    salesChannel?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    numberOfItemsShipped?: IntFieldUpdateOperationsInput | number
    numberOfItemsUnshipped?: IntFieldUpdateOperationsInput | number
    buyerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    isBusinessOrder?: BoolFieldUpdateOperationsInput | boolean
    isPrime?: BoolFieldUpdateOperationsInput | boolean
    isGlobalExpressEnabled?: BoolFieldUpdateOperationsInput | boolean
    isReplacementOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyLineItemCreateWithoutOrderInput = {
    id?: string
    lineItemId: string
    productId?: string | null
    variantId?: string | null
    title?: string | null
    variantTitle?: string | null
    sku?: string | null
    vendor?: string | null
    quantity: number
    price?: number | null
    totalDiscount?: number | null
    grams?: number | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    fulfillmentStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyLineItemUncheckedCreateWithoutOrderInput = {
    id?: string
    lineItemId: string
    productId?: string | null
    variantId?: string | null
    title?: string | null
    variantTitle?: string | null
    sku?: string | null
    vendor?: string | null
    quantity: number
    price?: number | null
    totalDiscount?: number | null
    grams?: number | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    fulfillmentStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyLineItemCreateOrConnectWithoutOrderInput = {
    where: ShopifyLineItemWhereUniqueInput
    create: XOR<ShopifyLineItemCreateWithoutOrderInput, ShopifyLineItemUncheckedCreateWithoutOrderInput>
  }

  export type ShopifyLineItemCreateManyOrderInputEnvelope = {
    data: ShopifyLineItemCreateManyOrderInput | ShopifyLineItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ShopifyLineItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: ShopifyLineItemWhereUniqueInput
    update: XOR<ShopifyLineItemUpdateWithoutOrderInput, ShopifyLineItemUncheckedUpdateWithoutOrderInput>
    create: XOR<ShopifyLineItemCreateWithoutOrderInput, ShopifyLineItemUncheckedCreateWithoutOrderInput>
  }

  export type ShopifyLineItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: ShopifyLineItemWhereUniqueInput
    data: XOR<ShopifyLineItemUpdateWithoutOrderInput, ShopifyLineItemUncheckedUpdateWithoutOrderInput>
  }

  export type ShopifyLineItemUpdateManyWithWhereWithoutOrderInput = {
    where: ShopifyLineItemScalarWhereInput
    data: XOR<ShopifyLineItemUpdateManyMutationInput, ShopifyLineItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type ShopifyLineItemScalarWhereInput = {
    AND?: ShopifyLineItemScalarWhereInput | ShopifyLineItemScalarWhereInput[]
    OR?: ShopifyLineItemScalarWhereInput[]
    NOT?: ShopifyLineItemScalarWhereInput | ShopifyLineItemScalarWhereInput[]
    id?: StringFilter<"ShopifyLineItem"> | string
    lineItemId?: StringFilter<"ShopifyLineItem"> | string
    shopifyOrderId?: StringFilter<"ShopifyLineItem"> | string
    productId?: StringNullableFilter<"ShopifyLineItem"> | string | null
    variantId?: StringNullableFilter<"ShopifyLineItem"> | string | null
    title?: StringNullableFilter<"ShopifyLineItem"> | string | null
    variantTitle?: StringNullableFilter<"ShopifyLineItem"> | string | null
    sku?: StringNullableFilter<"ShopifyLineItem"> | string | null
    vendor?: StringNullableFilter<"ShopifyLineItem"> | string | null
    quantity?: IntFilter<"ShopifyLineItem"> | number
    price?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    totalDiscount?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    grams?: FloatNullableFilter<"ShopifyLineItem"> | number | null
    requiresShipping?: BoolFilter<"ShopifyLineItem"> | boolean
    taxable?: BoolFilter<"ShopifyLineItem"> | boolean
    fulfillmentService?: StringNullableFilter<"ShopifyLineItem"> | string | null
    fulfillmentStatus?: StringNullableFilter<"ShopifyLineItem"> | string | null
    createdAt?: DateTimeFilter<"ShopifyLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyLineItem"> | Date | string
  }

  export type ShopifyOrderCreateWithoutLineItemsInput = {
    id?: string
    shopifyOrderId: string
    orderNumber?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    financialStatus?: string | null
    fulfillmentStatus?: string | null
    tags?: string | null
    totalPrice?: number | null
    totalTax?: number | null
    totalDiscounts?: number | null
    totalWeight?: number | null
    currency?: string
    processedAt?: Date | string | null
    closedAt?: Date | string | null
    cancelledAt?: Date | string | null
    test?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyOrderUncheckedCreateWithoutLineItemsInput = {
    id?: string
    shopifyOrderId: string
    orderNumber?: string | null
    email?: string | null
    phone?: string | null
    name?: string | null
    financialStatus?: string | null
    fulfillmentStatus?: string | null
    tags?: string | null
    totalPrice?: number | null
    totalTax?: number | null
    totalDiscounts?: number | null
    totalWeight?: number | null
    currency?: string
    processedAt?: Date | string | null
    closedAt?: Date | string | null
    cancelledAt?: Date | string | null
    test?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyOrderCreateOrConnectWithoutLineItemsInput = {
    where: ShopifyOrderWhereUniqueInput
    create: XOR<ShopifyOrderCreateWithoutLineItemsInput, ShopifyOrderUncheckedCreateWithoutLineItemsInput>
  }

  export type ShopifyOrderUpsertWithoutLineItemsInput = {
    update: XOR<ShopifyOrderUpdateWithoutLineItemsInput, ShopifyOrderUncheckedUpdateWithoutLineItemsInput>
    create: XOR<ShopifyOrderCreateWithoutLineItemsInput, ShopifyOrderUncheckedCreateWithoutLineItemsInput>
    where?: ShopifyOrderWhereInput
  }

  export type ShopifyOrderUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: ShopifyOrderWhereInput
    data: XOR<ShopifyOrderUpdateWithoutLineItemsInput, ShopifyOrderUncheckedUpdateWithoutLineItemsInput>
  }

  export type ShopifyOrderUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscounts?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyOrderUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyOrderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    financialStatus?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscounts?: NullableFloatFieldUpdateOperationsInput | number | null
    totalWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyVariantCreateWithoutProductInput = {
    id?: string
    shopifyVariantId: string
    title?: string | null
    price?: number | null
    compareAtPrice?: number | null
    sku?: string | null
    barcode?: string | null
    grams?: number | null
    weight?: number | null
    weightUnit?: string | null
    inventoryQuantity?: number
    inventoryPolicy?: string | null
    inventoryTracking?: string | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyVariantUncheckedCreateWithoutProductInput = {
    id?: string
    shopifyVariantId: string
    title?: string | null
    price?: number | null
    compareAtPrice?: number | null
    sku?: string | null
    barcode?: string | null
    grams?: number | null
    weight?: number | null
    weightUnit?: string | null
    inventoryQuantity?: number
    inventoryPolicy?: string | null
    inventoryTracking?: string | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyVariantCreateOrConnectWithoutProductInput = {
    where: ShopifyVariantWhereUniqueInput
    create: XOR<ShopifyVariantCreateWithoutProductInput, ShopifyVariantUncheckedCreateWithoutProductInput>
  }

  export type ShopifyVariantCreateManyProductInputEnvelope = {
    data: ShopifyVariantCreateManyProductInput | ShopifyVariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ShopifyVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ShopifyVariantWhereUniqueInput
    update: XOR<ShopifyVariantUpdateWithoutProductInput, ShopifyVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ShopifyVariantCreateWithoutProductInput, ShopifyVariantUncheckedCreateWithoutProductInput>
  }

  export type ShopifyVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ShopifyVariantWhereUniqueInput
    data: XOR<ShopifyVariantUpdateWithoutProductInput, ShopifyVariantUncheckedUpdateWithoutProductInput>
  }

  export type ShopifyVariantUpdateManyWithWhereWithoutProductInput = {
    where: ShopifyVariantScalarWhereInput
    data: XOR<ShopifyVariantUpdateManyMutationInput, ShopifyVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type ShopifyVariantScalarWhereInput = {
    AND?: ShopifyVariantScalarWhereInput | ShopifyVariantScalarWhereInput[]
    OR?: ShopifyVariantScalarWhereInput[]
    NOT?: ShopifyVariantScalarWhereInput | ShopifyVariantScalarWhereInput[]
    id?: StringFilter<"ShopifyVariant"> | string
    shopifyVariantId?: StringFilter<"ShopifyVariant"> | string
    shopifyProductId?: StringFilter<"ShopifyVariant"> | string
    title?: StringNullableFilter<"ShopifyVariant"> | string | null
    price?: FloatNullableFilter<"ShopifyVariant"> | number | null
    compareAtPrice?: FloatNullableFilter<"ShopifyVariant"> | number | null
    sku?: StringNullableFilter<"ShopifyVariant"> | string | null
    barcode?: StringNullableFilter<"ShopifyVariant"> | string | null
    grams?: FloatNullableFilter<"ShopifyVariant"> | number | null
    weight?: FloatNullableFilter<"ShopifyVariant"> | number | null
    weightUnit?: StringNullableFilter<"ShopifyVariant"> | string | null
    inventoryQuantity?: IntFilter<"ShopifyVariant"> | number
    inventoryPolicy?: StringNullableFilter<"ShopifyVariant"> | string | null
    inventoryTracking?: StringNullableFilter<"ShopifyVariant"> | string | null
    requiresShipping?: BoolFilter<"ShopifyVariant"> | boolean
    taxable?: BoolFilter<"ShopifyVariant"> | boolean
    fulfillmentService?: StringNullableFilter<"ShopifyVariant"> | string | null
    position?: IntNullableFilter<"ShopifyVariant"> | number | null
    createdAt?: DateTimeFilter<"ShopifyVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ShopifyVariant"> | Date | string
  }

  export type ShopifyProductCreateWithoutVariantsInput = {
    id?: string
    shopifyProductId: string
    title: string
    handle?: string | null
    vendor?: string | null
    productType?: string | null
    tags?: string | null
    status?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    shopifyProductId: string
    title: string
    handle?: string | null
    vendor?: string | null
    productType?: string | null
    tags?: string | null
    status?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyProductCreateOrConnectWithoutVariantsInput = {
    where: ShopifyProductWhereUniqueInput
    create: XOR<ShopifyProductCreateWithoutVariantsInput, ShopifyProductUncheckedCreateWithoutVariantsInput>
  }

  export type ShopifyProductUpsertWithoutVariantsInput = {
    update: XOR<ShopifyProductUpdateWithoutVariantsInput, ShopifyProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ShopifyProductCreateWithoutVariantsInput, ShopifyProductUncheckedCreateWithoutVariantsInput>
    where?: ShopifyProductWhereInput
  }

  export type ShopifyProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ShopifyProductWhereInput
    data: XOR<ShopifyProductUpdateWithoutVariantsInput, ShopifyProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ShopifyProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyProductId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyProductId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSensorCreateWithoutMachineInput = {
    id?: string
    sensorType: string
    sensorName: string
    value: number
    unit?: string | null
    threshold?: number | null
    minValue?: number | null
    maxValue?: number | null
    status?: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type MachineSensorUncheckedCreateWithoutMachineInput = {
    id?: string
    sensorType: string
    sensorName: string
    value: number
    unit?: string | null
    threshold?: number | null
    minValue?: number | null
    maxValue?: number | null
    status?: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type MachineSensorCreateOrConnectWithoutMachineInput = {
    where: MachineSensorWhereUniqueInput
    create: XOR<MachineSensorCreateWithoutMachineInput, MachineSensorUncheckedCreateWithoutMachineInput>
  }

  export type MachineSensorCreateManyMachineInputEnvelope = {
    data: MachineSensorCreateManyMachineInput | MachineSensorCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type MachineAlertCreateWithoutMachineInput = {
    id?: string
    severity: string
    type: string
    title: string
    description?: string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MachineAlertUncheckedCreateWithoutMachineInput = {
    id?: string
    severity: string
    type: string
    title: string
    description?: string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MachineAlertCreateOrConnectWithoutMachineInput = {
    where: MachineAlertWhereUniqueInput
    create: XOR<MachineAlertCreateWithoutMachineInput, MachineAlertUncheckedCreateWithoutMachineInput>
  }

  export type MachineAlertCreateManyMachineInputEnvelope = {
    data: MachineAlertCreateManyMachineInput | MachineAlertCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type MachineMaintenanceRecordCreateWithoutMachineInput = {
    id?: string
    type: string
    description: string
    performedBy?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    cost?: number | null
    status?: string
    notes?: string | null
    attachments?: MachineMaintenanceRecordCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineMaintenanceRecordUncheckedCreateWithoutMachineInput = {
    id?: string
    type: string
    description: string
    performedBy?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    cost?: number | null
    status?: string
    notes?: string | null
    attachments?: MachineMaintenanceRecordCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineMaintenanceRecordCreateOrConnectWithoutMachineInput = {
    where: MachineMaintenanceRecordWhereUniqueInput
    create: XOR<MachineMaintenanceRecordCreateWithoutMachineInput, MachineMaintenanceRecordUncheckedCreateWithoutMachineInput>
  }

  export type MachineMaintenanceRecordCreateManyMachineInputEnvelope = {
    data: MachineMaintenanceRecordCreateManyMachineInput | MachineMaintenanceRecordCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type MachineSensorUpsertWithWhereUniqueWithoutMachineInput = {
    where: MachineSensorWhereUniqueInput
    update: XOR<MachineSensorUpdateWithoutMachineInput, MachineSensorUncheckedUpdateWithoutMachineInput>
    create: XOR<MachineSensorCreateWithoutMachineInput, MachineSensorUncheckedCreateWithoutMachineInput>
  }

  export type MachineSensorUpdateWithWhereUniqueWithoutMachineInput = {
    where: MachineSensorWhereUniqueInput
    data: XOR<MachineSensorUpdateWithoutMachineInput, MachineSensorUncheckedUpdateWithoutMachineInput>
  }

  export type MachineSensorUpdateManyWithWhereWithoutMachineInput = {
    where: MachineSensorScalarWhereInput
    data: XOR<MachineSensorUpdateManyMutationInput, MachineSensorUncheckedUpdateManyWithoutMachineInput>
  }

  export type MachineSensorScalarWhereInput = {
    AND?: MachineSensorScalarWhereInput | MachineSensorScalarWhereInput[]
    OR?: MachineSensorScalarWhereInput[]
    NOT?: MachineSensorScalarWhereInput | MachineSensorScalarWhereInput[]
    id?: StringFilter<"MachineSensor"> | string
    machineId?: StringFilter<"MachineSensor"> | string
    sensorType?: StringFilter<"MachineSensor"> | string
    sensorName?: StringFilter<"MachineSensor"> | string
    value?: FloatFilter<"MachineSensor"> | number
    unit?: StringNullableFilter<"MachineSensor"> | string | null
    threshold?: FloatNullableFilter<"MachineSensor"> | number | null
    minValue?: FloatNullableFilter<"MachineSensor"> | number | null
    maxValue?: FloatNullableFilter<"MachineSensor"> | number | null
    status?: StringFilter<"MachineSensor"> | string
    timestamp?: DateTimeFilter<"MachineSensor"> | Date | string
    createdAt?: DateTimeFilter<"MachineSensor"> | Date | string
  }

  export type MachineAlertUpsertWithWhereUniqueWithoutMachineInput = {
    where: MachineAlertWhereUniqueInput
    update: XOR<MachineAlertUpdateWithoutMachineInput, MachineAlertUncheckedUpdateWithoutMachineInput>
    create: XOR<MachineAlertCreateWithoutMachineInput, MachineAlertUncheckedCreateWithoutMachineInput>
  }

  export type MachineAlertUpdateWithWhereUniqueWithoutMachineInput = {
    where: MachineAlertWhereUniqueInput
    data: XOR<MachineAlertUpdateWithoutMachineInput, MachineAlertUncheckedUpdateWithoutMachineInput>
  }

  export type MachineAlertUpdateManyWithWhereWithoutMachineInput = {
    where: MachineAlertScalarWhereInput
    data: XOR<MachineAlertUpdateManyMutationInput, MachineAlertUncheckedUpdateManyWithoutMachineInput>
  }

  export type MachineAlertScalarWhereInput = {
    AND?: MachineAlertScalarWhereInput | MachineAlertScalarWhereInput[]
    OR?: MachineAlertScalarWhereInput[]
    NOT?: MachineAlertScalarWhereInput | MachineAlertScalarWhereInput[]
    id?: StringFilter<"MachineAlert"> | string
    machineId?: StringFilter<"MachineAlert"> | string
    severity?: StringFilter<"MachineAlert"> | string
    type?: StringFilter<"MachineAlert"> | string
    title?: StringFilter<"MachineAlert"> | string
    description?: StringNullableFilter<"MachineAlert"> | string | null
    acknowledged?: BoolFilter<"MachineAlert"> | boolean
    acknowledgedBy?: StringNullableFilter<"MachineAlert"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"MachineAlert"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"MachineAlert"> | Date | string | null
    metadata?: JsonNullableFilter<"MachineAlert">
    createdAt?: DateTimeFilter<"MachineAlert"> | Date | string
  }

  export type MachineMaintenanceRecordUpsertWithWhereUniqueWithoutMachineInput = {
    where: MachineMaintenanceRecordWhereUniqueInput
    update: XOR<MachineMaintenanceRecordUpdateWithoutMachineInput, MachineMaintenanceRecordUncheckedUpdateWithoutMachineInput>
    create: XOR<MachineMaintenanceRecordCreateWithoutMachineInput, MachineMaintenanceRecordUncheckedCreateWithoutMachineInput>
  }

  export type MachineMaintenanceRecordUpdateWithWhereUniqueWithoutMachineInput = {
    where: MachineMaintenanceRecordWhereUniqueInput
    data: XOR<MachineMaintenanceRecordUpdateWithoutMachineInput, MachineMaintenanceRecordUncheckedUpdateWithoutMachineInput>
  }

  export type MachineMaintenanceRecordUpdateManyWithWhereWithoutMachineInput = {
    where: MachineMaintenanceRecordScalarWhereInput
    data: XOR<MachineMaintenanceRecordUpdateManyMutationInput, MachineMaintenanceRecordUncheckedUpdateManyWithoutMachineInput>
  }

  export type MachineMaintenanceRecordScalarWhereInput = {
    AND?: MachineMaintenanceRecordScalarWhereInput | MachineMaintenanceRecordScalarWhereInput[]
    OR?: MachineMaintenanceRecordScalarWhereInput[]
    NOT?: MachineMaintenanceRecordScalarWhereInput | MachineMaintenanceRecordScalarWhereInput[]
    id?: StringFilter<"MachineMaintenanceRecord"> | string
    machineId?: StringFilter<"MachineMaintenanceRecord"> | string
    type?: StringFilter<"MachineMaintenanceRecord"> | string
    description?: StringFilter<"MachineMaintenanceRecord"> | string
    performedBy?: StringNullableFilter<"MachineMaintenanceRecord"> | string | null
    scheduledDate?: DateTimeNullableFilter<"MachineMaintenanceRecord"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"MachineMaintenanceRecord"> | Date | string | null
    duration?: IntNullableFilter<"MachineMaintenanceRecord"> | number | null
    cost?: FloatNullableFilter<"MachineMaintenanceRecord"> | number | null
    status?: StringFilter<"MachineMaintenanceRecord"> | string
    notes?: StringNullableFilter<"MachineMaintenanceRecord"> | string | null
    attachments?: StringNullableListFilter<"MachineMaintenanceRecord">
    createdAt?: DateTimeFilter<"MachineMaintenanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MachineMaintenanceRecord"> | Date | string
  }

  export type MachineCreateWithoutSensorsInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: MachineAlertCreateNestedManyWithoutMachineInput
    maintenanceRecords?: MachineMaintenanceRecordCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutSensorsInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: MachineAlertUncheckedCreateNestedManyWithoutMachineInput
    maintenanceRecords?: MachineMaintenanceRecordUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutSensorsInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutSensorsInput, MachineUncheckedCreateWithoutSensorsInput>
  }

  export type MachineUpsertWithoutSensorsInput = {
    update: XOR<MachineUpdateWithoutSensorsInput, MachineUncheckedUpdateWithoutSensorsInput>
    create: XOR<MachineCreateWithoutSensorsInput, MachineUncheckedCreateWithoutSensorsInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutSensorsInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutSensorsInput, MachineUncheckedUpdateWithoutSensorsInput>
  }

  export type MachineUpdateWithoutSensorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: MachineAlertUpdateManyWithoutMachineNestedInput
    maintenanceRecords?: MachineMaintenanceRecordUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutSensorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: MachineAlertUncheckedUpdateManyWithoutMachineNestedInput
    maintenanceRecords?: MachineMaintenanceRecordUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type MachineCreateWithoutAlertsInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sensors?: MachineSensorCreateNestedManyWithoutMachineInput
    maintenanceRecords?: MachineMaintenanceRecordCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutAlertsInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sensors?: MachineSensorUncheckedCreateNestedManyWithoutMachineInput
    maintenanceRecords?: MachineMaintenanceRecordUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutAlertsInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutAlertsInput, MachineUncheckedCreateWithoutAlertsInput>
  }

  export type MachineUpsertWithoutAlertsInput = {
    update: XOR<MachineUpdateWithoutAlertsInput, MachineUncheckedUpdateWithoutAlertsInput>
    create: XOR<MachineCreateWithoutAlertsInput, MachineUncheckedCreateWithoutAlertsInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutAlertsInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutAlertsInput, MachineUncheckedUpdateWithoutAlertsInput>
  }

  export type MachineUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sensors?: MachineSensorUpdateManyWithoutMachineNestedInput
    maintenanceRecords?: MachineMaintenanceRecordUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sensors?: MachineSensorUncheckedUpdateManyWithoutMachineNestedInput
    maintenanceRecords?: MachineMaintenanceRecordUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type MachineCreateWithoutMaintenanceRecordsInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sensors?: MachineSensorCreateNestedManyWithoutMachineInput
    alerts?: MachineAlertCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutMaintenanceRecordsInput = {
    id?: string
    machineId: string
    name: string
    type: string
    location: string
    manufacturer?: string | null
    model?: string | null
    serialNumber?: string | null
    installDate?: Date | string | null
    status?: string
    isActive?: boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sensors?: MachineSensorUncheckedCreateNestedManyWithoutMachineInput
    alerts?: MachineAlertUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutMaintenanceRecordsInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutMaintenanceRecordsInput, MachineUncheckedCreateWithoutMaintenanceRecordsInput>
  }

  export type MachineUpsertWithoutMaintenanceRecordsInput = {
    update: XOR<MachineUpdateWithoutMaintenanceRecordsInput, MachineUncheckedUpdateWithoutMaintenanceRecordsInput>
    create: XOR<MachineCreateWithoutMaintenanceRecordsInput, MachineUncheckedCreateWithoutMaintenanceRecordsInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutMaintenanceRecordsInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutMaintenanceRecordsInput, MachineUncheckedUpdateWithoutMaintenanceRecordsInput>
  }

  export type MachineUpdateWithoutMaintenanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sensors?: MachineSensorUpdateManyWithoutMachineNestedInput
    alerts?: MachineAlertUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutMaintenanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    machineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    installDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    configuration?: NullableJsonNullValueInput | InputJsonValue
    specifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sensors?: MachineSensorUncheckedUpdateManyWithoutMachineNestedInput
    alerts?: MachineAlertUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type ProductionCreateWithoutQualityChecksInput = {
    id?: string
    jobNumber: string
    productName: string
    productSKU?: string | null
    quantity: number
    targetQuantity: number
    completedQuantity?: number
    status: $Enums.ProductionStatus
    priority: $Enums.Priority
    startDate: Date | string
    targetDate: Date | string
    completionDate?: Date | string | null
    qualityScore?: number | null
    defectRate?: number | null
    efficiency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionUncheckedCreateWithoutQualityChecksInput = {
    id?: string
    jobNumber: string
    productName: string
    productSKU?: string | null
    quantity: number
    targetQuantity: number
    completedQuantity?: number
    status: $Enums.ProductionStatus
    priority: $Enums.Priority
    startDate: Date | string
    targetDate: Date | string
    completionDate?: Date | string | null
    qualityScore?: number | null
    defectRate?: number | null
    efficiency?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionCreateOrConnectWithoutQualityChecksInput = {
    where: ProductionWhereUniqueInput
    create: XOR<ProductionCreateWithoutQualityChecksInput, ProductionUncheckedCreateWithoutQualityChecksInput>
  }

  export type ProductionUpsertWithoutQualityChecksInput = {
    update: XOR<ProductionUpdateWithoutQualityChecksInput, ProductionUncheckedUpdateWithoutQualityChecksInput>
    create: XOR<ProductionCreateWithoutQualityChecksInput, ProductionUncheckedCreateWithoutQualityChecksInput>
    where?: ProductionWhereInput
  }

  export type ProductionUpdateToOneWithWhereWithoutQualityChecksInput = {
    where?: ProductionWhereInput
    data: XOR<ProductionUpdateWithoutQualityChecksInput, ProductionUncheckedUpdateWithoutQualityChecksInput>
  }

  export type ProductionUpdateWithoutQualityChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productSKU?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    targetQuantity?: IntFieldUpdateOperationsInput | number
    completedQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    defectRate?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionUncheckedUpdateWithoutQualityChecksInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobNumber?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productSKU?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    targetQuantity?: IntFieldUpdateOperationsInput | number
    completedQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumProductionStatusFieldUpdateOperationsInput | $Enums.ProductionStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualityScore?: NullableFloatFieldUpdateOperationsInput | number | null
    defectRate?: NullableFloatFieldUpdateOperationsInput | number | null
    efficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardCreateManyUserInput = {
    id?: string
    name: string
    type: string
    layout: JsonNullValueInput | InputJsonValue
    widgets: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    layout?: JsonNullValueInput | InputJsonValue
    widgets?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    layout?: JsonNullValueInput | InputJsonValue
    widgets?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    layout?: JsonNullValueInput | InputJsonValue
    widgets?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityCheckCreateManyProductionInput = {
    id?: string
    checkType: string
    checkDate?: Date | string
    inspector?: string | null
    passed: boolean
    score?: number | null
    defectCount?: number
    sampleSize?: number | null
    notes?: string | null
    corrective?: string | null
    attachments?: QualityCheckCreateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QualityCheckUpdateWithoutProductionInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    checkDate?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    defectCount?: IntFieldUpdateOperationsInput | number
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    corrective?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: QualityCheckUpdateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityCheckUncheckedUpdateWithoutProductionInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    checkDate?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    defectCount?: IntFieldUpdateOperationsInput | number
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    corrective?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: QualityCheckUpdateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityCheckUncheckedUpdateManyWithoutProductionInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkType?: StringFieldUpdateOperationsInput | string
    checkDate?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    defectCount?: IntFieldUpdateOperationsInput | number
    sampleSize?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    corrective?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: QualityCheckUpdateattachmentsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyInventoryInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    reference?: string | null
    reason?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroInvoiceCreateManyContactInput = {
    id?: string
    xeroId: string
    invoiceNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroBillCreateManyContactInput = {
    id?: string
    xeroId: string
    billNumber?: string | null
    reference?: string | null
    type: string
    date?: Date | string | null
    dueDate?: Date | string | null
    status: string
    lineAmountTypes?: string | null
    subTotal?: number | null
    totalTax?: number | null
    total?: number | null
    amountDue?: number | null
    amountPaid?: number | null
    amountCredited?: number | null
    currencyCode?: string
    fullyPaidOnDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroPaymentCreateManyContactInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    invoiceId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroInvoiceUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: XeroPaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type XeroInvoiceUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: XeroPaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type XeroInvoiceUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroBillUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: XeroPaymentUpdateManyWithoutBillNestedInput
  }

  export type XeroBillUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: XeroPaymentUncheckedUpdateManyWithoutBillNestedInput
  }

  export type XeroBillUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    billNumber?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    lineAmountTypes?: NullableStringFieldUpdateOperationsInput | string | null
    subTotal?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTax?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    amountDue?: NullableFloatFieldUpdateOperationsInput | number | null
    amountPaid?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCredited?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    fullyPaidOnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: XeroInvoiceUpdateOneWithoutPaymentsNestedInput
    bill?: XeroBillUpdateOneWithoutPaymentsNestedInput
  }

  export type XeroPaymentUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentCreateManyInvoiceInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    contactId?: string | null
    billId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroPaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: XeroContactUpdateOneWithoutPaymentsNestedInput
    bill?: XeroBillUpdateOneWithoutPaymentsNestedInput
  }

  export type XeroPaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentCreateManyBillInput = {
    id?: string
    xeroId: string
    date?: Date | string | null
    amount?: number | null
    currencyCode?: string
    paymentType?: string | null
    status?: string | null
    isReconciled?: boolean
    reference?: string | null
    batchPaymentId?: string | null
    contactId?: string | null
    invoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type XeroPaymentUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: XeroContactUpdateOneWithoutPaymentsNestedInput
    invoice?: XeroInvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type XeroPaymentUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type XeroPaymentUncheckedUpdateManyWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    xeroId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currencyCode?: StringFieldUpdateOperationsInput | string
    paymentType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    batchPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderItemCreateManyOrderInput = {
    id?: string
    orderItemId: string
    asin: string
    sellerSKU?: string | null
    title?: string | null
    quantityOrdered: number
    quantityShipped?: number
    itemPrice?: number | null
    itemTax?: number | null
    shippingPrice?: number | null
    shippingTax?: number | null
    giftWrapPrice?: number | null
    giftWrapTax?: number | null
    itemPromotionDiscount?: number | null
    shipPromotionDiscount?: number | null
    currency?: string
    conditionNote?: string | null
    conditionId?: string | null
    conditionSubtypeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmazonOrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    asin?: StringFieldUpdateOperationsInput | string
    sellerSKU?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityShipped?: IntFieldUpdateOperationsInput | number
    itemPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    itemTax?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingTax?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapTax?: NullableFloatFieldUpdateOperationsInput | number | null
    itemPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    shipPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    conditionNote?: NullableStringFieldUpdateOperationsInput | string | null
    conditionId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionSubtypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    asin?: StringFieldUpdateOperationsInput | string
    sellerSKU?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityShipped?: IntFieldUpdateOperationsInput | number
    itemPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    itemTax?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingTax?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapTax?: NullableFloatFieldUpdateOperationsInput | number | null
    itemPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    shipPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    conditionNote?: NullableStringFieldUpdateOperationsInput | string | null
    conditionId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionSubtypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmazonOrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    asin?: StringFieldUpdateOperationsInput | string
    sellerSKU?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    quantityOrdered?: IntFieldUpdateOperationsInput | number
    quantityShipped?: IntFieldUpdateOperationsInput | number
    itemPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    itemTax?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shippingTax?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    giftWrapTax?: NullableFloatFieldUpdateOperationsInput | number | null
    itemPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    shipPromotionDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    conditionNote?: NullableStringFieldUpdateOperationsInput | string | null
    conditionId?: NullableStringFieldUpdateOperationsInput | string | null
    conditionSubtypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyLineItemCreateManyOrderInput = {
    id?: string
    lineItemId: string
    productId?: string | null
    variantId?: string | null
    title?: string | null
    variantTitle?: string | null
    sku?: string | null
    vendor?: string | null
    quantity: number
    price?: number | null
    totalDiscount?: number | null
    grams?: number | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    fulfillmentStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyLineItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineItemId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    variantTitle?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyLineItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineItemId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    variantTitle?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyLineItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineItemId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    variantTitle?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    totalDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    fulfillmentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyVariantCreateManyProductInput = {
    id?: string
    shopifyVariantId: string
    title?: string | null
    price?: number | null
    compareAtPrice?: number | null
    sku?: string | null
    barcode?: string | null
    grams?: number | null
    weight?: number | null
    weightUnit?: string | null
    inventoryQuantity?: number
    inventoryPolicy?: string | null
    inventoryTracking?: string | null
    requiresShipping?: boolean
    taxable?: boolean
    fulfillmentService?: string | null
    position?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShopifyVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyVariantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryQuantity?: IntFieldUpdateOperationsInput | number
    inventoryPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryTracking?: NullableStringFieldUpdateOperationsInput | string | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyVariantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryQuantity?: IntFieldUpdateOperationsInput | number
    inventoryPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryTracking?: NullableStringFieldUpdateOperationsInput | string | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopifyVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopifyVariantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    grams?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryQuantity?: IntFieldUpdateOperationsInput | number
    inventoryPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryTracking?: NullableStringFieldUpdateOperationsInput | string | null
    requiresShipping?: BoolFieldUpdateOperationsInput | boolean
    taxable?: BoolFieldUpdateOperationsInput | boolean
    fulfillmentService?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSensorCreateManyMachineInput = {
    id?: string
    sensorType: string
    sensorName: string
    value: number
    unit?: string | null
    threshold?: number | null
    minValue?: number | null
    maxValue?: number | null
    status?: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type MachineAlertCreateManyMachineInput = {
    id?: string
    severity: string
    type: string
    title: string
    description?: string | null
    acknowledged?: boolean
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MachineMaintenanceRecordCreateManyMachineInput = {
    id?: string
    type: string
    description: string
    performedBy?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    cost?: number | null
    status?: string
    notes?: string | null
    attachments?: MachineMaintenanceRecordCreateattachmentsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineSensorUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    sensorType?: StringFieldUpdateOperationsInput | string
    sensorName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSensorUncheckedUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    sensorType?: StringFieldUpdateOperationsInput | string
    sensorName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineSensorUncheckedUpdateManyWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    sensorType?: StringFieldUpdateOperationsInput | string
    sensorName?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: NullableFloatFieldUpdateOperationsInput | number | null
    minValue?: NullableFloatFieldUpdateOperationsInput | number | null
    maxValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineAlertUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineAlertUncheckedUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineAlertUncheckedUpdateManyWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMaintenanceRecordUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: MachineMaintenanceRecordUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMaintenanceRecordUncheckedUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: MachineMaintenanceRecordUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineMaintenanceRecordUncheckedUpdateManyWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: MachineMaintenanceRecordUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}